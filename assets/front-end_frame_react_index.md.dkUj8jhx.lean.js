import{_ as r,D as n,o as a,c as p,k as t,a as e,I as l,R as o}from"./chunks/framework.buEibnTs.js";const i="/silver-bullet/assets/1.dwoCQ_4_.png",c="/silver-bullet/assets/2.3jxJyBL_.png",d="/silver-bullet/assets/3.DtvJKmHu.png",m="/silver-bullet/assets/4.94wO1pjn.png",u="/silver-bullet/assets/5.-j4utaxq.png",g="/silver-bullet/assets/6.B_EUVzlN.png",h="/silver-bullet/assets/7.kG6kyfIA.png",_="/silver-bullet/assets/8.iIG_CeZT.png",R="/silver-bullet/assets/9.-B7num9u.png",C="/silver-bullet/assets/10.2sVmXhSr.png",f="/silver-bullet/assets/11.vEsT1RG0.png",F=JSON.parse('{"title":"React","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/frame/react/index.md","filePath":"front-end/frame/react/index.md","lastUpdated":1710001468000}'),S={name:"front-end/frame/react/index.md"},P=o("",47),v=o("",3),x=t("p",null,[t("strong",null,"render()"),e("，是 class 组件中唯一必须实现的方法。render() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。如果 shouldComponentUpdate() 返回 false，则不会调用 render()。当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一：")],-1),D=t("code",null,"<div />",-1),U=t("li",null,"数组或 fragments。 使得 render 方法可以返回多个元素。",-1),O=t("li",null,"Portals。可以渲染子节点到不同的 DOM 子树中。",-1),b=t("li",null,"字符串或数值类型。它们在 DOM 中会被渲染为文本节点。",-1),H=t("li",null,[t("strong",null,"布尔类型或 null或undefined"),e("。什么都不渲染。")],-1),k=t("li",null,[t("p",null,[t("strong",null,"componentDidMount()"),e("，会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化比如通过网络请求获取数据、添加订阅等应该放在这里。虽然可以在 componentDidMount() 里直接调用 setState()，但将触发额外一次渲染，多调用了一次 render 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 constructor 中初始化 state 对象。")])],-1),q=o("",14);function M(T,E,A,I,N,y){const s=n("MyComponent");return a(),p("div",null,[P,t("ol",null,[v,t("li",null,[x,t("ol",null,[t("li",null,[e("React 元素。通常通过 JSX 创建。例如，无论是 "),D,e(" 还是 "),l(s),e(" 均为 React 元素。")]),U,O,b,H])]),k]),q])}const V=r(S,[["render",M]]);export{F as __pageData,V as default};
