import{_ as o,c as t,o as r,P as a}from"./chunks/framework.DtSlGNS9.js";const u=JSON.parse('{"title":"NodeJS","description":"","frontmatter":{},"headers":[],"relativePath":"back-end/nodejs.md","filePath":"back-end/nodejs.md","lastUpdated":1756990369000}'),i={name:"back-end/nodejs.md"};function s(l,e,d,n,p,c){return r(),t("div",null,[...e[0]||(e[0]=[a('<h1 id="nodejs" tabindex="-1">NodeJS <a class="header-anchor" href="#nodejs" aria-label="Permalink to &quot;NodeJS&quot;">​</a></h1><h2 id="require和import的区别" tabindex="-1">require和import的区别 <a class="header-anchor" href="#require和import的区别" aria-label="Permalink to &quot;require和import的区别&quot;">​</a></h2><ol><li>是否采用严格模式，import/export 导出的模块默认调用严格模式。</li><li>ES6 模块可以在 import 引用语句前使用模块，CommonJS 则需要先引用后使用</li><li>import/export 不能对引入模块重新赋值/定义</li><li>require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用</li><li>CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</li><li>import/export 在浏览器中无法直接使用，我们需要在引入模块的 <code>&lt;script&gt;</code> 元素上添加type=&quot;module属性</li></ol><h2 id="express" tabindex="-1">Express <a class="header-anchor" href="#express" aria-label="Permalink to &quot;Express&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">写作中 :::</p></div>',5)])])}const h=o(i,[["render",s]]);export{u as __pageData,h as default};
