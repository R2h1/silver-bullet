const t='{"documentCount":52,"nextId":52,"documentIds":{"0":"/silver-bullet/basics/data-structures-algorithms#数据结构与算法","1":"/silver-bullet/basics/data-structures-algorithms#面向对象、面向过程、面向函数","2":"/silver-bullet/basics/data-structures-algorithms#数组","3":"/silver-bullet/basics/data-structures-algorithms#集合、列表、数组","4":"/silver-bullet/basics/data-structures-algorithms#数组基本操作","5":"/silver-bullet/basics/data-structures-algorithms#为什么数组下标从-0-开始","6":"/silver-bullet/basics/data-structures-algorithms#数组的优劣","7":"/silver-bullet/basics/data-structures-algorithms#算法题","8":"/silver-bullet/basics/data-structures-algorithms#_1-二维数组的查找","9":"/silver-bullet/basics/data-structures-algorithms#_2-旋转数组的最小数字","10":"/silver-bullet/basics/internet#计算机网络","11":"/silver-bullet/basics/make-up-principle#计算机组成原理","12":"/silver-bullet/basics/make-up-principle#cpu-central-processing-unit","13":"/silver-bullet/basics/make-up-principle#内存-memory","14":"/silver-bullet/basics/make-up-principle#磁盘","15":"/silver-bullet/basics/make-up-principle#二进制","16":"/silver-bullet/basics/make-up-principle#压缩算法-compaction-algorithm","17":"/silver-bullet/basics/make-up-principle#rle算法","18":"/silver-bullet/basics/make-up-principle#huffman-哈夫曼-算法","19":"/silver-bullet/basics/os#操作系统","20":"/silver-bullet/basics/os#linux","21":"/silver-bullet/basics/os#进程与线程","22":"/silver-bullet/basics/os#进程与线程区别-即概念","23":"/silver-bullet/basics/os#进程的状态","24":"/silver-bullet/basics/os#进程通信-ipc","25":"/silver-bullet/basics/os#进程的调度算法","26":"/silver-bullet/basics/os#线程同步","27":"/silver-bullet/basics/os#死锁","28":"/silver-bullet/basics/os#并行与并发","29":"/silver-bullet/basics/os#阻塞与非阻塞","30":"/silver-bullet/basics/os#同步与异步","31":"/silver-bullet/basics/os#单线程与多线程","32":"/silver-bullet/basics/os#内存管理","33":"/silver-bullet/basics/os#内存管理机制","34":"/silver-bullet/basics/os#分页与分段","35":"/silver-bullet/basics/os#快表与多级页表","36":"/silver-bullet/basics/os#物理地址和逻辑-虚拟-地址","37":"/silver-bullet/basics/os#虚拟内存","38":"/silver-bullet/basics/os#页面置换算法-淘汰机制-算法","39":"/silver-bullet/font-end/design-patterns#前端常用设计模式","40":"/silver-bullet/font-end/design-patterns#设计模式的原则-solid","41":"/silver-bullet/font-end/design-patterns#常用的-23-种设计模式","42":"/silver-bullet/font-end/design-patterns#单例模式","43":"/silver-bullet/font-end/design-patterns#观察者模式和发布-订阅模式","44":"/silver-bullet/font-end/design-patterns#工厂模式","45":"/silver-bullet/font-end/design-patterns#迭代器模式","46":"/silver-bullet/font-end/design-patterns#原型模式","47":"/silver-bullet/font-end/design-patterns#装饰器模式","48":"/silver-bullet/font-end/design-patterns#代理模式","49":"/silver-bullet/font-end/design-patterns#策略模式","50":"/silver-bullet/font-end/design-patterns#职责链模式","51":"/silver-bullet/font-end/design-patterns#适配器模式"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[4,1,38],"2":[1,1,1],"3":[3,2,24],"4":[1,2,8],"5":[4,3,62],"6":[1,2,14],"7":[1,2,1],"8":[2,3,85],"9":[2,3,77],"10":[1,1,1],"11":[1,1,1],"12":[5,1,149],"13":[3,1,118],"14":[1,1,56],"15":[1,1,50],"16":[4,1,113],"17":[1,5,23],"18":[3,5,64],"19":[1,1,35],"20":[1,1,108],"21":[1,1,1],"22":[3,2,24],"23":[1,2,19],"24":[3,2,32],"25":[1,2,41],"26":[1,2,11],"27":[1,2,126],"28":[1,2,16],"29":[1,2,12],"30":[1,2,22],"31":[1,2,27],"32":[1,1,4],"33":[1,2,19],"34":[1,2,19],"35":[1,2,35],"36":[3,2,22],"37":[1,2,69],"38":[4,2,28],"39":[1,1,2],"40":[3,1,50],"41":[3,1,29],"42":[1,4,110],"43":[2,4,150],"44":[1,4,56],"45":[1,4,61],"46":[1,4,75],"47":[1,4,43],"48":[1,4,55],"49":[1,4,70],"50":[1,4,30],"51":[1,4,28]},"averageFieldLength":[1.6730769230769236,2.2307692307692304,44.51923076923077],"storedFields":{"0":{"title":"数据结构与算法","titles":[]},"1":{"title":"面向对象、面向过程、面向函数？","titles":["数据结构与算法"]},"2":{"title":"数组","titles":["数据结构与算法"]},"3":{"title":"集合、列表、数组","titles":["数据结构与算法","数组"]},"4":{"title":"数组基本操作","titles":["数据结构与算法","数组"]},"5":{"title":"为什么数组下标从 0 开始？","titles":["数据结构与算法","数组","数组基本操作"]},"6":{"title":"数组的优劣","titles":["数据结构与算法","数组"]},"7":{"title":"算法题","titles":["数据结构与算法","数组"]},"8":{"title":"1. 二维数组的查找","titles":["数据结构与算法","数组","算法题"]},"9":{"title":"2. 旋转数组的最小数字","titles":["数据结构与算法","数组","算法题"]},"10":{"title":"计算机网络","titles":[]},"11":{"title":"计算机组成原理","titles":[]},"12":{"title":"CPU（ Central Processing Unit）","titles":["计算机组成原理"]},"13":{"title":"内存（Memory）","titles":["计算机组成原理"]},"14":{"title":"磁盘","titles":["计算机组成原理"]},"15":{"title":"二进制","titles":["计算机组成原理"]},"16":{"title":"压缩算法（compaction algorithm）","titles":["计算机组成原理"]},"17":{"title":"RLE算法","titles":["计算机组成原理","压缩算法（compaction algorithm）"]},"18":{"title":"Huffman（哈夫曼）算法","titles":["计算机组成原理","压缩算法（compaction algorithm）"]},"19":{"title":"操作系统","titles":[]},"20":{"title":"Linux","titles":["操作系统"]},"21":{"title":"进程与线程","titles":["操作系统"]},"22":{"title":"进程与线程区别（即概念）","titles":["操作系统","进程与线程"]},"23":{"title":"进程的状态","titles":["操作系统","进程与线程"]},"24":{"title":"进程通信（IPC）","titles":["操作系统","进程与线程"]},"25":{"title":"进程的调度算法","titles":["操作系统","进程与线程"]},"26":{"title":"线程同步","titles":["操作系统","进程与线程"]},"27":{"title":"死锁","titles":["操作系统","进程与线程"]},"28":{"title":"并行与并发","titles":["操作系统","进程与线程"]},"29":{"title":"阻塞与非阻塞","titles":["操作系统","进程与线程"]},"30":{"title":"同步与异步","titles":["操作系统","进程与线程"]},"31":{"title":"单线程与多线程","titles":["操作系统","进程与线程"]},"32":{"title":"内存管理","titles":["操作系统"]},"33":{"title":"内存管理机制","titles":["操作系统","内存管理"]},"34":{"title":"分页与分段","titles":["操作系统","内存管理"]},"35":{"title":"快表与多级页表","titles":["操作系统","内存管理"]},"36":{"title":"物理地址和逻辑（虚拟）地址","titles":["操作系统","内存管理"]},"37":{"title":"虚拟内存","titles":["操作系统","内存管理"]},"38":{"title":"页面置换算法（淘汰机制/算法）","titles":["操作系统","内存管理"]},"39":{"title":"前端常用设计模式","titles":[]},"40":{"title":"设计模式的原则（SOLID）","titles":["前端常用设计模式"]},"41":{"title":"常用的 23 种设计模式","titles":["前端常用设计模式"]},"42":{"title":"单例模式","titles":["前端常用设计模式","常用的 23 种设计模式"]},"43":{"title":"观察者模式和发布-订阅模式","titles":["前端常用设计模式","常用的 23 种设计模式"]},"44":{"title":"工厂模式","titles":["前端常用设计模式","常用的 23 种设计模式"]},"45":{"title":"迭代器模式","titles":["前端常用设计模式","常用的 23 种设计模式"]},"46":{"title":"原型模式","titles":["前端常用设计模式","常用的 23 种设计模式"]},"47":{"title":"装饰器模式","titles":["前端常用设计模式","常用的 23 种设计模式"]},"48":{"title":"代理模式","titles":["前端常用设计模式","常用的 23 种设计模式"]},"49":{"title":"策略模式","titles":["前端常用设计模式","常用的 23 种设计模式"]},"50":{"title":"职责链模式","titles":["前端常用设计模式","常用的 23 种设计模式"]},"51":{"title":"适配器模式","titles":["前端常用设计模式","常用的 23 种设计模式"]}},"dirtCount":0,"index":[["链式调用",{"2":{"50":1}}],["链表等",{"2":{"3":1}}],["部分请求可能未被处理",{"2":{"50":1}}],["维护后继者",{"2":{"50":1}}],["另一种是由",{"2":{"50":1}}],["职责链适合处理对象数量不确定",{"2":{"50":1}}],["职责链的简单实现模式也分为两种",{"2":{"50":1}}],["职责链模式",{"0":{"50":1}}],["职责连模式",{"2":{"41":1}}],["策略类会增多",{"2":{"49":1}}],["策略模式",{"0":{"49":1},"2":{"41":1}}],["服务器",{"2":{"48":1}}],["反向",{"2":{"48":1}}],["客户端",{"2":{"48":1}}],["适配成",{"2":{"51":1}}],["适配器是把",{"2":{"51":1}}],["适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作",{"2":{"51":1}}],["适配器模式",{"0":{"51":1},"2":{"41":1}}],["适合在代理层做",{"2":{"48":1}}],["画一个圆",{"2":{"47":1}}],["装饰层次增多",{"2":{"47":1}}],["装饰器模式不能改变原始对象的行为",{"2":{"48":1}}],["装饰器模式相比生成子类更为灵活",{"2":{"47":1}}],["装饰器模式",{"0":{"47":1},"2":{"41":1}}],["允许向一个现有的对象添加新的功能",{"2":{"47":1}}],["允许用户定制环境",{"2":{"40":1}}],["扩展运算符很方便",{"2":{"46":1}}],["扩展性良好",{"2":{"49":1}}],["扩展性",{"2":{"40":1}}],["嵌套对象应该指向克隆对象",{"2":{"46":1}}],["那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为",{"2":{"49":1}}],["那么你可能需要定义一个特殊方法来复制对象数据",{"2":{"46":1}}],["那么剩下代码将不再执行",{"2":{"31":1}}],["构造函数必须复制参数对象中的所有成员变量值到新建实体中",{"2":{"46":1}}],["构造哈夫曼树的步骤",{"2":{"18":1}}],["克隆完成后",{"2":{"46":1}}],["克隆具有反向引用嵌套对象的对象需要特殊处理",{"2":{"46":1}}],["克隆方法可能会生成父类的对象",{"2":{"46":1}}],["克隆方法通常只有一行代码",{"2":{"46":1}}],["克隆方法会创建一个当前类的对象",{"2":{"46":1}}],["克隆包含循环引用的复杂对象可能会非常麻烦",{"2":{"46":1}}],["整体链路可能会特别长",{"2":{"46":1}}],["违背了开闭原则",{"2":{"46":1}}],["弊端",{"2":{"46":1,"47":1,"48":1}}],["传统的原型模式就是克隆",{"2":{"46":1}}],["自定义迭代器",{"2":{"45":1}}],["自定义事件",{"2":{"42":1,"43":2}}],["迭代器",{"2":{"45":1}}],["迭代器模式",{"0":{"45":1},"2":{"41":1}}],["主要思想是将集合的遍历行为抽取为单独的迭代器对象",{"2":{"45":1}}],["主要由两部分构成",{"2":{"12":1}}],["表",{"2":{"45":1}}],["表示将申请后的剩余资源先分配给p3",{"2":{"27":1}}],["表示当前分配给进程的资源",{"2":{"27":1}}],["表示进程对资源的需求",{"2":{"27":1}}],["表示强迫进程立即停止",{"2":{"20":1}}],["表示列出文件详情信息",{"2":{"20":1}}],["表示显示所有文件",{"2":{"20":1}}],["表示的字节数据有",{"2":{"16":1}}],["表示的是数据信号",{"2":{"13":1}}],["表示位权",{"2":{"15":1}}],["表示可以指定",{"2":{"13":1}}],["表示一次可以输入输出",{"2":{"13":1}}],["表示电源",{"2":{"13":1}}],["表示",{"2":{"12":1}}],["表示数组的首地址的寻址公式",{"2":{"5":1}}],["弱化对象实体间的引用关系",{"2":{"43":1}}],["否则",{"2":{"46":1}}],["否则可能会导致内存泄漏",{"2":{"43":1}}],["否则不安全",{"2":{"27":1}}],["没有意义的代理只会徒增程序开销",{"2":{"48":1}}],["没有",{"2":{"43":1}}],["没有结果之前不会返回",{"2":{"30":1}}],["推荐使用",{"2":{"43":1}}],["`",{"2":{"43":1}}],["`$",{"2":{"43":1}}],["$",{"2":{"43":1}}],["添加观察者",{"2":{"43":1}}],["目标数据自行控制内部迭代逻辑",{"2":{"45":1}}],["目标",{"2":{"43":1}}],["目的在于确定进程的执行顺序",{"2":{"25":1}}],["目的在于进程间同步并避免竞争条件",{"2":{"24":1}}],["目的是在不改变原有文件属性的前提下",{"2":{"16":1}}],["选项",{"2":{"43":1}}],["选择就绪队列中估计运行时间最短的进程运行",{"2":{"25":1}}],["订阅者需要从事件通道订阅事件",{"2":{"43":1}}],["订阅模式场景",{"2":{"43":1}}],["订阅模式",{"0":{"43":1}}],["发布订阅模式实现",{"2":{"43":1}}],["发布订阅模式中的事件通道可更细粒度处理",{"2":{"43":1}}],["发布事件",{"2":{"43":1}}],["发布者",{"2":{"43":1}}],["接收事件",{"2":{"43":1}}],["接口的调用者不应该被强迫依赖它不需要的接口",{"2":{"40":1}}],["接口隔离原则",{"2":{"40":1}}],["绑定事件",{"2":{"43":1}}],["观察者",{"2":{"43":2}}],["观察者模式实现",{"2":{"43":1}}],["观察者模式场景",{"2":{"43":1}}],["观察者模式和发布",{"0":{"43":1}}],["观察者模式",{"2":{"41":1}}],["外部只能",{"2":{"42":1}}],["闭包实现单例",{"2":{"42":1}}],["闭包",{"2":{"42":2}}],["|",{"2":{"42":1,"45":2}}],["||",{"2":{"8":2,"42":5,"43":5}}],["利用代理实现单例",{"2":{"42":1}}],["利用局部性原理实现髙速缓存",{"2":{"37":1}}],["注意",{"2":{"42":1,"46":1}}],["弹窗",{"2":{"42":1}}],["登录",{"2":{"42":2}}],["场景",{"2":{"42":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1}}],["节约系统资源",{"2":{"42":1}}],["减少过多的类生成需要的内存和运行时间",{"2":{"42":1}}],["减少内存碎片",{"2":{"34":1}}],["保证一个类仅有一个实例",{"2":{"42":1}}],["保存到磁盘文件",{"2":{"36":1}}],["状态模式",{"2":{"41":1}}],["备忘录模式",{"2":{"41":1}}],["命令模式",{"2":{"41":1}}],["命令的多功能产品",{"2":{"20":1}}],["模式实现",{"2":{"42":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1}}],["模板方法模式",{"2":{"41":1}}],["模块化实现单例",{"2":{"42":1}}],["模块",{"2":{"40":1}}],["行为型模式",{"2":{"41":1}}],["行程长度编码",{"2":{"16":1,"17":1}}],["享元模式",{"2":{"41":1}}],["组合过程的复杂",{"2":{"47":1}}],["组合模式",{"2":{"41":1}}],["组件中使用自定义事件",{"2":{"43":1}}],["组成二叉树",{"2":{"18":1}}],["组成的",{"2":{"13":1}}],["桥接模式",{"2":{"41":1}}],["原型类必须另行定义一个以该类对象为参数的构造函数",{"2":{"46":1}}],["原型",{"2":{"46":1}}],["原型模式",{"0":{"46":1},"2":{"41":1}}],["原码就是数的二进制表示",{"2":{"15":1}}],["建造者模式",{"2":{"41":1}}],["抽象工厂模式",{"2":{"41":1}}],["工厂中的创建逻辑也可以自由扩展",{"2":{"44":1}}],["工厂和类分离",{"2":{"44":1}}],["工厂",{"2":{"44":1}}],["工厂方法模式",{"2":{"41":1}}],["工厂模式",{"0":{"44":1},"2":{"41":1}}],["加粗的是前端常用",{"2":{"41":1}}],["常用的",{"0":{"41":1},"1":{"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1}}],["常见操作系统有",{"2":{"19":1}}],["寻求90",{"2":{"40":1}}],["考虑多环境",{"2":{"40":1}}],["软件复用",{"2":{"40":1}}],["软件实体",{"2":{"40":1}}],["充分利用软件得杠杆效应",{"2":{"40":1}}],["舍弃高效率",{"2":{"40":1}}],["让父类复制其私有成员变量值",{"2":{"46":1}}],["让每个程序只做一件事",{"2":{"40":1}}],["让该进程继续等待",{"2":{"27":1}}],["依赖于抽象而不依赖于具体",{"2":{"40":1}}],["依赖倒置原则",{"2":{"40":1,"44":1}}],["子类对象能够替换程序中父类对象出现的任何地方",{"2":{"40":1}}],["子数组有序",{"2":{"9":1}}],["里式替换原则",{"2":{"40":1}}],["应该对扩展开放",{"2":{"40":1}}],["方法",{"2":{"46":2}}],["方法等",{"2":{"40":1}}],["方式",{"2":{"26":1}}],["开放封闭原则",{"2":{"40":1}}],["开始的计算机寻址公式",{"2":{"5":1}}],["开始",{"0":{"5":1},"2":{"5":2}}],["提高了类或者模块的内聚性",{"2":{"40":1}}],["提取",{"2":{"12":1}}],["设置边框颜色",{"2":{"47":1}}],["设计模式的原则",{"0":{"40":1}}],["设计模式是通过代码设计经验总结出的解决问题的一系列套路",{"2":{"39":1}}],["设备",{"2":{"20":1}}],["设备管理",{"2":{"19":1}}],["设备驱动和文件系统",{"2":{"19":1}}],["赋予每页一个上次访问所经历的时间t字段",{"2":{"38":1}}],["赋值更改",{"2":{"5":1}}],["淘汰t值最大的页",{"2":{"38":1}}],["淘汰在内存中驻留时间最久的页",{"2":{"38":1}}],["淘汰机制",{"0":{"38":1}}],["置换所需外存中的页",{"2":{"38":1}}],["缺点",{"2":{"49":1,"50":1,"51":1}}],["缺点是复杂场景不易追踪维护和理解",{"2":{"43":1}}],["缺点是扩展性差和职责过重",{"2":{"42":1}}],["缺页时淘汰链表尾节点的页",{"2":{"38":1}}],["缺页中断时将选择合适的内存中的页调出",{"2":{"38":1}}],["缺段",{"2":{"37":1}}],["倍",{"2":{"37":1}}],["生成和管理",{"2":{"37":1}}],["该文件由",{"2":{"37":1}}],["该方法的压缩比较大",{"2":{"16":1}}],["该方法的压缩比",{"2":{"16":1}}],["采用纯文本方式来存储数据",{"2":{"40":1}}],["采用的是分页式",{"2":{"37":1}}],["采用虚拟寻址",{"2":{"36":1}}],["称为缺页",{"2":{"37":1}}],["需执行的指令或数据未在内存",{"2":{"37":1}}],["需要对应对象也实现",{"2":{"46":1}}],["需要可以使用",{"2":{"43":1}}],["需要在代码中触发",{"2":{"43":1}}],["需要直接订阅目标事件",{"2":{"43":1}}],["需要额外的操作才能得到预期的结果是为异步",{"2":{"30":1}}],["需要破坏死锁发生的必要条件之一",{"2":{"27":1}}],["需要实时处理或传输数据",{"2":{"16":1}}],["换空间",{"2":{"37":1}}],["换队首进程运行",{"2":{"25":1}}],["产生于指令的顺序存放和顺序执行",{"2":{"37":1}}],["产生于程序存在的循环操作",{"2":{"37":1}}],["空间局部性",{"2":{"37":1}}],["空闲物理内存",{"2":{"20":1}}],["局部性原理",{"2":{"37":1}}],["会增加调试成本",{"2":{"47":1}}],["会影响到操作系统",{"2":{"36":1}}],["会对操作系统造成伤害",{"2":{"36":1}}],["虚拟内存技术就是建立了",{"2":{"37":1}}],["虚拟内存定义了一个连续的虚拟",{"2":{"37":1}}],["虚拟内存",{"0":{"37":1}}],["虚拟地址允许访问大于可用物理内存的内存缓冲区",{"2":{"36":1}}],["虚拟地址允许一系列相邻的虚拟地址访问真实物理地址不连续的内存区域",{"2":{"36":1}}],["虚拟",{"0":{"36":1}}],["使得页表占用的内存空间大幅减少",{"2":{"35":1}}],["使用代理",{"2":{"48":1}}],["使用者不关心目标数据的内部结构",{"2":{"45":1}}],["使用者和目标数据分离",{"2":{"45":1}}],["使用情况统计",{"2":{"20":1}}],["使用的内存占比",{"2":{"20":1}}],["使用的",{"2":{"20":1}}],["使用的交换区等",{"2":{"20":1}}],["使用",{"2":{"13":1,"20":1,"46":1}}],["尤其是根本就不需要的页表",{"2":{"35":1}}],["再从页表中得到物理地址",{"2":{"35":1}}],["转换流程如下",{"2":{"35":1}}],["引入多级页表",{"2":{"35":1}}],["引入块表后",{"2":{"35":1}}],["引脚来进行数据的读写",{"2":{"13":1}}],["要生成过多的对象",{"2":{"47":1}}],["要修改已有类时",{"2":{"46":1}}],["要访问两次主存",{"2":{"35":1}}],["要求运行时间",{"2":{"25":2}}],["之于",{"2":{"35":1}}],["之间加入一个事件通道",{"2":{"43":1}}],["之间",{"2":{"13":1}}],["类",{"2":{"40":1}}],["类似于redis",{"2":{"35":1}}],["类型相同",{"2":{"3":1}}],["类型不一定相同",{"2":{"3":2}}],["快表与多级页表",{"0":{"35":1}}],["快速建立原型",{"2":{"40":1}}],["快速",{"2":{"16":1}}],["体现为代码段",{"2":{"34":1}}],["仅为满足操作系统内存管理需求",{"2":{"34":1}}],["物理内存页+磁盘文件",{"2":{"36":1}}],["物理信息单位",{"2":{"34":1}}],["物理地址和逻辑",{"0":{"36":1}}],["物理地址",{"2":{"33":1}}],["先进先出页面置换算法",{"2":{"38":1}}],["先分段再分页",{"2":{"33":1}}],["先到先服务",{"2":{"25":1}}],["段取决于当前运行的程序",{"2":{"34":1}}],["段之内",{"2":{"34":1}}],["段之间",{"2":{"34":1}}],["段页式管理",{"2":{"33":1}}],["段表",{"2":{"33":1}}],["段式管理",{"2":{"33":1}}],["逻辑信息单位",{"2":{"34":1}}],["逻辑",{"2":{"33":1,"37":1}}],["逻辑地址转换为物理地址",{"2":{"32":1}}],["页面置换算法目的是选择内存中合适的页淘汰掉",{"2":{"38":1}}],["页面置换算法",{"0":{"38":1},"2":{"38":3}}],["页文件",{"2":{"37":1}}],["页调入调出时间",{"2":{"37":1}}],["页表的高速缓冲存储器",{"2":{"35":1}}],["页表记录",{"2":{"33":1}}],["页大小固定",{"2":{"34":1}}],["页之内均为连续的",{"2":{"34":1}}],["页之间均为离散存储",{"2":{"34":1}}],["页是物理信息单位",{"2":{"33":1}}],["页式管理",{"2":{"33":1}}],["碎片",{"2":{"33":1}}],["块中容易形成未被利用的内存空间",{"2":{"33":1}}],["块式管理",{"2":{"33":1}}],["连续分配管理",{"2":{"33":1}}],["性能问题",{"2":{"31":1}}],["性能更高",{"2":{"20":1}}],["安全问题",{"2":{"31":1}}],["安全性算法",{"2":{"27":1}}],["竞态条件",{"2":{"31":1}}],["竞争资源",{"2":{"27":1}}],["避免使用多重条件判断",{"2":{"49":1}}],["避免对共享资源的多重占用",{"2":{"42":1}}],["避免强制性的用户界面",{"2":{"40":1}}],["避免将不相关的代码耦合在一起",{"2":{"40":1}}],["避免数据竞争和死锁",{"2":{"31":1}}],["避免阻塞",{"2":{"31":1}}],["避免死锁",{"2":{"27":1}}],["代理",{"2":{"48":1}}],["代理与",{"2":{"48":1}}],["代理对象过多",{"2":{"48":1}}],["代理模式会增加微弱的开销",{"2":{"48":1}}],["代理模式",{"0":{"48":1},"2":{"41":1}}],["代码整体复杂度增加",{"2":{"51":1}}],["代码复用",{"2":{"40":1}}],["代码运行的环境不同",{"2":{"31":1}}],["代价指优先级",{"2":{"27":1}}],["逐行执行",{"2":{"31":1}}],["逐步向后查询",{"2":{"5":1}}],["单例模式需要加线程锁",{"2":{"42":1}}],["单例模式在一定情况下可以节约内存",{"2":{"42":1}}],["单例模式能保证全局的唯一性",{"2":{"42":1}}],["单例模式",{"0":{"42":1},"2":{"41":1}}],["单一职责原则",{"2":{"40":1}}],["单线程",{"2":{"31":1}}],["单线程与多线程",{"0":{"31":1}}],["单向数据流动",{"2":{"24":2}}],["异步指两个或两个以上的对象或事件不同时存在或发生",{"2":{"30":1}}],["异步",{"2":{"30":1}}],["信息的即时沟通方式",{"2":{"30":1}}],["信号量",{"2":{"24":2,"26":1}}],["信号",{"2":{"24":1,"27":1}}],["信号均是",{"2":{"13":1}}],["地址空间",{"2":{"37":1}}],["地址",{"0":{"36":1}}],["地址信号",{"2":{"13":2}}],["地收取",{"2":{"30":1}}],["各种异步回调",{"2":{"43":1}}],["各线程独立",{"2":{"31":1}}],["各方都实时",{"2":{"30":1}}],["各部分之间通过电信号连通",{"2":{"12":1}}],["同时又不改变其结构",{"2":{"47":1}}],["同时访问同一物理内存地址而崩溃",{"2":{"36":1}}],["同时将页表中的该映射表项添加到快表中",{"2":{"35":1}}],["同时容易代码阻塞",{"2":{"31":1}}],["同步问题",{"2":{"31":1}}],["同步时调用者主动等待调用过程",{"2":{"30":1}}],["同步",{"2":{"30":1}}],["同步与异步",{"0":{"30":1}}],["同静态图像的编码",{"2":{"16":1}}],["阻塞是指调用在等待的过程中线程被挂起",{"2":{"29":1}}],["阻塞",{"2":{"29":1}}],["阻塞与非阻塞",{"0":{"29":1}}],["阻塞状态",{"2":{"23":1}}],["指定",{"2":{"46":1}}],["指程序的设计结构",{"2":{"28":1}}],["指程序的运行状态",{"2":{"28":1}}],["指令译码器按照预定的指令格式",{"2":{"12":1}}],["指令译码是在取完指令后",{"2":{"12":1}}],["指令译码",{"2":{"12":1}}],["指令的功能是把保存在栈中的指令地址设定到程序计数器",{"2":{"12":1}}],["指令会把函数调用后要执行的指令地址存储在名为栈的主存内",{"2":{"12":1}}],["指令",{"2":{"12":2}}],["指令寄存器",{"2":{"12":1}}],["撤消进程",{"2":{"27":1}}],["剥夺资源",{"2":{"27":1}}],["检测死锁",{"2":{"27":1}}],["回收和地址转换",{"2":{"32":1}}],["回收",{"2":{"27":3}}],["剩余资源数量增加",{"2":{"27":1}}],["则必须调用父类构造函数",{"2":{"46":1}}],["则只需在其所有类中添加该方法即可",{"2":{"46":1}}],["则系统处于安全状态",{"2":{"27":1}}],["则系统处于不安全状态",{"2":{"27":1}}],["则假设p3执行完毕后回收已分配给它的资源并标记为可完成",{"2":{"27":1}}],["随时间推移",{"2":{"27":1}}],["随机存储器",{"2":{"13":1}}],["随机访问即时间复杂度o",{"2":{"4":1}}],["能在不暴露集合底层表现形式",{"2":{"45":1}}],["能更好满足用户需求",{"2":{"34":1}}],["能实现多任务运行的过程就是并发",{"2":{"28":1}}],["能不能使进程队列的某个进程执行完毕",{"2":{"27":1}}],["能还原到压缩前状态的压缩称为可逆压缩",{"2":{"16":1}}],["判断分配给p1后剩余的资源",{"2":{"27":1}}],["判断数组中是否含有该整数",{"2":{"8":1}}],["若用户能访问任意物理内存",{"2":{"36":1}}],["若采用页表做地址转换",{"2":{"35":1}}],["若所有进程都将能执行完毕",{"2":{"27":1}}],["若存在进程p3可执行完毕",{"2":{"27":1}}],["若没有进程可执行完毕",{"2":{"27":1}}],["若不安全则试探分配作废",{"2":{"27":1}}],["若无外力作用",{"2":{"27":1}}],["银行家算法通过先试探分配给该进程资源",{"2":{"27":1}}],["及两个二维数组claim",{"2":{"27":1}}],["及数值不变的情况下",{"2":{"15":1}}],["未分配给进程的每种资源的总量",{"2":{"27":1}}],["系统终将处于死锁状态",{"2":{"27":1}}],["系统的安全状态是指至少存在一个资源分配序列不会导致死锁",{"2":{"27":1}}],["系统的状态是当前给进程分配的资源情况",{"2":{"27":1}}],["系统中每种资源的总量",{"2":{"27":1}}],["包含两个一维数组resource",{"2":{"27":1}}],["包括",{"2":{"41":1}}],["包括隐藏文件",{"2":{"20":1}}],["包括数组",{"2":{"3":1}}],["申请的时候按序号从小到大进行申请",{"2":{"27":1}}],["申请使用系统态级别的资源",{"2":{"19":1}}],["所有策略类都需要对外暴露",{"2":{"49":1}}],["所谓按序申请",{"2":{"27":1}}],["所以并行需要多个线程在同一时间执行多件事情",{"2":{"28":1}}],["所以需要磁盘缓存负责存储经常访问的内容",{"2":{"14":1}}],["所以可以分成以下情况",{"2":{"9":1}}],["非连续分配管理",{"2":{"33":1}}],["非阻塞是指等待的过程",{"2":{"29":1}}],["非阻塞",{"2":{"29":1}}],["非请求",{"2":{"27":1}}],["非循环等待",{"2":{"27":1}}],["非保持",{"2":{"27":1}}],["非尾部删除",{"2":{"5":1}}],["非尾部插入",{"2":{"5":1}}],["预防死锁是严格防止死锁的出现",{"2":{"27":1}}],["预防死锁",{"2":{"27":1}}],["缓冲区内的消息等",{"2":{"27":1}}],["消息",{"2":{"27":1}}],["消息队列克服了信号承载信息量少",{"2":{"24":1}}],["消息队列是内核中由消息队列标识符标识的消息构成的链表",{"2":{"24":1}}],["消息队列",{"2":{"24":1}}],["临时资源包括硬件中断",{"2":{"27":1}}],["与之相对的是可以再被其他进程或系统剥夺的可剥夺性资源",{"2":{"27":1}}],["打印机等",{"2":{"27":1}}],["打包并压缩",{"2":{"20":1}}],["必然存在一个进程",{"2":{"27":1}}],["必然会读到相同的内容",{"2":{"14":1}}],["环路等待条件",{"2":{"27":1}}],["请先注册",{"2":{"42":1}}],["请求段页式存储管理",{"2":{"37":1}}],["请求分段存储管理",{"2":{"37":1}}],["请求分页存储管理",{"2":{"37":1}}],["请求和保持条件",{"2":{"27":1}}],["请完成一个函数",{"2":{"8":1}}],["死锁产生的两类原因",{"2":{"27":1}}],["死锁的发生必须具备以下四个必要条件",{"2":{"27":1}}],["死锁是指两个或两个以上的进程在运行过程中因争夺资源或因彼此通信而造成的一一种阻塞的现象",{"2":{"27":1}}],["死锁",{"0":{"27":1}}],["便于实现多线程优先级的比较操作",{"2":{"26":1}}],["事件冒泡机制",{"2":{"50":1}}],["事件委托",{"2":{"48":1}}],["事件代理",{"2":{"48":1}}],["事件",{"2":{"26":1,"43":1}}],["等待时间越长或运行时间越短响应比越高",{"2":{"25":1}}],["等待资源或",{"2":{"23":1}}],["已等待时间",{"2":{"25":1}}],["已用物理内存",{"2":{"20":1}}],["优点",{"2":{"44":1,"45":1,"49":1,"50":1,"51":1}}],["优点是时间上解耦",{"2":{"43":1}}],["优点是提供了对唯一实例的受控访问",{"2":{"42":1}}],["优先的原则",{"2":{"25":1}}],["优先级",{"2":{"25":2}}],["优先照顾了短进程而忽略了长进程",{"2":{"25":1}}],["优化解法",{"2":{"8":1,"9":1}}],["短进程优先",{"2":{"25":1}}],["短数据类型转换为长数据类型",{"2":{"15":1}}],["实例本身就支持自定义事件",{"2":{"43":1}}],["实际上被分隔成多个物理内存碎片或部分存储在外部磁盘存储器",{"2":{"37":1}}],["实际上是在",{"2":{"12":1}}],["实现请求在多个对象之间的传递",{"2":{"50":1}}],["实现起来比较麻烦",{"2":{"46":1}}],["实现单例",{"2":{"42":1}}],["实现了高内聚",{"2":{"42":1}}],["实现方式可以是",{"2":{"37":1}}],["实现",{"2":{"25":1}}],["还可用于不同机器之间的进程",{"2":{"24":1}}],["还包括磁盘",{"2":{"14":1}}],["套接字",{"2":{"24":1}}],["互不影响",{"2":{"31":1}}],["互斥条件",{"2":{"27":1}}],["互斥量",{"2":{"26":1}}],["互斥锁",{"2":{"24":1}}],["互异",{"2":{"3":1}}],["往往配合其他通信机制",{"2":{"24":1}}],["管道只能承载无格式字节流和缓冲区大小受限等缺点",{"2":{"24":1}}],["且能立即得到结果的",{"2":{"30":1}}],["且无论是否亲缘关系的进程通信",{"2":{"24":1}}],["且仅具有亲缘关系的进程通信",{"2":{"24":1}}],["有时直接更改服务类使其与其他代码兼容会更简单",{"2":{"51":1}}],["有时只需访问一次高速缓冲存储器和一次主存",{"2":{"35":1}}],["有名管道",{"2":{"24":1}}],["有序",{"2":{"3":2}}],["存在于磁盘",{"2":{"24":1}}],["存在于内存",{"2":{"24":1}}],["存储着",{"2":{"18":1}}],["存储栈区域的起始位置",{"2":{"12":1}}],["存储任意数据",{"2":{"12":1}}],["存储基址寄存器的相对地址",{"2":{"12":1}}],["存储数据内存的起始位置",{"2":{"12":1}}],["存储运行的数据和运算后的数据",{"2":{"12":1}}],["出来的子进程",{"2":{"24":1}}],["出字符中权值",{"2":{"18":1}}],["半双工通信",{"2":{"24":2}}],["结构型模式",{"2":{"41":1}}],["结束状态",{"2":{"23":1}}],["结果数据经常被写到",{"2":{"12":1}}],["结果写回",{"2":{"12":2}}],["结果为负表示",{"2":{"12":1}}],["结果为零表示",{"2":{"12":1}}],["结果为正表示",{"2":{"12":1}}],["操作完成",{"2":{"23":1}}],["操作系统在页表方案基础之上引入了快表",{"2":{"35":1}}],["操作系统支持额外的扩展",{"2":{"19":1}}],["操作系统是运行在计算机上管理计算机硬件与软件资源的软件程序",{"2":{"19":1}}],["操作系统",{"0":{"19":1},"1":{"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1,"38":1}}],["就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器",{"2":{"51":1}}],["就增加功能来说",{"2":{"47":1}}],["就按照一定的淘汰策略淘汰掉快表中的一个页",{"2":{"35":1}}],["就访问内存中的页表",{"2":{"35":1}}],["就差",{"2":{"23":1}}],["就绪状态",{"2":{"23":1}}],["就是少了一次减法指令",{"2":{"5":1}}],["独享栈和寄存器等资源",{"2":{"22":1}}],["静态变量",{"2":{"22":1}}],["静态语言",{"2":{"3":1}}],["全局变量",{"2":{"22":1}}],["资源还在该线程中",{"2":{"29":1}}],["资源被分配到其他地方去",{"2":{"29":1}}],["资源的环形链",{"2":{"27":1}}],["资源就可运行",{"2":{"23":1}}],["资源",{"2":{"22":1}}],["占用大量",{"2":{"22":1}}],["占比",{"2":{"20":1}}],["却对其余进程不友好",{"2":{"22":1}}],["调度",{"2":{"22":1,"25":1}}],["更有弹性",{"2":{"20":1}}],["更改元素",{"2":{"5":1}}],["参数",{"2":{"20":1}}],["网络状态",{"2":{"20":1}}],["网络现场直播",{"2":{"16":1}}],["监控",{"2":{"20":1}}],["监控全部或指定进程占用系统资源情况",{"2":{"20":1}}],["针对特定进程进行统计",{"2":{"20":1}}],["情况统计",{"2":{"20":1}}],["using",{"2":{"49":1}}],["used",{"2":{"38":2}}],["updated",{"2":{"43":1}}],["update",{"2":{"43":2}}],["u",{"2":{"20":1}}],["unix操作系统采用",{"2":{"25":1}}],["unix",{"2":{"19":1,"40":1}}],["unit",{"0":{"12":1},"2":{"12":2}}],["undefined",{"2":{"5":1,"45":2}}],["线性化申请避免循环",{"2":{"27":1}}],["线性的问题",{"2":{"1":1}}],["线程还能做其他的事情",{"2":{"29":1}}],["线程同步是两个或多个共享关键资源的线程在并发执行过程中避免资源冲突",{"2":{"26":1}}],["线程同步",{"0":{"26":1}}],["线程共享堆",{"2":{"22":1}}],["线程共享进程的地址数据空间",{"2":{"22":1}}],["线程从属于进程",{"2":{"22":1}}],["线程是",{"2":{"22":1}}],["线程等",{"2":{"20":1}}],["任务切换",{"2":{"20":1}}],["handler",{"2":{"50":1}}],["hasnext",{"2":{"45":3}}],["how",{"2":{"49":1}}],["html",{"2":{"42":2}}],["h",{"2":{"20":1}}],["huffman",{"0":{"18":1},"2":{"16":2,"18":5}}],["huffman编码",{"2":{"16":1}}],["交换区总量",{"2":{"20":1}}],["总物理内存",{"2":{"20":1}}],["总进程",{"2":{"20":1}}],["统计",{"2":{"20":1}}],["睡眠进程等",{"2":{"20":1}}],["运行代价",{"2":{"27":1}}],["运行状态",{"2":{"23":1}}],["运行进程",{"2":{"20":1}}],["运算符",{"2":{"46":1}}],["运算符调用原型版本的构造函数",{"2":{"46":1}}],["运算符后会马上返回结果对象",{"2":{"46":1}}],["运算结果的正",{"2":{"12":1}}],["运算器",{"2":{"14":1}}],["运算器负责运算从内存中读入寄存器的数据",{"2":{"12":1}}],["运算器和时钟四部分组成",{"2":{"12":1}}],["搜索",{"2":{"20":1}}],["终止进程",{"2":{"20":1}}],["显示所有状态",{"2":{"20":1}}],["显示当前所在目录",{"2":{"20":1}}],["动态地给一个对象添加一些额外的职责",{"2":{"47":1}}],["动态将需要的部分调入内存",{"2":{"37":1}}],["动态打印文件内容",{"2":{"20":1}}],["动态语言",{"2":{"3":1}}],["zcvf",{"2":{"20":1}}],["创建原型接口",{"2":{"46":1}}],["创建对象的一种方式",{"2":{"44":1}}],["创建型模式",{"2":{"41":1}}],["创建状态",{"2":{"23":1}}],["创建空文件",{"2":{"20":1}}],["创建目录",{"2":{"20":1}}],["移除目录",{"2":{"20":1}}],["移位后需在最高位填充符号位的值",{"2":{"15":1}}],["移位运算",{"2":{"15":1}}],["进行进程间同步",{"2":{"24":1}}],["进程间的推进顺序非法",{"2":{"27":1}}],["进程集合",{"2":{"27":1}}],["进程已获得的资源在未使用完之前",{"2":{"27":1}}],["进程要求对所分配的资源进行排它性控制",{"2":{"27":1}}],["进程性质和类型",{"2":{"25":1}}],["进程的重要性和价值等",{"2":{"27":1}}],["进程的调度算法",{"0":{"25":1}}],["进程的状态",{"0":{"23":1}}],["进程占用资源多于线程",{"2":{"22":1}}],["进程拥有独立的地址数据空间",{"2":{"22":1}}],["进程是系统资源分配的最小独立单位",{"2":{"22":1}}],["进程和线程都是在程序执行过程中的运行活动",{"2":{"22":1}}],["进程与线程区别",{"0":{"22":1}}],["进程与线程",{"0":{"21":1},"1":{"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1}}],["进程详细信息",{"2":{"20":1}}],["进程数统计",{"2":{"20":1}}],["进程通信",{"0":{"24":1},"2":{"19":1}}],["进程控制",{"2":{"19":1}}],["进制的数",{"2":{"15":1}}],["sure",{"2":{"49":1}}],["sub",{"2":{"43":4}}],["subscriber",{"2":{"43":2}}],["substitution",{"2":{"40":1}}],["subject",{"2":{"43":3}}],["symbol",{"2":{"45":2}}],["synchronous",{"2":{"30":1}}],["splice",{"2":{"43":1}}],["server",{"2":{"48":1}}],["set",{"2":{"49":2}}],["setstrategy",{"2":{"49":2}}],["setstate",{"2":{"43":2}}],["setborder",{"2":{"47":2}}],["settimeout",{"2":{"43":1}}],["segregation",{"2":{"40":1}}],["strategy",{"2":{"49":17}}],["string",{"2":{"43":5,"44":7,"48":3,"49":6}}],["state",{"2":{"43":7}}],["static",{"2":{"42":2}}],["style",{"2":{"42":2}}],["store",{"2":{"42":1}}],["s2",{"2":{"42":3}}],["s1",{"2":{"42":3}}],["shared",{"2":{"19":1}}],["sorting",{"2":{"49":3}}],["sort",{"2":{"43":1,"49":1}}],["somemethod",{"2":{"42":1}}],["solid",{"0":{"40":1}}],["so",{"2":{"19":1}}],["singleton",{"2":{"42":12}}],["single",{"2":{"40":1}}],["signal",{"2":{"16":1}}],["size",{"2":{"5":4}}],["支持按需装载",{"2":{"19":1}}],["图像文件",{"2":{"18":1}}],["图中的",{"2":{"13":1}}],["文本文件",{"2":{"18":1}}],["文件的大小和虚拟内存大小相同",{"2":{"37":1}}],["文件等资源",{"2":{"22":1}}],["文件",{"2":{"20":1}}],["文件管理",{"2":{"19":1}}],["文件类型",{"2":{"18":1}}],["文件采用的就是非可逆压缩",{"2":{"16":1}}],["文件中的字节数都是连续存储的",{"2":{"16":1}}],["文件是字节数据的集合",{"2":{"16":1}}],["树作为压缩算法",{"2":{"18":1}}],["直接接收事件并作出响应",{"2":{"43":1}}],["直接从快表中读取相应的物理地址",{"2":{"35":1}}],["直接删除",{"2":{"5":1}}],["直到有对象处理它为止",{"2":{"50":1}}],["直到有足够的资源可用和死锁状态消除为止",{"2":{"27":1}}],["直到频率表为空",{"2":{"18":1}}],["步",{"2":{"18":1}}],["频率",{"2":{"18":1}}],["哈夫曼",{"0":{"18":1}}],["经常用于压缩传真的图像等",{"2":{"17":1}}],["也会导致调试困难",{"2":{"48":1}}],["也就是",{"2":{"17":1,"30":1}}],["也可用于多媒体数据的压缩",{"2":{"16":1}}],["也可以写入数据",{"2":{"13":1}}],["也可以从右上角开始",{"2":{"8":1}}],["重点是",{"2":{"28":1}}],["重复次数",{"2":{"17":1}}],["重构的数据只是原始数据的一个近似",{"2":{"16":1}}],["复杂的",{"2":{"16":1}}],["≤50",{"2":{"16":1}}],["编辑器",{"2":{"20":1}}],["编码信息和压缩过的数据",{"2":{"18":1}}],["编码算法和",{"2":{"16":1}}],["编码和分形编码编码难而解码容易",{"2":{"16":1}}],["编解码一般要求延时",{"2":{"16":1}}],["音频点播",{"2":{"16":1}}],["音感编码",{"2":{"16":1}}],["视频会议",{"2":{"16":1}}],["视频",{"2":{"16":1}}],["播放",{"2":{"16":1}}],["帧内编码是指在一帧图像内独立完成的编码方法",{"2":{"16":1}}],["但",{"2":{"43":2}}],["但用于密码学的编码方法则相反",{"2":{"16":1}}],["但也有不对称的",{"2":{"16":1}}],["但是当机器停电时",{"2":{"13":1}}],["多次点击只会产生一个弹窗",{"2":{"42":1}}],["多线程处理可能会导致过多的上下文切换和内存消耗",{"2":{"31":1}}],["多线程处理会导致访问共享内存的竞争条件",{"2":{"31":1}}],["多线程可能会存在安全漏洞",{"2":{"31":1}}],["多线程可能出现的问题",{"2":{"31":1}}],["多线程需要进行同步",{"2":{"31":1}}],["多线程",{"2":{"31":1}}],["多线程编程性能和体验更好",{"2":{"22":1}}],["多级反馈队列",{"2":{"25":1}}],["多媒体场景",{"2":{"16":1}}],["多数压缩算法都是对称的",{"2":{"16":1}}],["多个",{"2":{"12":3}}],["例如预测编码",{"2":{"16":1}}],["例如修改全局变量",{"2":{"1":1}}],["算法可以自由切换",{"2":{"49":1}}],["算法有",{"2":{"25":1}}],["算法压缩过的文件中",{"2":{"18":1}}],["算法是指按照出现频率高的字符用尽量少的位数编码来表示",{"2":{"18":1}}],["算法",{"0":{"18":1,"38":1},"2":{"16":1,"17":1,"18":1}}],["算法题",{"0":{"7":1},"1":{"8":1,"9":1}}],["算术编码",{"2":{"16":1}}],["e",{"2":{"49":1}}],["ecmascript",{"2":{"47":1}}],["error",{"2":{"44":1}}],["eventemitter",{"2":{"43":1}}],["event",{"2":{"43":1}}],["eventbus",{"2":{"42":1,"43":2}}],["emitter",{"2":{"43":1}}],["emit",{"2":{"43":2}}],["export",{"2":{"42":1}}],["extends",{"2":{"42":1}}],["exe文件",{"2":{"18":1}}],["eeeee",{"2":{"18":1}}],["encoding",{"2":{"16":1,"17":1}}],["else",{"2":{"8":1,"9":2}}],["element",{"2":{"8":6}}],["较小",{"2":{"16":1}}],["压缩比率",{"2":{"18":1}}],["压缩比为",{"2":{"17":1,"18":1}}],["压缩后",{"2":{"18":1}}],["压缩后的大小",{"2":{"16":1}}],["压缩前",{"2":{"18":1}}],["压缩前的大小",{"2":{"16":1}}],["压缩算法主要包括压缩和还原",{"2":{"16":1}}],["压缩算法",{"0":{"16":1},"1":{"17":1,"18":1}}],["如数据泄露",{"2":{"31":1}}],["如此来避免系统存在潜在死锁的风险",{"2":{"27":1}}],["如cpu和主存",{"2":{"27":1}}],["如磁带机",{"2":{"27":1}}],["如下图所示",{"2":{"27":1}}],["如现场的数字录音和录影",{"2":{"16":1}}],["如",{"2":{"16":3,"20":1,"27":1}}],["如多媒体数据的压缩",{"2":{"16":1}}],["如差分编码",{"2":{"16":1}}],["如可执行文件和普通文件的压缩",{"2":{"16":1}}],["如果不用恰当的模式",{"2":{"49":1}}],["如果一个对象有很多的行为",{"2":{"49":1}}],["如果在一个系统里面有许多类",{"2":{"49":1}}],["如果编程语言不支持方法重载",{"2":{"46":1}}],["如果你需要修改子类",{"2":{"46":1}}],["如果你已有类层次结构",{"2":{"46":1}}],["如果要实现深拷贝",{"2":{"46":1}}],["如果该页不在快表中",{"2":{"35":1}}],["如果该页在快表中",{"2":{"35":1}}],["如果其中一行代码报错",{"2":{"31":1}}],["如果小于",{"2":{"8":1}}],["如果大于",{"2":{"8":1}}],["准确地还原原始数据",{"2":{"16":1}}],["前端常用设计模式",{"0":{"39":1},"1":{"40":1,"41":1,"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1}}],["前提是申请的资源数量小于等于剩余资源",{"2":{"27":1}}],["前者能够无失真地从压缩后的数据重构",{"2":{"16":1}}],["前一段的元素一定大于等于后一段的元素",{"2":{"9":1}}],["按照高响应比",{"2":{"25":1}}],["按照一定的线性顺序",{"2":{"3":1}}],["按内存",{"2":{"25":1}}],["按进程进入就绪队列的先后次序运行",{"2":{"25":1}}],["按是否可逆",{"2":{"16":1}}],["按是否支持分级处理",{"2":{"16":1}}],["按是否实时性要求",{"2":{"16":1}}],["按是否有损",{"2":{"16":1}}],["按帧间与帧内",{"2":{"16":1}}],["按对称性",{"2":{"16":1}}],["我们可将其分成不同的类型",{"2":{"16":1}}],["我们称之为数组的旋转",{"2":{"9":1}}],["降低文件字节空间和占用空间的一种算法",{"2":{"16":1}}],["解决请求的发送者和请求的接受者之间的耦合",{"2":{"50":1}}],["解决死锁的基本方法",{"2":{"27":1}}],["解耦",{"2":{"44":1,"45":1}}],["解释器模式",{"2":{"41":1}}],["解除死锁",{"2":{"27":1}}],["解压缩",{"2":{"16":1}}],["解码和执行",{"2":{"12":1}}],["~1111",{"2":{"16":1}}],["种设计模式",{"0":{"41":1},"1":{"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1}}],["种",{"2":{"16":1}}],["种类",{"2":{"12":1}}],["位",{"2":{"16":1,"18":1}}],["用一个已经创建的实例作为原型",{"2":{"46":1}}],["用户cpu占用",{"2":{"20":1}}],["用户程序",{"2":{"19":1}}],["用户态",{"2":{"19":1}}],["用",{"2":{"16":1}}],["用于多进程对共享数据的访问",{"2":{"24":1}}],["用于通知接收进程某个事件已经发生",{"2":{"24":1}}],["用于查看当前正在运行的进程",{"2":{"20":1}}],["用于显示文件后几行内容",{"2":{"20":1}}],["用于存放下一条即将执行的指令所在单元的地址",{"2":{"12":1}}],["用于反映处理器的状态和运算结果的某些特征以及控制指令的执行",{"2":{"12":1}}],["后者有失真",{"2":{"16":1}}],["后符号位填充在最左高字节位",{"2":{"15":1}}],["后续元素依次向前填补",{"2":{"5":1}}],["左侧补",{"2":{"15":1}}],["左移一位",{"2":{"15":1}}],["增加二进制数字位数的操作",{"2":{"15":1}}],["符号扩展",{"2":{"15":1}}],["右移一位",{"2":{"15":1}}],["被称为算数右移",{"2":{"15":1}}],["正向",{"2":{"48":1}}],["正常结束或中断退出",{"2":{"23":1}}],["正负性",{"2":{"15":1}}],["正数",{"2":{"15":1}}],["正数的补码是其本身",{"2":{"15":1}}],["正极",{"2":{"13":1}}],["为其他对象提供一种代理以控制这个对象的访问",{"2":{"48":1}}],["为了实现虚拟内存功能",{"2":{"37":1}}],["为了避免把全部页表",{"2":{"35":1}}],["为了解决虚拟地址到物理地址的转换速度",{"2":{"35":1}}],["为每个进程和每个资源指定一个唯一标识",{"2":{"27":1}}],["为各压缩对象文件分别构造最佳的编码体系",{"2":{"18":1}}],["为正数",{"2":{"15":1}}],["为负数",{"2":{"15":1}}],["为什么数组下标从",{"0":{"5":1}}],["最近最少使用页面排序算法",{"2":{"38":1}}],["最近最久未使用页面置换算法",{"2":{"38":1}}],["最佳页面置换算法",{"2":{"38":1}}],["最大利用率",{"2":{"25":1}}],["最快且最有用的进程间通信方式",{"2":{"24":1}}],["最高位为符号位",{"2":{"15":1}}],["最小的两个",{"2":{"18":1}}],["最小元素在",{"2":{"9":4}}],["最小在",{"2":{"9":4}}],["最小数字一定是第一段非递减元素末尾的下一个",{"2":{"9":1}}],["64",{"2":{"14":1}}],["簇的容量也越大",{"2":{"14":1}}],["簇",{"2":{"14":3}}],["扇区",{"2":{"14":2}}],["扇区是对磁盘进行物理读写的最小单位",{"2":{"14":1}}],["扇区中",{"2":{"14":1}}],["把代码都放在一个类里面维护",{"2":{"42":1}}],["把内存的内容写入磁盘称为",{"2":{"37":1}}],["把运行的程序按照一定大小",{"2":{"37":1}}],["把文件内容用",{"2":{"17":1}}],["把磁盘的内容读到内存中称为",{"2":{"37":1}}],["把磁盘表面分成若干个同心圆的空间就是磁道",{"2":{"14":1}}],["把磁道按照固定大小的存储空间划分而成的就是扇区",{"2":{"14":1}}],["把一个数组最开始的若干个元素搬到数组的末尾",{"2":{"9":1}}],["划分的方式有两种",{"2":{"14":1}}],["磁盘的压缩",{"2":{"16":1}}],["磁盘的容量越大",{"2":{"14":1}}],["磁盘的物理结构指的是磁盘存储数据的形式",{"2":{"14":1}}],["磁盘缓存就大大改善了磁盘访问的速度",{"2":{"14":1}}],["磁盘缓存指的是把从磁盘中读出的数据存储到内存的方式",{"2":{"14":1}}],["磁盘中存储的程序必须加载到内存中才能运行",{"2":{"14":1}}],["磁盘",{"0":{"14":1}}],["无名管道",{"2":{"24":1}}],["无论哪种类型的数据",{"2":{"18":1}}],["无法立即得到结果",{"2":{"30":1}}],["无法还原到压缩前状态的压缩称为非可逆压缩",{"2":{"16":1}}],["无法进行写入和读取操作",{"2":{"13":1}}],["无序",{"2":{"3":1}}],["又要登记新页时",{"2":{"35":1}}],["又称",{"2":{"25":1}}],["又称线性列表",{"2":{"3":1}}],["又被称为控制信号",{"2":{"13":1}}],["只要客户端代码通过客户端接口与适配器进行交互",{"2":{"51":1}}],["只能在进程用完后自行释放的资源",{"2":{"27":1}}],["只能在使用完时由自己释放",{"2":{"27":1}}],["只有拥有互斥对象的线程才能访问公共资源",{"2":{"26":1}}],["只打包不压缩",{"2":{"20":1}}],["只需要通过",{"2":{"13":1}}],["只读存储器",{"2":{"13":1}}],["来生产对象",{"2":{"44":1}}],["来加速虚拟地址到物理地址的转换",{"2":{"35":1}}],["来指定数据的存储地址",{"2":{"13":1}}],["来说",{"2":{"5":1}}],["过程如下",{"2":{"13":1}}],["共享内存",{"2":{"24":1}}],["共享内存大小",{"2":{"20":1}}],["共40",{"2":{"18":1}}],["共",{"2":{"13":1}}],["共十个",{"2":{"13":1}}],["共八个",{"2":{"13":1}}],["字节",{"2":{"13":1,"14":1,"16":1}}],["8kb",{"2":{"14":1}}],["8",{"2":{"13":1,"16":1}}],["都可以用",{"2":{"18":1}}],["都为",{"2":{"13":1}}],["都是控制信号",{"2":{"13":1}}],["都会保存到标志寄存器中",{"2":{"12":1}}],["写入数据",{"2":{"13":1}}],["写入",{"2":{"13":1}}],["写回",{"2":{"12":1}}],["draw",{"2":{"47":5}}],["datacontainer",{"2":{"45":3}}],["dataiterator",{"2":{"45":2}}],["data",{"2":{"43":2,"45":6,"49":6}}],["doalgorithm",{"2":{"49":4}}],["do",{"2":{"49":1}}],["dosomebusinesslogic",{"2":{"49":3}}],["done",{"2":{"45":3}}],["dom",{"2":{"43":1,"48":1,"50":1}}],["document",{"2":{"42":3}}],["display",{"2":{"42":2,"48":5}}],["div",{"2":{"42":5}}],["digital",{"2":{"16":1}}],["decorator",{"2":{"47":5}}],["dev",{"2":{"42":1,"48":1}}],["default",{"2":{"42":1}}],["dependency",{"2":{"40":1}}],["dstat",{"2":{"20":1}}],["dsp",{"2":{"16":1}}],["d",{"2":{"20":1,"49":1}}],["dynamic",{"2":{"19":1}}],["ddl",{"2":{"19":1}}],["dd",{"2":{"18":1}}],["dvd",{"2":{"16":1}}],["d7",{"2":{"13":3}}],["d0",{"2":{"13":3}}],["负数",{"2":{"15":1}}],["负数的补码等于二进制表示取反+1",{"2":{"15":1}}],["负极",{"2":{"13":1}}],["负和零三种状态由标志寄存器的第",{"2":{"12":1}}],["getiterator",{"2":{"45":2}}],["getinstance",{"2":{"42":6}}],["getstate",{"2":{"43":1}}],["getsingleton",{"2":{"42":2}}],["gengetinstance",{"2":{"42":2}}],["grep",{"2":{"20":2}}],["ground",{"2":{"13":1}}],["gnd接通0v",{"2":{"13":1}}],["gnd",{"2":{"13":1}}],["gt",{"2":{"9":2,"27":6}}],["value",{"2":{"45":3}}],["void",{"2":{"44":1,"49":1}}],["voltage",{"2":{"13":1}}],["vue中的computed计算属性",{"2":{"51":1}}],["vue3",{"2":{"43":2}}],["vue2",{"2":{"43":1}}],["vue",{"2":{"43":4,"44":1}}],["vuex",{"2":{"42":1}}],["vmstat",{"2":{"20":1}}],["vi",{"2":{"20":1}}],["vim",{"2":{"20":1}}],["vcd",{"2":{"16":1}}],["vcc接通",{"2":{"13":1}}],["vcc",{"2":{"13":1}}],["读写内存数据时",{"2":{"35":1}}],["读写速度比内存更快",{"2":{"13":1}}],["读出数据时",{"2":{"13":1}}],["读取相同的内容时",{"2":{"14":1}}],["读取",{"2":{"13":1}}],["读取元素",{"2":{"4":1}}],["它们之间的区别仅在于它们的行为",{"2":{"49":1}}],["它们都将无法推进下去",{"2":{"27":1}}],["它将一组行为转换为对象",{"2":{"49":1}}],["它将程序看作是函数的集合",{"2":{"1":1}}],["它将程序看作是一系列过程或函数的集合",{"2":{"1":1}}],["它将程序看作是一组对象的集合",{"2":{"1":1}}],["它是作为现有的类的一个包装",{"2":{"47":1}}],["它可以前后翻页",{"2":{"20":1}}],["它内部也有电源",{"2":{"13":1}}],["它位于内存和",{"2":{"13":1}}],["分段目的都是提高内存利用率",{"2":{"34":1}}],["分页",{"2":{"34":2}}],["分页与分段",{"0":{"34":1}}],["分配给",{"2":{"27":1}}],["分配给p2",{"2":{"27":1}}],["分配给p0",{"2":{"27":1}}],["分配给某进程后不能强行收回",{"2":{"27":1}}],["分成子队列",{"2":{"25":1}}],["分形压缩",{"2":{"16":1}}],["分为无损压缩和有损压缩",{"2":{"16":1}}],["分为一级缓存",{"2":{"13":1}}],["分别对应于划分为长度可变和长度固定的空间",{"2":{"14":1}}],["分析",{"2":{"8":1,"9":1}}],["不用每次都亲自创建对象",{"2":{"44":1}}],["不再支持",{"2":{"43":1}}],["不再通过实际的磁盘",{"2":{"14":1}}],["不存在才调用构造函数创建",{"2":{"42":1}}],["不需要使用代理",{"2":{"42":1}}],["不需要的调入外存",{"2":{"37":1}}],["不断维护一个按最近一段时间使用频率排序的页链表",{"2":{"38":1}}],["不断重复第",{"2":{"18":1}}],["不可实现的理想情况",{"2":{"38":1}}],["不可剥夺资源",{"2":{"27":1}}],["不剥夺条件",{"2":{"27":1}}],["不同进程使用的虚拟地址彼此隔离",{"2":{"36":1}}],["不同子队列采用适合自己队列进程性质的调度算法",{"2":{"25":1}}],["不同质量水平的多媒体数据的压缩算法",{"2":{"16":1}}],["不同传输速率",{"2":{"16":1}}],["不能剥夺",{"2":{"27":1}}],["不能完全准确地恢复原始数据",{"2":{"16":1}}],["不能写入数据",{"2":{"13":1}}],["不过",{"2":{"14":2}}],["不一定互异",{"2":{"3":2}}],["一种是每个对象本身维护到下一个对象的引用",{"2":{"50":1}}],["一种比较复杂的通信方式",{"2":{"24":1}}],["一直放在内存中占用过多空间",{"2":{"35":1}}],["一直等待直到返回结果",{"2":{"30":1}}],["一般作为衡量其他置换算法的方法",{"2":{"38":1}}],["一般是一个扇区",{"2":{"14":1}}],["一般只能用于数据的读取",{"2":{"13":1}}],["一个系统需要动态地在几种算法中选择一种",{"2":{"49":1}}],["一个类或者模块只负责完成一个职责",{"2":{"40":1}}],["一个计数器",{"2":{"24":1}}],["一个进程至少有一个运行代码的主线程",{"2":{"22":1}}],["一个进程死掉不影响另一个进程",{"2":{"22":1}}],["一个线程死掉可能会导致整个进程被操作系统杀掉",{"2":{"22":1}}],["一个",{"2":{"12":1}}],["当类又调用了其他对象时",{"2":{"46":1}}],["当可用物理内存变小时内存管理器会将物理内存页",{"2":{"36":1}}],["当快表填满后",{"2":{"35":1}}],["当一个进程申请使用资源的时候",{"2":{"27":1}}],["当进程因请求资源而阻塞时",{"2":{"27":1}}],["当",{"2":{"13":1}}],["当机器关闭时",{"2":{"13":1}}],["当前行不大于目标元素",{"2":{"8":1}}],["当前行已经都比目标元素大",{"2":{"8":1}}],["当前一维数组大了",{"2":{"8":1}}],["既可以从中读取数据",{"2":{"13":1}}],["集成电路",{"2":{"13":1}}],["集合",{"0":{"3":1},"2":{"3":1}}],["以按需使用",{"2":{"48":1}}],["以解除死锁状态",{"2":{"27":1}}],["以此判断是否分配资源",{"2":{"27":1}}],["以及与硬盘等外部存储设备交换的数据",{"2":{"13":1}}],["以便被后续的指令快速地存取",{"2":{"12":1}}],["作用是存放",{"2":{"13":1}}],["或多个相关事物的发生无需等待其前一事物的完成",{"2":{"30":1}}],["或者功能",{"2":{"40":1}}],["或者尽可能实时",{"2":{"30":1}}],["或者临时资源",{"2":{"27":1}}],["或符号扩充",{"2":{"15":1}}],["或",{"2":{"13":1,"15":1,"20":1,"44":1}}],["或称为主存",{"2":{"13":1}}],["或类型可不同",{"2":{"3":1}}],["内外存",{"2":{"37":1}}],["内核cpu占用等",{"2":{"20":1}}],["内存一外存",{"2":{"37":1}}],["内存单元真实地址",{"2":{"36":1}}],["内存利用率提高",{"2":{"33":1}}],["内存利用率低下",{"2":{"33":1}}],["内存溢出等问题",{"2":{"31":1}}],["内存信息",{"2":{"20":1}}],["内存管理机制",{"0":{"33":1}}],["内存管理涉及内存分配",{"2":{"32":1}}],["内存管理",{"0":{"32":1},"1":{"33":1,"34":1,"35":1,"36":1,"37":1,"38":1},"2":{"19":1}}],["内存是由各种",{"2":{"13":1}}],["内存",{"0":{"13":1},"2":{"13":2,"20":1}}],["内部做减法运算",{"2":{"12":1}}],["内部使用",{"2":{"12":1}}],["内部会有",{"2":{"12":1}}],["内部的一维数组仍然从索引",{"2":{"5":1}}],["到某种存储形式",{"2":{"12":1}}],["webpack",{"2":{"48":1}}],["watch",{"2":{"43":1}}],["waiting",{"2":{"23":1}}],["windows在磁盘上提供了虚拟内存使用的文件",{"2":{"37":1}}],["windows",{"2":{"14":3,"19":2,"37":3}}],["wr",{"2":{"13":2}}],["write",{"2":{"12":1,"13":1}}],["wb",{"2":{"12":1}}],["while",{"2":{"8":1,"9":1,"45":1}}],["得到操作数在主存中的地址",{"2":{"12":1}}],["根据虚拟地址中的页号查快表",{"2":{"35":1}}],["根据压缩算法的定义",{"2":{"16":1}}],["根据磁盘容量不同功能",{"2":{"14":1}}],["根据指令地址",{"2":{"12":1}}],["根据种类的不同",{"2":{"12":1}}],["此阶段的任务是",{"2":{"12":1}}],["完成指令所规定的各种操作",{"2":{"12":1}}],["识别区分出不同的指令类别以及各种获取操作数的方法",{"2":{"12":1}}],["立马进入指令译码阶段",{"2":{"12":1}}],["访问者模式",{"2":{"41":1}}],["访问取数是根据指令的需要",{"2":{"12":1}}],["访问数组元素少一次减法运算",{"2":{"5":1}}],["访问数组中的元素",{"2":{"4":1}}],["访存取数",{"2":{"12":1}}],["取指令是将内存中的指令读取到",{"2":{"12":1}}],["取指令",{"2":{"12":1}}],["诺伊曼体系的计算机cpu",{"2":{"12":1}}],["冯诺依曼体系",{"2":{"14":1}}],["冯",{"2":{"12":1}}],["循环是重复执行同一地址的指令",{"2":{"12":1}}],["循环判断三种",{"2":{"12":1}}],["条件分支是根据条件执行指定地址的指令",{"2":{"12":1}}],["条件分支",{"2":{"12":1}}],["顺序执行是按照地址的内容依次顺序",{"2":{"12":1}}],["顺序执行",{"2":{"12":1}}],["高层模块不要依赖低层模块",{"2":{"40":1}}],["高响应比",{"2":{"25":1}}],["高速缓存实现",{"2":{"37":1}}],["高速缓存",{"2":{"13":1}}],["高级编程语言中的条件控制流程主要分为三种",{"2":{"12":1}}],["高效的算法和高速",{"2":{"16":1}}],["高效",{"2":{"6":1}}],["小即是美",{"2":{"40":1}}],["小波压缩",{"2":{"16":1}}],["小",{"2":{"12":1}}],["相同优先级的进程以先到先服务方式运行",{"2":{"25":1}}],["相等",{"2":{"12":1}}],["相比下标从",{"2":{"5":1}}],["大小不固定",{"2":{"34":1}}],["大",{"2":{"12":1}}],["比较难追溯到一个",{"2":{"47":1}}],["比",{"2":{"12":2,"20":1}}],["比如需要用的接口",{"2":{"51":1}}],["比如不兼容的接口",{"2":{"51":1}}],["比如数组等",{"2":{"37":1}}],["比如单核",{"2":{"28":1}}],["比如设置定时器",{"2":{"27":1}}],["比如",{"2":{"8":1,"9":1,"16":2,"17":1,"19":1,"43":2,"48":2}}],["零还是负数",{"2":{"12":1}}],["做比较",{"2":{"12":1}}],["y",{"2":{"12":4}}],["假设要向内存ic中写入1byte的数据的话",{"2":{"13":1}}],["假设累加寄存器中存储的",{"2":{"12":1}}],["假如对于整数",{"2":{"8":1}}],["函数返回时触发",{"2":{"12":1}}],["函数调用时触发",{"2":{"12":1}}],["函数是可变的",{"2":{"1":1}}],["程序运行时",{"2":{"37":1}}],["程序在一段时间内所访问的可能是一定范围内的内存地址",{"2":{"37":1}}],["程序在某一段时间内访问同一数据或执行同一指令多次",{"2":{"37":1}}],["程序发出调用之后",{"2":{"30":1}}],["程序发出调用的时候",{"2":{"30":1}}],["程序执行",{"2":{"22":1}}],["程序比较的指令",{"2":{"12":1}}],["程序员无法对该寄存器进行读写",{"2":{"12":1}}],["程序计数器值++",{"2":{"12":1}}],["程序计数器控制着程序的流程",{"2":{"12":1}}],["程序计数器",{"2":{"12":2}}],["储存正在被运行的指令",{"2":{"12":1}}],["变址寄存器",{"2":{"12":1}}],["基址寄存器",{"2":{"12":1}}],["和订阅者",{"2":{"43":1}}],["和同时给运行多个程序造成困难",{"2":{"36":1}}],["和allocation",{"2":{"27":1}}],["和available",{"2":{"27":1}}],["和三级缓存",{"2":{"13":1}}],["和通用寄存器中存储的",{"2":{"12":1}}],["和",{"2":{"12":2,"13":4,"20":1,"43":2}}],["和算术逻辑单元",{"2":{"12":1}}],["标志寄存器",{"2":{"12":1}}],["累加寄存器",{"2":{"12":1}}],["功能",{"2":{"12":1}}],["功能上",{"2":{"12":1}}],["而代理模式可以改变",{"2":{"48":1}}],["而不是原始对象",{"2":{"46":1}}],["而不能是匿名函数",{"2":{"43":1}}],["而更关注可移植性和可扩展性",{"2":{"40":1}}],["而段",{"2":{"34":1}}],["而避免死锁允许进程动态地申请资源",{"2":{"27":1}}],["而是通过一个既定的",{"2":{"44":1}}],["而是通过磁盘缓存来读取",{"2":{"14":1}}],["而是一次性申请所有需要的资源",{"2":{"27":1}}],["而帧间编码则需要参照前后帧才能进行编解码",{"2":{"16":1}}],["而无论减法运算的结果是正数",{"2":{"12":1}}],["而",{"2":{"12":1,"42":1}}],["而且存在事件通道等额外时间内存开销",{"2":{"43":1}}],["而且",{"2":{"43":1}}],["而且必要的话也处理或者回复",{"2":{"30":1}}],["而且在应用程序中",{"2":{"12":1}}],["而且左边大于等于右边",{"2":{"9":1}}],["而且使用二分法比较中间元素与右侧元素的大小关系",{"2":{"9":1}}],["寄存器划分为",{"2":{"12":1}}],["寄存器是作为对象描述的",{"2":{"12":1}}],["寄存器是用来暂存指令",{"2":{"12":1}}],["寄存器作为",{"2":{"12":1}}],["并使其在原始上下文对象内部能够相互替换",{"2":{"49":1}}],["并提供一个访问它的全局访问点",{"2":{"42":1}}],["并以页为单位进行置换",{"2":{"37":1}}],["并以该编码体系为基础来进行压缩",{"2":{"18":1}}],["并发",{"2":{"28":1}}],["并行",{"2":{"28":1}}],["并行与并发",{"0":{"28":1}}],["并建立资源分配表和进程等待表",{"2":{"27":1}}],["并根据可完成进程的分配顺序生成安全序列",{"2":{"27":1}}],["并根据指令的结果控制计算机",{"2":{"12":1}}],["并在其中声明克隆方法",{"2":{"46":1}}],["并在资源分配之前预先计算资源分配的安全性",{"2":{"27":1}}],["并在编码过程中考虑对帧之间的时间冗余的压缩",{"2":{"16":1}}],["并由操作系统代为完成系统态的操作",{"2":{"19":1}}],["并加入此次最小两个数的频率和",{"2":{"18":1}}],["并把wr的值置为",{"2":{"13":1}}],["并从主存中读取该操作数用于运算",{"2":{"12":1}}],["并且保证原来程序的逻辑行为不变及正确性不被破坏",{"2":{"40":1}}],["并且把内存扩展到硬盘空间",{"2":{"37":1}}],["并且不会对外部状态进行修改",{"2":{"1":1}}],["并且对象之间可以建立继承和关联关系",{"2":{"1":1}}],["个字节",{"2":{"14":1}}],["个字节位为",{"2":{"12":1}}],["个寄存器",{"2":{"12":1}}],["个一维数组的首元素的地址为",{"2":{"5":1}}],["控制信号和用于寻址的",{"2":{"13":1}}],["控制器负责把内存上的指令",{"2":{"12":1}}],["控制器",{"2":{"12":1,"14":1}}],["控制单元",{"2":{"12":1}}],["执行完这些操作后",{"2":{"13":1}}],["执行指令是译码完成后",{"2":{"12":1}}],["执行指令",{"2":{"12":1}}],["执行",{"2":{"12":1}}],["然后将原始对象所有的成员变量值复制到新建的对象中",{"2":{"46":1}}],["然后将该元素插入到尾部",{"2":{"5":1}}],["然后继续判断队列中的其它进程",{"2":{"27":1}}],["然后通过安全性算法判断分配后的系统是否处于安全状态",{"2":{"27":1}}],["然后再将",{"2":{"13":1}}],["然后再把数据的值输入给",{"2":{"13":1}}],["然后再由",{"2":{"12":1}}],["然后解码该指令的实际内容",{"2":{"12":1}}],["具体而言是",{"2":{"12":1}}],["其十进制表示为",{"2":{"15":1}}],["其主要分为三种存储器",{"2":{"13":1}}],["其工作都可以分为5个阶段",{"2":{"12":1}}],["其中最具有代表性的避免死锁算法是银行家算法",{"2":{"27":1}}],["其中不能破坏互斥条件",{"2":{"27":1}}],["其中左移右端补",{"2":{"15":1}}],["其中",{"2":{"15":1,"51":1}}],["其中存储器除了内存",{"2":{"14":1}}],["其中当wr",{"2":{"13":1}}],["其中的信息会丢失",{"2":{"13":1}}],["其中控制单元负责从内存中提取指令并解码",{"2":{"12":1}}],["其中第",{"2":{"5":1}}],["其核心可以分为三个关键阶段",{"2":{"12":1}}],["即面向接口编程",{"2":{"40":1}}],["即淘汰",{"2":{"38":1}}],["即为同步",{"2":{"30":1}}],["即撤消死锁进程或撤消代价最小的进程",{"2":{"27":1}}],["即从其它进程剥夺足够数量的资源给死锁进程",{"2":{"27":1}}],["即发现有进程死锁的同时立即把它从死锁状态中解脱出来",{"2":{"27":1}}],["即此时没有一个进程能够完成并释放资源",{"2":{"27":1}}],["即不是使用前才申请",{"2":{"27":1}}],["即按序申请",{"2":{"27":1}}],["即占用部分资源的线程如果申请不到其他资源时",{"2":{"27":1}}],["即在一段时间内某资源仅为一进程所占用",{"2":{"27":1}}],["即该进程允许运行的时间",{"2":{"25":1}}],["即等待状态",{"2":{"23":1}}],["即概念",{"0":{"22":1}}],["即编解码算法的复杂性和所需时间是否相似",{"2":{"16":1}}],["即整除以",{"2":{"15":1}}],["即",{"2":{"15":1,"16":1,"18":1}}],["即可",{"2":{"13":1}}],["即可以向内存",{"2":{"13":1}}],["即中央处理器",{"2":{"12":1}}],["即函数式编程",{"2":{"1":1}}],["计算机的五大基础部件是存储器",{"2":{"14":1}}],["计算机组成原理",{"0":{"11":1},"1":{"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1}}],["计算机网络",{"0":{"10":1}}],["上一个元素比当前元素大",{"2":{"9":1}}],["+5v",{"2":{"13":1}}],["+",{"2":{"9":6,"25":1,"37":1}}],["说明最小在left",{"2":{"9":1}}],["时要传入原来的函数",{"2":{"43":1}}],["时间局部性",{"2":{"37":1}}],["时间或其他资源",{"2":{"25":1}}],["时间片轮转",{"2":{"25":1}}],["时间",{"2":{"20":1}}],["时间复杂度为",{"2":{"5":1}}],["时间复杂度",{"2":{"5":5}}],["时",{"2":{"13":1}}],["时钟负责发出cpu开始计时的时钟信号",{"2":{"12":1}}],["时只能是mid",{"2":{"9":1}}],["ll",{"2":{"49":1}}],["loading",{"2":{"48":1}}],["loadfromdist",{"2":{"48":2}}],["log",{"2":{"42":1,"43":1,"45":5,"47":2,"48":2,"49":4}}],["logic",{"2":{"12":1}}],["lfu",{"2":{"38":1}}],["lru",{"2":{"38":1}}],["l",{"2":{"20":1}}],["ls",{"2":{"20":1}}],["listeners",{"2":{"43":13}}],["liskov",{"2":{"40":1}}],["link",{"2":{"19":1}}],["linux设计哲学",{"2":{"40":1}}],["linux",{"0":{"20":1},"2":{"19":2,"37":1}}],["library",{"2":{"19":2}}],["lzw编码",{"2":{"16":1}}],["l3",{"2":{"13":1}}],["l2",{"2":{"13":1}}],["l1",{"2":{"13":1}}],["lt",{"2":{"9":4}}],["least",{"2":{"38":2}}],["less",{"2":{"20":1}}],["len",{"2":{"9":6}}],["length",{"2":{"8":4,"9":2,"16":1,"17":1,"43":2,"45":3}}],["leftnum",{"2":{"9":3}}],["left+1",{"2":{"9":1}}],["left",{"2":{"9":17}}],["let",{"2":{"8":4,"9":3,"42":5,"43":1}}],["由每个对象灵活决定是否处理请求的场景",{"2":{"50":1}}],["由操作系统决定",{"2":{"34":1}}],["由一个进程创建的映射一段能被其他多个进程所访问的内存",{"2":{"24":1}}],["由一个或多个确定的元素所构成的整体",{"2":{"3":1}}],["由寄存器",{"2":{"12":1}}],["由于一个线程在同一时间只能处理一件事情",{"2":{"28":1}}],["由于",{"2":{"9":1}}],["遍历即可",{"2":{"9":1}}],["首先定义状态和安全状态的概念",{"2":{"27":1}}],["首先运行具有最高优先级的进程",{"2":{"25":1}}],["首先",{"2":{"9":1}}],["是适配为的内容",{"2":{"51":1}}],["是被适配的内容",{"2":{"51":1}}],["是在哪一层包装导致的",{"2":{"47":1}}],["是单线程",{"2":{"42":1}}],["是多线程",{"2":{"42":1}}],["是目前最常用的实现虚拟内存的方式",{"2":{"37":1}}],["是用时间",{"2":{"37":1}}],["是指资源是有线性顺序的",{"2":{"27":1}}],["是较好的进程调度算法",{"2":{"25":1}}],["是可以取代",{"2":{"20":1}}],["是内存使用情况统计",{"2":{"20":1}}],["是编码容易而解码难",{"2":{"16":1}}],["是使用扇区",{"2":{"14":1}}],["是地址信号的引脚",{"2":{"13":1}}],["是把执行指令阶段的运行结果数据",{"2":{"12":1}}],["是",{"2":{"9":1,"20":2}}],["是一种元素在内存中连续存储的线性列表数据结构",{"2":{"3":1}}],["40",{"2":{"45":1}}],["4652字节",{"2":{"18":1}}],["4119字节",{"2":{"18":1}}],["4kb",{"2":{"14":1,"37":1}}],["4",{"2":{"9":2,"16":1,"36":1,"46":1}}],["旋转数组的前一部分均大于等于后一部分",{"2":{"9":1}}],["旋转数组的最小数字",{"0":{"9":1}}],["旋转数组由前后两段非递减元素组成",{"2":{"9":1}}],["输出某个特定进程内所有线程的运行情况",{"2":{"20":1}}],["输出旋转数组的最小元素",{"2":{"9":1}}],["输入和输出设备",{"2":{"14":1}}],["输入一个存在重复元素的升序数组的一个旋转",{"2":{"9":1}}],["输入这样的一个二维数组和一个整数",{"2":{"8":1}}],["xxx",{"2":{"48":1}}],["x",{"2":{"12":4}}],["x26",{"2":{"8":2,"43":2}}],["x3c",{"2":{"8":3,"9":4,"42":2,"43":1,"45":2}}],["bug",{"2":{"47":1}}],["block",{"2":{"42":1}}],["blocking",{"2":{"29":2}}],["body",{"2":{"42":2}}],["boolean",{"2":{"8":2,"45":1}}],["bb",{"2":{"18":1}}],["b",{"2":{"15":1,"43":3,"49":1}}],["bytes字节",{"2":{"18":1}}],["byte",{"2":{"13":2}}],["bits",{"2":{"16":1,"18":1}}],["bit",{"2":{"13":1}}],["back",{"2":{"12":1}}],["break",{"2":{"8":1}}],[">=",{"2":{"8":1,"9":1}}],[">",{"2":{"8":2,"9":2}}],["rr",{"2":{"25":1}}],["r",{"2":{"20":1}}],["rmdir",{"2":{"20":1}}],["rm",{"2":{"16":1}}],["running",{"2":{"23":1}}],["run",{"2":{"16":1,"17":1}}],["rle算法",{"0":{"17":1}}],["rle",{"2":{"16":2,"17":1}}],["relational",{"2":{"51":1}}],["reverse",{"2":{"49":2}}],["result",{"2":{"49":2}}],["responsibility",{"2":{"40":1}}],["realimg",{"2":{"48":3}}],["react",{"2":{"43":2,"44":2,"47":1}}],["readimg",{"2":{"48":3}}],["ready",{"2":{"23":1}}],["read",{"2":{"13":1}}],["recently",{"2":{"38":1}}],["returns",{"2":{"42":1}}],["return",{"2":{"8":6,"9":6,"12":2,"42":9,"43":6,"44":2,"45":7,"46":1,"49":2}}],["rd",{"2":{"13":4}}],["robin",{"2":{"25":1}}],["round",{"2":{"25":1}}],["rom",{"2":{"13":1}}],["row",{"2":{"8":6}}],["ram",{"2":{"13":1}}],["rightnum",{"2":{"9":4}}],["right",{"2":{"9":18}}],["二进制",{"0":{"15":1}}],["二级缓存",{"2":{"13":1}}],["二分查找",{"2":{"9":1}}],["二位数组为空",{"2":{"8":2}}],["二维数组的查找",{"0":{"8":1}}],["二维数组的本质上仍然是一个一维数组",{"2":{"5":1}}],["==",{"2":{"43":6}}],["===",{"2":{"8":2,"42":1,"43":2,"44":2}}],["=>",{"2":{"42":2,"43":5,"44":1}}],["=right",{"2":{"9":1}}],["=",{"2":{"8":10,"9":18,"13":2,"14":3,"17":1,"18":2,"42":20,"43":11,"44":5,"45":9,"46":4,"47":3,"48":3,"49":4}}],["circle",{"2":{"47":12}}],["circularreference",{"2":{"46":3}}],["circuit",{"2":{"13":2}}],["creator",{"2":{"44":5}}],["create",{"2":{"44":3,"46":3}}],["createsinglealert",{"2":{"42":2}}],["createelementvnode",{"2":{"44":1}}],["createelement",{"2":{"42":1,"44":1}}],["createalert",{"2":{"42":2}}],["cb",{"2":{"43":9}}],["client",{"2":{"49":2}}],["click",{"2":{"42":1}}],["clone",{"2":{"46":7}}],["closed",{"2":{"40":1}}],["class",{"2":{"42":3,"43":2,"44":3,"45":2,"46":2,"47":1,"48":1,"49":2}}],["classname",{"2":{"42":3}}],["cvf",{"2":{"20":1}}],["c",{"2":{"18":1,"49":1}}],["cache",{"2":{"13":4,"35":1}}],["call",{"2":{"12":2,"43":1}}],["customiterator",{"2":{"45":2}}],["cu",{"2":{"12":1}}],["cur",{"2":{"9":3}}],["central",{"0":{"12":1}}],["component",{"2":{"46":3}}],["componentwithbackreference",{"2":{"46":2}}],["compaction",{"0":{"16":1},"1":{"17":1,"18":1}}],["concretestrategyb",{"2":{"49":2}}],["concretestrategya",{"2":{"49":2}}],["concurrency",{"2":{"28":1}}],["context1",{"2":{"49":4}}],["context",{"2":{"49":3}}],["container",{"2":{"45":2}}],["control",{"2":{"12":1}}],["console",{"2":{"42":1,"43":1,"45":5,"47":2,"48":2,"49":4}}],["construct",{"2":{"42":1}}],["constructor",{"2":{"42":2,"43":2,"44":2,"45":1,"46":1,"47":1,"48":2,"49":1}}],["const",{"2":{"8":6,"9":8,"42":8,"43":3,"44":3,"45":3,"46":1,"47":2,"48":1,"49":2}}],["col",{"2":{"8":6}}],["cpu通知操作系统os将其调入内存的过程称为缺页中断",{"2":{"37":1}}],["cpu计算时间",{"2":{"37":1}}],["cpu中的内存管理单元mmu",{"2":{"36":1}}],["cpu执行比较运算的机制",{"2":{"12":1}}],["cpu",{"0":{"12":1},"2":{"5":1,"12":13,"13":3,"14":1,"16":1,"20":5,"22":2,"23":1,"25":1,"28":1,"29":2,"35":1,"36":1}}],["the",{"2":{"49":1}}],["then",{"2":{"43":1,"50":1}}],["throw",{"2":{"44":1}}],["this",{"2":{"42":1,"43":21,"44":2,"45":12,"46":6,"47":3,"48":6,"49":3}}],["t>",{"2":{"42":1}}],["t",{"2":{"42":2}}],["terminated",{"2":{"23":1}}],["tcp",{"2":{"20":1}}],["to",{"2":{"49":2}}],["top",{"2":{"20":2}}],["touch",{"2":{"20":1}}],["tail",{"2":{"20":1}}],["tar",{"2":{"20":2}}],["target",{"2":{"8":6,"42":2,"51":2}}],["true",{"2":{"8":2,"42":1,"45":1}}],["typeof",{"2":{"43":5}}],["typescriptinterface",{"2":{"44":1}}],["typescriptclass",{"2":{"43":1,"45":1,"47":1,"48":1,"49":1}}],["typescript",{"2":{"8":1,"9":1,"42":2,"43":1,"46":1}}],["type",{"2":{"5":4,"43":16,"44":4}}],["暴力解法",{"2":{"8":1,"9":1}}],["求解",{"2":{"8":1}}],["找不到",{"2":{"8":2}}],["超时释放资源",{"2":{"27":1}}],["超时送入就绪队列的队尾",{"2":{"25":1}}],["超过行边界退出",{"2":{"8":1}}],["超过列边界退出",{"2":{"8":1}}],["超出数组长度范围插入",{"2":{"5":1}}],["向订阅者",{"2":{"43":1}}],["向内存写入数据时",{"2":{"13":1}}],["向上走",{"2":{"8":1}}],["向右上进行遍历",{"2":{"8":1}}],["向右上角进行遍历",{"2":{"8":1}}],["向右走",{"2":{"8":1}}],["向左下角进行遍历",{"2":{"8":1}}],["可对发起操作和执行操作的类进行解耦",{"2":{"50":1}}],["可能导致数据不一致和死锁等问题",{"2":{"31":1}}],["可能会引起副作用",{"2":{"1":1}}],["可用套接字中的相关函数来完成通信过程",{"2":{"24":1}}],["可用于对数据的准确性要求不高的场合",{"2":{"16":1}}],["可用于对数据的准确性要求严格的场合",{"2":{"16":1}}],["可以将接口或数据转换代码从程序主要业务逻辑中分离",{"2":{"51":1}}],["可以在不更改现有代码的情况下在程序中新增处理者",{"2":{"50":1}}],["可以控制请求处理的顺序",{"2":{"50":1}}],["可以扩展多个类",{"2":{"44":1}}],["可以实现异步",{"2":{"43":1}}],["可以减少命名变量",{"2":{"42":1}}],["可以主动释放它占有的资源",{"2":{"27":1}}],["可以提升压缩比率",{"2":{"18":1}}],["可以同时处理不同分辨率",{"2":{"16":1}}],["可以从左下角开始",{"2":{"8":1}}],["可视电话",{"2":{"16":1}}],["可视为内存的一种",{"2":{"12":1}}],["可变长方式和扇区方式",{"2":{"14":1}}],["20",{"2":{"45":1}}],["20~100",{"2":{"12":1}}],["24576字节",{"2":{"18":1}}],["28",{"2":{"18":1}}],["29",{"2":{"18":1}}],["256",{"2":{"16":1}}],["2kb",{"2":{"14":1}}],["2",{"0":{"9":1},"2":{"9":3,"12":1,"13":1,"14":1,"15":2,"16":1,"37":1,"46":1}}],["23",{"0":{"41":1},"1":{"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1},"2":{"8":1}}],["21",{"2":{"8":1}}],["512",{"2":{"14":2}}],["5",{"2":{"8":1,"9":2,"18":2}}],["9456字节",{"2":{"18":1}}],["96062字节",{"2":{"18":1}}],["9",{"2":{"8":1,"20":1}}],["30",{"2":{"45":1}}],["32kb",{"2":{"14":1}}],["3",{"2":{"8":1,"9":2,"12":1,"45":1,"46":1}}],["70",{"2":{"17":2}}],["7",{"2":{"8":1}}],["从发布者",{"2":{"43":1}}],["从而降低程序的性能和稳定性",{"2":{"31":1}}],["从头执行到尾",{"2":{"31":1}}],["从宏观上观察系统各个进程对cpu的占用情况以及内存使用情况",{"2":{"20":1}}],["从系统的主存中提取指令",{"2":{"12":1}}],["从左下角元素出发",{"2":{"8":1}}],["从上到下递增的顺序排序",{"2":{"8":1}}],["从索引",{"2":{"5":1}}],["列出文件列表",{"2":{"20":1}}],["列元素从上到下递增",{"2":{"8":1}}],["列分别按照从左到右",{"2":{"8":1}}],["列表",{"0":{"3":1},"2":{"3":1}}],["每次内存都需要从磁盘中读取数据",{"2":{"14":1}}],["每一行",{"2":{"8":1}}],["每个类都必须显式重写克隆方法并使用自身类名调用",{"2":{"46":1}}],["每个类都要实现",{"2":{"46":1}}],["每个进程分配",{"2":{"25":1}}],["每个进程均有一个时间片",{"2":{"25":1}}],["每个地址对应的位置会存放",{"2":{"13":1}}],["每个一维数组的长度相同",{"2":{"8":1}}],["每个过程都可以操作共享的数据",{"2":{"1":1}}],["每个对象都可以接收消息",{"2":{"1":1}}],["题目描述",{"2":{"8":1,"9":1}}],["删操作少的场景",{"2":{"6":1}}],["删除指定索引元素",{"2":{"5":1}}],["删除元素",{"2":{"5":1}}],["查看文件",{"2":{"20":1}}],["查找字符串",{"2":{"20":1}}],["查找元素",{"2":{"5":1}}],["查",{"2":{"6":1}}],["改操作多",{"2":{"6":1}}],["因此请不要将所有对象都变成代理",{"2":{"48":1}}],["因此不用考虑同步锁的问题",{"2":{"42":1}}],["因此我们可以得出内存",{"2":{"13":1}}],["因此最小值和最大值在左上角和右下角",{"2":{"8":1}}],["因此",{"2":{"6":1,"14":1}}],["因为需要新增一系列接口和类",{"2":{"51":1}}],["因为它在调用",{"2":{"46":1}}],["因为直接暴露物理地址",{"2":{"36":1}}],["因为使用锁目的就是保证资源被互斥访问",{"2":{"27":1}}],["因为",{"2":{"5":1}}],["插入和删除元素",{"2":{"6":1}}],["插入元素",{"2":{"5":1}}],["低效",{"2":{"6":1}}],["的洋葱模型",{"2":{"50":1}}],["的链式调用",{"2":{"50":1}}],["的高阶组件",{"2":{"47":1}}],["的情况下遍历集合中所有的元素",{"2":{"45":1}}],["的$",{"2":{"44":1}}],["的文件读取流",{"2":{"43":1}}],["的组件更新过程",{"2":{"43":1}}],["的生命周期",{"2":{"43":1}}],["的解决方案",{"2":{"40":1}}],["的页进行分割",{"2":{"37":1}}],["的方案",{"2":{"37":1}}],["的两级存储器的结构",{"2":{"37":1}}],["的两个步骤",{"2":{"16":1}}],["的虚拟内存",{"2":{"37":1}}],["的交换空间",{"2":{"37":1}}],["的映射",{"2":{"33":1}}],["的最小单位",{"2":{"22":1}}],["的17个字符构建哈夫曼树后为",{"2":{"18":1}}],["的17个字符被压缩成了",{"2":{"17":1}}],["的12个字符",{"2":{"17":1}}],["的形式来表示的压缩方法成为",{"2":{"17":1}}],["的值置为",{"2":{"13":1}}],["的地址信号指定数据的存储地址",{"2":{"13":1}}],["的容量就是",{"2":{"13":1}}],["的",{"2":{"13":1,"42":1,"43":1,"44":2,"47":1,"50":1}}],["的数据信号",{"2":{"13":1}}],["的数据",{"2":{"13":2}}],["的内部寄存器中",{"2":{"12":1}}],["的过程",{"2":{"12":1}}],["的执行指令",{"2":{"12":1}}],["的运算机制就会对x和y做减法运算",{"2":{"12":1}}],["的通信核心",{"2":{"12":1}}],["的相关部分执行该指令",{"2":{"12":1}}],["的前两个数旋转到数组末尾得到的旋转数组",{"2":{"9":1}}],["的查找",{"2":{"6":1}}],["的随机访问",{"2":{"6":1}}],["的二维数组寻址公式为",{"2":{"5":1}}],["koa",{"2":{"50":1}}],["kill",{"2":{"20":1}}],["kb",{"2":{"13":1,"36":1}}],["k∗n",{"2":{"5":1}}],["k",{"2":{"5":2,"15":1}}],["join",{"2":{"49":1}}],["jquery",{"2":{"44":1,"50":1}}],["js",{"2":{"42":1}}],["java",{"2":{"42":1}}],["javascriptconst",{"2":{"42":1}}],["javascript",{"2":{"5":1,"42":1}}],["jpeg2000",{"2":{"16":1}}],["jpeg",{"2":{"16":3}}],["j++",{"2":{"8":2}}],["j",{"2":{"5":1,"8":8}}],["mutationobserver",{"2":{"43":1}}],["mysql",{"2":{"35":1}}],["more",{"2":{"20":1}}],["mkdir",{"2":{"20":1}}],["mapping",{"2":{"51":1}}],["macos",{"2":{"19":1}}],["math",{"2":{"9":1}}],["matrix",{"2":{"8":8}}],["ms",{"2":{"16":1}}],["mp3",{"2":{"16":1}}],["mpeg",{"2":{"16":3}}],["memory",{"0":{"13":1}}],["mitt",{"2":{"43":2}}],["minarray2",{"2":{"9":1}}],["minarray1",{"2":{"9":1}}],["midnum",{"2":{"9":3}}],["mid",{"2":{"9":12}}],["m",{"2":{"5":1}}],["尾部删除",{"2":{"5":1}}],["尾部插入",{"2":{"5":1}}],["对需要保护的对象进行代理",{"2":{"48":1}}],["对开销大的对象使用代理",{"2":{"48":1}}],["对类的实现是有一定入侵的",{"2":{"46":1}}],["对修改关闭",{"2":{"40":1}}],["对于这种情况",{"2":{"46":1}}],["对于没有使用的2级页表就可以不需要存储再内存中了",{"2":{"35":1}}],["对于右移操作",{"2":{"15":1}}],["对已获得的资源保持不放",{"2":{"27":1}}],["对取回的指令进行拆分和解释",{"2":{"12":1}}],["对超出部分会自动设置为",{"2":{"5":1}}],["对象具有状态和行为",{"2":{"1":1}}],["将一个类的接口转换成客户希望的另一个接口",{"2":{"51":1}}],["将逻辑地址映射为物理地址",{"2":{"36":1}}],["将1级页表划分成若干个2级页表",{"2":{"35":1}}],["将页细化成定义了逻辑信息的具有实际意义的段",{"2":{"33":1}}],["将就绪队列再划",{"2":{"25":1}}],["将二进制数作为带符号的数值进行右移时",{"2":{"15":1}}],["将二进制的数值的各个位置上的元素作左移或右移操作",{"2":{"15":1}}],["将元素插入索引对应的空出空间",{"2":{"5":1}}],["将尾部到索引下标之间的元素依次后移",{"2":{"5":1}}],["将函数作为程序的基本构建块",{"2":{"1":1}}],["nginx",{"2":{"48":1}}],["name2",{"2":{"44":1}}],["name1",{"2":{"44":1}}],["name",{"2":{"43":5,"44":12}}],["nan",{"2":{"9":2}}],["normal",{"2":{"49":1}}],["not",{"2":{"49":1}}],["notify",{"2":{"43":2}}],["nodejs",{"2":{"43":1}}],["none",{"2":{"42":1}}],["non",{"2":{"29":1}}],["num",{"2":{"45":2}}],["numbers",{"2":{"9":11}}],["number",{"2":{"8":4,"9":4,"43":4,"45":4}}],["null",{"2":{"42":3,"43":1,"45":2}}],["next",{"2":{"45":7}}],["newstate",{"2":{"43":2}}],["new",{"2":{"23":1,"42":5,"43":3,"44":4,"45":3,"46":3,"47":2,"48":2,"49":3}}],["netstat",{"2":{"20":2}}],["n",{"2":{"5":4,"6":1}}],["处开始",{"2":{"5":1}}],["处理数据并和其他对象交互",{"2":{"1":1}}],["这种类型的设计模式属于结构型模式",{"2":{"47":1}}],["这个函数",{"2":{"42":1}}],["这样可加速查找并提高指令执行速度",{"2":{"35":1}}],["这会增加代码的复杂度和开销",{"2":{"31":1}}],["这会使系统性能降低",{"2":{"27":1}}],["这就需要简单",{"2":{"16":1}}],["这是因为负责解析和运行程序内容的",{"2":{"14":1}}],["这些行为就只好使用多重的条件选择语句来实现",{"2":{"49":1}}],["这些永远在互相等待的进程称为死锁进程",{"2":{"27":1}}],["这些数据也会被写入高速缓存中",{"2":{"13":1}}],["这些数据不会丢失",{"2":{"13":1}}],["这些过程按照特定的顺序执行",{"2":{"1":1}}],["这对于",{"2":{"5":1}}],["∗data",{"2":{"5":3}}],["it",{"2":{"49":2}}],["iteratorres",{"2":{"45":2}}],["iterator",{"2":{"45":10}}],["item",{"2":{"43":4}}],["implements",{"2":{"44":2,"49":2}}],["import",{"2":{"42":1}}],["is",{"2":{"43":1,"49":2}}],["index++",{"2":{"45":2}}],["index",{"2":{"45":5}}],["invalid",{"2":{"44":1}}],["inversion",{"2":{"40":1}}],["innerhtml",{"2":{"42":1}}],["instance",{"2":{"42":15}}],["interface",{"2":{"40":1,"45":1,"49":1}}],["integrated",{"2":{"13":1}}],["in",{"2":{"37":1,"38":1}}],["iproduct",{"2":{"44":4}}],["ipc",{"0":{"24":1}}],["ip",{"2":{"20":1}}],["io",{"2":{"20":2,"23":1}}],["iostat",{"2":{"20":1}}],["ios",{"2":{"19":1}}],["id",{"2":{"20":1}}],["ic是一个完整的结构",{"2":{"13":1}}],["ic",{"2":{"13":4}}],["i++",{"2":{"8":1,"9":1,"43":1}}],["ifstat",{"2":{"20":1}}],["if",{"2":{"8":6,"9":6,"43":5,"44":2,"45":2}}],["i∗n+j",{"2":{"5":1}}],["i−1",{"2":{"5":1}}],["i",{"2":{"5":3,"8":9,"9":4,"19":1,"43":4}}],["adaptee",{"2":{"51":1}}],["adapter",{"2":{"51":1}}],["adeptee",{"2":{"51":1}}],["addeventlistener",{"2":{"43":1}}],["addevenlistener",{"2":{"42":1}}],["address+",{"2":{"5":3}}],["address+i∗data",{"2":{"5":1}}],["address=base",{"2":{"5":4}}],["aop",{"2":{"47":1}}],["any",{"2":{"46":1}}],["android",{"2":{"19":1}}],["attach",{"2":{"43":3}}],["appendchild",{"2":{"42":1}}],["apply",{"2":{"42":1}}],["asynchronous",{"2":{"30":1}}],["awk",{"2":{"20":1}}],["aux",{"2":{"20":1}}],["aaaaaa",{"2":{"18":1}}],["aaaaaabbcddeeeeef",{"2":{"17":1,"18":1}}],["a6b2c1d2e5f1",{"2":{"17":1}}],["alert",{"2":{"44":2}}],["alertmessage",{"2":{"42":2}}],["algorithm",{"0":{"16":1},"1":{"17":1,"18":1}}],["alu负责处理算术和逻辑运算",{"2":{"12":1}}],["alu",{"2":{"12":1}}],["a2a1a0",{"2":{"15":1}}],["akak",{"2":{"15":1}}],["a9",{"2":{"13":4}}],["a0",{"2":{"13":4}}],["args",{"2":{"42":4}}],["arithmetic",{"2":{"12":1}}],["arr",{"2":{"8":2}}],["arr=",{"2":{"8":1}}],["array",{"2":{"3":1}}],["a",{"2":{"5":5,"20":1,"43":3,"49":1}}],["0110",{"2":{"15":1}}],["0010",{"2":{"15":1}}],["0001",{"2":{"15":1}}],["0000",{"2":{"15":3,"16":2}}],["000000",{"2":{"18":1}}],["00000",{"2":{"13":2}}],["0",{"0":{"5":1},"2":{"5":4,"8":6,"9":2,"13":2,"15":4,"43":4,"45":2}}],["1级页表中存储的是到2级页表的映射",{"2":{"35":1}}],["14862字节",{"2":{"18":1}}],["123456789101112131415161718192021222324",{"2":{"48":1}}],["1234567891011121314151617181920212223242526272829303132",{"2":{"46":1}}],["123456789101112131415161718192021222324252627282930313233343536373839",{"2":{"43":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445",{"2":{"49":1}}],["1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556",{"2":{"45":1}}],["1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556惰性弹窗",{"2":{"42":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940414243444546",{"2":{"9":1}}],["1234567891011121314151617181920212223242526272829303132333435363738394041发布",{"2":{"43":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940",{"2":{"8":1,"44":1}}],["12345678910111213141516171819202122",{"2":{"47":1}}],["12345678910111213141516171819",{"2":{"42":1}}],["12",{"2":{"17":1}}],["1byte",{"2":{"16":1}}],["16kb",{"2":{"14":1}}],["1kb",{"2":{"14":1}}],["1扇区",{"2":{"14":1}}],["1簇可以是",{"2":{"14":1}}],["10",{"2":{"18":1,"45":1}}],["1010101010",{"2":{"18":1}}],["1001",{"2":{"15":1}}],["1024个地址",{"2":{"13":1}}],["10次方",{"2":{"13":1}}],["17",{"2":{"8":1,"17":1,"18":1}}],["11101",{"2":{"18":1}}],["11100",{"2":{"18":1}}],["1111",{"2":{"16":1}}],["11111111",{"2":{"18":1}}],["11111",{"2":{"13":2}}],["110110",{"2":{"18":1}}],["1101",{"2":{"15":1}}],["11",{"2":{"8":1}}],["15",{"2":{"8":2}}],["19",{"2":{"8":1,"18":1}}],["13",{"2":{"8":1}}],["1",{"0":{"8":1},"2":{"4":1,"5":5,"6":1,"8":2,"9":13,"12":7,"13":6,"14":3,"15":3,"18":1,"37":1,"43":2,"46":1}}],["下标从",{"2":{"5":1}}],["下标",{"2":{"4":1,"5":1}}],["索引",{"2":{"4":1}}],["队列",{"2":{"3":1}}],["栈和树等",{"2":{"45":1}}],["栈寄存器",{"2":{"12":1}}],["栈",{"2":{"3":1}}],["排列而成的数据项的集合",{"2":{"3":1}}],["确定",{"2":{"3":1}}],["数字信号处理器",{"2":{"16":1}}],["数值一律用补码来表示并存储",{"2":{"15":1}}],["数量",{"2":{"12":1}}],["数组的规律是行元素从左到右递增",{"2":{"8":1}}],["数组的优劣",{"0":{"6":1}}],["数组所适合的是读",{"2":{"6":1}}],["数组基本操作",{"0":{"4":1},"1":{"5":1}}],["数组",{"0":{"2":1,"3":1},"1":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1},"2":{"3":1}}],["数据库orm",{"2":{"51":1}}],["数据的连续存储",{"2":{"37":1}}],["数据或代码页会根据需要在该物理内存与磁盘之间移动",{"2":{"36":1}}],["数据段",{"2":{"34":1}}],["数据处理工具",{"2":{"20":1}}],["数据",{"2":{"17":1}}],["数据信号",{"2":{"13":2}}],["数据读入寄存器",{"2":{"12":1}}],["数据和地址",{"2":{"12":1}}],["数据转换等问题",{"2":{"1":1}}],["数据结构与算法",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1}}],["fn1",{"2":{"44":5}}],["fn",{"2":{"42":2}}],["frequently",{"2":{"38":1}}],["filter",{"2":{"43":1}}],["filename",{"2":{"48":8}}],["file",{"2":{"37":1}}],["first",{"2":{"38":2}}],["fifo",{"2":{"38":1}}],["findnumberin2darray2",{"2":{"8":1}}],["findnumberin2darray1",{"2":{"8":1}}],["f",{"2":{"18":1,"20":1}}],["floor",{"2":{"9":1}}],["foreach",{"2":{"43":2}}],["fork",{"2":{"24":1}}],["for",{"2":{"8":2,"9":1,"43":1}}],["fop",{"2":{"1":1}}],["false",{"2":{"8":4,"43":4,"45":1}}],["functional",{"2":{"1":1}}],["function",{"2":{"1":1,"8":2,"9":2,"42":6,"43":2}}],["通信",{"2":{"43":1}}],["通知",{"2":{"43":2}}],["通常大小是内存的",{"2":{"37":1}}],["通常大小为",{"2":{"36":1}}],["通常适用于处理数学运算",{"2":{"1":1}}],["通常适用于处理简单",{"2":{"1":1}}],["通用寄存器",{"2":{"12":1}}],["通过职责链上的多个对象对分解请求流程",{"2":{"50":1}}],["通过复制该原型对象来创建一个和原型相同或相似的新对象",{"2":{"46":1}}],["通过通知操作的方式来保持多线程同步",{"2":{"26":1}}],["通过控制同一时刻多个线程访问同一资源最大线程数量",{"2":{"26":1}}],["通过互斥对象具有唯一性",{"2":{"26":1}}],["通过父进程",{"2":{"24":1}}],["通过系统调用",{"2":{"19":1}}],["通过程序计数器读出程序指令指定的是内存地址",{"2":{"14":1}}],["通过数组的索引",{"2":{"5":1}}],["通过数组的长度计算出即将插入元素的内存地址",{"2":{"5":1}}],["通过数组的",{"2":{"4":1}}],["通过组合和转换函数实现复杂的计算过程",{"2":{"1":1}}],["强调函数的使用和复用",{"2":{"1":1}}],["postmessage",{"2":{"43":1}}],["pop",{"2":{"1":1}}],["push",{"2":{"43":2}}],["publisher",{"2":{"43":2}}],["public",{"2":{"42":1,"46":5,"49":4}}],["pt页面置换算法",{"2":{"38":1}}],["param",{"2":{"42":1}}],["parallelism",{"2":{"28":1}}],["page",{"2":{"37":3}}],["p3",{"2":{"27":1}}],["png",{"2":{"48":1}}],["pn正在等待已被p0占用的资源",{"2":{"27":1}}],["pn",{"2":{"27":1}}],["p2",{"2":{"27":2,"44":3}}],["p1正在等待p2占用的资源",{"2":{"27":1}}],["p1",{"2":{"27":3,"44":3}}],["p0",{"2":{"27":2}}],["p",{"2":{"20":2}}],["ps",{"2":{"20":1}}],["pidstat",{"2":{"20":1}}],["pid",{"2":{"20":3}}],["pwd",{"2":{"20":1}}],["primitive",{"2":{"46":1}}],["priority",{"2":{"43":4}}],["private",{"2":{"42":2,"43":3,"45":4,"47":2,"48":1,"49":1}}],["principle",{"2":{"40":5}}],["pre",{"2":{"9":2}}],["proximg",{"2":{"48":2}}],["proxyimg",{"2":{"48":2}}],["proxy",{"2":{"42":1,"48":1}}],["prototype",{"2":{"46":8}}],["product2",{"2":{"44":3}}],["product1",{"2":{"44":3}}],["promise",{"2":{"43":1,"50":1}}],["processor",{"2":{"16":1}}],["processing",{"0":{"12":1}}],["procedural",{"2":{"1":1}}],["procedure",{"2":{"1":1}}],["programming",{"2":{"1":3}}],["在代理层做权限控制或在对象访问与修改时要执行一些其他逻辑",{"2":{"48":1}}],["在构造函数中进行此类处理比较方便",{"2":{"46":1}}],["在组件销毁之前需要进行",{"2":{"43":1}}],["在发布订阅模式中",{"2":{"43":1}}],["在发生死锁时",{"2":{"27":1}}],["在目标发出内容改变的事件后",{"2":{"43":1}}],["在观察者模式中",{"2":{"43":1}}],["在分页式中",{"2":{"37":1}}],["在不考虑程序构造的情况下",{"2":{"37":1}}],["在页式管理基础上增加请求调页功能和页面置换功能",{"2":{"37":1}}],["在某个时刻只有一件事情在执行",{"2":{"28":1}}],["在同一时间内多件事情能被交替地处理",{"2":{"28":1}}],["在同一时间内有几件事情并行在处理",{"2":{"28":1}}],["在",{"2":{"19":2,"43":1}}],["在频率表中删除此次找到的两个数",{"2":{"18":1}}],["在视频编码中会同时用到帧内与帧间的编码方法",{"2":{"16":1}}],["在任何情况下",{"2":{"16":1}}],["在保留数字的符号",{"2":{"15":1}}],["在计算机系统中",{"2":{"15":1}}],["在二进制中",{"2":{"15":1}}],["在软盘中簇和扇区的大小是相等的",{"2":{"14":1}}],["在逻辑方面对磁盘进行读写的单位是扇区整数倍簇",{"2":{"14":1}}],["在执行指令过程中有可能需要从内存中提取数据",{"2":{"12":1}}],["在一个二维数组中",{"2":{"8":1}}],["在pop中",{"2":{"1":1}}],["在oop",{"2":{"1":1}}],["中介者模式",{"2":{"41":1}}],["中的p0正在等待一个p1占用的资源",{"2":{"27":1}}],["中的运算数据",{"2":{"13":1}}],["中则被称为动态链接库",{"2":{"19":1}}],["中叫做共享库",{"2":{"19":1}}],["中使用的磁盘",{"2":{"14":1}}],["中寄存器",{"2":{"12":1}}],["中根据功能的不同",{"2":{"12":1}}],["中间件机制",{"2":{"50":1}}],["中间的数等于右边",{"2":{"9":1}}],["中间数小于右边数",{"2":{"9":1}}],["中间数大于右边数",{"2":{"9":1}}],["中间元素的下标",{"2":{"9":1}}],["中",{"2":{"1":1}}],["options",{"2":{"43":2}}],["open",{"2":{"40":1}}],["on",{"2":{"43":1}}],["once",{"2":{"43":1}}],["off",{"2":{"43":3}}],["observer2",{"2":{"43":2}}],["observer1",{"2":{"43":2}}],["observers",{"2":{"43":3}}],["observer",{"2":{"43":8}}],["object>",{"2":{"42":1}}],["object",{"2":{"1":2,"46":4,"51":1}}],["out",{"2":{"37":1,"38":1}}],["o",{"2":{"5":6,"6":2,"19":1,"43":2}}],["oop通常适用于处理与现实世界有关的问题",{"2":{"1":1}}],["oriented",{"2":{"1":6}}],["面向切面编程",{"2":{"47":1}}],["面向函数",{"0":{"1":1},"2":{"1":1}}],["面向过程",{"0":{"1":1},"2":{"1":1}}],["面向对象",{"0":{"1":1},"2":{"1":1}}]],"serializationVersion":2}';export{t as default};
