const t='{"documentCount":32,"nextId":32,"documentIds":{"0":"/silver-bullet/basics/data-structures-algorithms#数据结构与算法","1":"/silver-bullet/basics/data-structures-algorithms#面向对象、面向过程、面向函数","2":"/silver-bullet/basics/data-structures-algorithms#数组","3":"/silver-bullet/basics/data-structures-algorithms#集合、列表、数组","4":"/silver-bullet/basics/data-structures-algorithms#数组基本操作","5":"/silver-bullet/basics/data-structures-algorithms#为什么数组下标从-0-开始","6":"/silver-bullet/basics/data-structures-algorithms#数组的优劣","7":"/silver-bullet/basics/data-structures-algorithms#算法题","8":"/silver-bullet/basics/data-structures-algorithms#_1-二维数组的查找","9":"/silver-bullet/basics/data-structures-algorithms#_2-旋转数组的最小数字","10":"/silver-bullet/basics/internet#计算机网络","11":"/silver-bullet/basics/make-up-principle#计算机组成原理","12":"/silver-bullet/basics/os#操作系统","13":"/silver-bullet/basics/os#linux","14":"/silver-bullet/basics/os#进程与线程","15":"/silver-bullet/basics/os#进程与线程区别-即概念","16":"/silver-bullet/basics/os#进程的状态","17":"/silver-bullet/basics/os#进程通信-ipc","18":"/silver-bullet/basics/os#进程的调度算法","19":"/silver-bullet/basics/os#线程同步","20":"/silver-bullet/basics/os#死锁","21":"/silver-bullet/basics/os#并行与并发","22":"/silver-bullet/basics/os#阻塞与非阻塞","23":"/silver-bullet/basics/os#同步与异步","24":"/silver-bullet/basics/os#单线程与多线程","25":"/silver-bullet/basics/os#内存管理","26":"/silver-bullet/basics/os#内存管理机制","27":"/silver-bullet/basics/os#分页与分段","28":"/silver-bullet/basics/os#快表与多级页表","29":"/silver-bullet/basics/os#物理地址和逻辑-虚拟-地址","30":"/silver-bullet/basics/os#虚拟内存","31":"/silver-bullet/basics/os#页面置换算法-淘汰机制-算法"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[4,1,38],"2":[1,1,1],"3":[3,2,24],"4":[1,2,8],"5":[4,3,62],"6":[1,2,14],"7":[1,2,1],"8":[2,3,85],"9":[2,3,77],"10":[1,1,1],"11":[1,1,1],"12":[1,1,35],"13":[1,1,108],"14":[1,1,1],"15":[3,2,24],"16":[1,2,19],"17":[3,2,32],"18":[1,2,41],"19":[1,2,11],"20":[1,2,126],"21":[1,2,16],"22":[1,2,12],"23":[1,2,22],"24":[1,2,27],"25":[1,1,4],"26":[1,2,19],"27":[1,2,19],"28":[1,2,35],"29":[3,2,22],"30":[1,2,69],"31":[4,2,28]},"averageFieldLength":[1.59375,1.8125,30.71875],"storedFields":{"0":{"title":"数据结构与算法","titles":[]},"1":{"title":"面向对象、面向过程、面向函数？","titles":["数据结构与算法"]},"2":{"title":"数组","titles":["数据结构与算法"]},"3":{"title":"集合、列表、数组","titles":["数据结构与算法","数组"]},"4":{"title":"数组基本操作","titles":["数据结构与算法","数组"]},"5":{"title":"为什么数组下标从 0 开始？","titles":["数据结构与算法","数组","数组基本操作"]},"6":{"title":"数组的优劣","titles":["数据结构与算法","数组"]},"7":{"title":"算法题","titles":["数据结构与算法","数组"]},"8":{"title":"1. 二维数组的查找","titles":["数据结构与算法","数组","算法题"]},"9":{"title":"2. 旋转数组的最小数字","titles":["数据结构与算法","数组","算法题"]},"10":{"title":"计算机网络","titles":[]},"11":{"title":"计算机组成原理","titles":[]},"12":{"title":"操作系统","titles":[]},"13":{"title":"Linux","titles":["操作系统"]},"14":{"title":"进程与线程","titles":["操作系统"]},"15":{"title":"进程与线程区别（即概念）","titles":["操作系统","进程与线程"]},"16":{"title":"进程的状态","titles":["操作系统","进程与线程"]},"17":{"title":"进程通信（IPC）","titles":["操作系统","进程与线程"]},"18":{"title":"进程的调度算法","titles":["操作系统","进程与线程"]},"19":{"title":"线程同步","titles":["操作系统","进程与线程"]},"20":{"title":"死锁","titles":["操作系统","进程与线程"]},"21":{"title":"并行与并发","titles":["操作系统","进程与线程"]},"22":{"title":"阻塞与非阻塞","titles":["操作系统","进程与线程"]},"23":{"title":"同步与异步","titles":["操作系统","进程与线程"]},"24":{"title":"单线程与多线程","titles":["操作系统","进程与线程"]},"25":{"title":"内存管理","titles":["操作系统"]},"26":{"title":"内存管理机制","titles":["操作系统","内存管理"]},"27":{"title":"分页与分段","titles":["操作系统","内存管理"]},"28":{"title":"快表与多级页表","titles":["操作系统","内存管理"]},"29":{"title":"物理地址和逻辑（虚拟）地址","titles":["操作系统","内存管理"]},"30":{"title":"虚拟内存","titles":["操作系统","内存管理"]},"31":{"title":"页面置换算法（淘汰机制/算法）","titles":["操作系统","内存管理"]}},"dirtCount":0,"index":[["赋予每页一个上次访问所经历的时间t字段",{"2":{"31":1}}],["赋值更改",{"2":{"5":1}}],["淘汰t值最大的页",{"2":{"31":1}}],["淘汰在内存中驻留时间最久的页",{"2":{"31":1}}],["淘汰机制",{"0":{"31":1}}],["置换所需外存中的页",{"2":{"31":1}}],["缺页时淘汰链表尾节点的页",{"2":{"31":1}}],["缺页中断时将选择合适的内存中的页调出",{"2":{"31":1}}],["缺段",{"2":{"30":1}}],["倍",{"2":{"30":1}}],["生成和管理",{"2":{"30":1}}],["该文件由",{"2":{"30":1}}],["把内存的内容写入磁盘称为",{"2":{"30":1}}],["把磁盘的内容读到内存中称为",{"2":{"30":1}}],["把运行的程序按照一定大小",{"2":{"30":1}}],["把一个数组最开始的若干个元素搬到数组的末尾",{"2":{"9":1}}],["采用的是分页式",{"2":{"30":1}}],["采用虚拟寻址",{"2":{"29":1}}],["称为缺页",{"2":{"30":1}}],["需执行的指令或数据未在内存",{"2":{"30":1}}],["需要额外的操作才能得到预期的结果是为异步",{"2":{"23":1}}],["需要破坏死锁发生的必要条件之一",{"2":{"20":1}}],["换空间",{"2":{"30":1}}],["换队首进程运行",{"2":{"18":1}}],["利用局部性原理实现髙速缓存",{"2":{"30":1}}],["产生于指令的顺序存放和顺序执行",{"2":{"30":1}}],["产生于程序存在的循环操作",{"2":{"30":1}}],["空间局部性",{"2":{"30":1}}],["空闲物理内存",{"2":{"13":1}}],["局部性原理",{"2":{"30":1}}],["实际上被分隔成多个物理内存碎片或部分存储在外部磁盘存储器",{"2":{"30":1}}],["实现方式可以是",{"2":{"30":1}}],["实现",{"2":{"18":1}}],["会影响到操作系统",{"2":{"29":1}}],["会对操作系统造成伤害",{"2":{"29":1}}],["保存到磁盘文件",{"2":{"29":1}}],["地址空间",{"2":{"30":1}}],["地址",{"0":{"29":1}}],["地收取",{"2":{"23":1}}],["虚拟内存技术就是建立了",{"2":{"30":1}}],["虚拟内存定义了一个连续的虚拟",{"2":{"30":1}}],["虚拟内存",{"0":{"30":1}}],["虚拟地址允许访问大于可用物理内存的内存缓冲区",{"2":{"29":1}}],["虚拟地址允许一系列相邻的虚拟地址访问真实物理地址不连续的内存区域",{"2":{"29":1}}],["虚拟",{"0":{"29":1}}],["使得页表占用的内存空间大幅减少",{"2":{"28":1}}],["使用情况统计",{"2":{"13":1}}],["使用",{"2":{"13":1}}],["使用的内存占比",{"2":{"13":1}}],["使用的",{"2":{"13":1}}],["使用的交换区等",{"2":{"13":1}}],["引入多级页表",{"2":{"28":1}}],["引入块表后",{"2":{"28":1}}],["尤其是根本就不需要的页表",{"2":{"28":1}}],["又要登记新页时",{"2":{"28":1}}],["又称",{"2":{"18":1}}],["又称线性列表",{"2":{"3":1}}],["再从页表中得到物理地址",{"2":{"28":1}}],["根据虚拟地址中的页号查快表",{"2":{"28":1}}],["转换流程如下",{"2":{"28":1}}],["要访问两次主存",{"2":{"28":1}}],["要求运行时间",{"2":{"18":2}}],["读写内存数据时",{"2":{"28":1}}],["读取元素",{"2":{"4":1}}],["来加速虚拟地址到物理地址的转换",{"2":{"28":1}}],["来说",{"2":{"5":1}}],["之于",{"2":{"28":1}}],["类似于redis",{"2":{"28":1}}],["类型相同",{"2":{"3":1}}],["类型不一定相同",{"2":{"3":2}}],["快表与多级页表",{"0":{"28":1}}],["体现为代码段",{"2":{"27":1}}],["仅为满足操作系统内存管理需求",{"2":{"27":1}}],["物理内存页+磁盘文件",{"2":{"29":1}}],["物理信息单位",{"2":{"27":1}}],["物理地址和逻辑",{"0":{"29":1}}],["物理地址",{"2":{"26":1}}],["大小不固定",{"2":{"27":1}}],["减少内存碎片",{"2":{"27":1}}],["先进先出页面置换算法",{"2":{"31":1}}],["先分段再分页",{"2":{"26":1}}],["先到先服务",{"2":{"18":1}}],["段取决于当前运行的程序",{"2":{"27":1}}],["段之内",{"2":{"27":1}}],["段之间",{"2":{"27":1}}],["段页式管理",{"2":{"26":1}}],["段表",{"2":{"26":1}}],["段式管理",{"2":{"26":1}}],["逻辑信息单位",{"2":{"27":1}}],["逻辑",{"2":{"26":1,"30":1}}],["逻辑地址转换为物理地址",{"2":{"25":1}}],["页面置换算法目的是选择内存中合适的页淘汰掉",{"2":{"31":1}}],["页面置换算法",{"0":{"31":1},"2":{"31":3}}],["页文件",{"2":{"30":1}}],["页调入调出时间",{"2":{"30":1}}],["页表的高速缓冲存储器",{"2":{"28":1}}],["页表记录",{"2":{"26":1}}],["页大小固定",{"2":{"27":1}}],["页之内均为连续的",{"2":{"27":1}}],["页之间均为离散存储",{"2":{"27":1}}],["页是物理信息单位",{"2":{"26":1}}],["页式管理",{"2":{"26":1}}],["碎片",{"2":{"26":1}}],["块中容易形成未被利用的内存空间",{"2":{"26":1}}],["块式管理",{"2":{"26":1}}],["连续分配管理",{"2":{"26":1}}],["性能问题",{"2":{"24":1}}],["性能更高",{"2":{"13":1}}],["安全问题",{"2":{"24":1}}],["安全性算法",{"2":{"20":1}}],["竞态条件",{"2":{"24":1}}],["竞争资源",{"2":{"20":1}}],["避免数据竞争和死锁",{"2":{"24":1}}],["避免阻塞",{"2":{"24":1}}],["避免死锁",{"2":{"20":1}}],["各线程独立",{"2":{"24":1}}],["各方都实时",{"2":{"23":1}}],["代码运行的环境不同",{"2":{"24":1}}],["代价指优先级",{"2":{"20":1}}],["同时访问同一物理内存地址而崩溃",{"2":{"29":1}}],["同时将页表中的该映射表项添加到快表中",{"2":{"28":1}}],["同时容易代码阻塞",{"2":{"24":1}}],["同步问题",{"2":{"24":1}}],["同步时调用者主动等待调用过程",{"2":{"23":1}}],["同步",{"2":{"23":1}}],["同步与异步",{"0":{"23":1}}],["那么剩下代码将不再执行",{"2":{"24":1}}],["逐行执行",{"2":{"24":1}}],["逐步向后查询",{"2":{"5":1}}],["单线程",{"2":{"24":1}}],["单线程与多线程",{"0":{"24":1}}],["单向数据流动",{"2":{"17":2}}],["异步指两个或两个以上的对象或事件不同时存在或发生",{"2":{"23":1}}],["异步",{"2":{"23":1}}],["也就是",{"2":{"23":1}}],["也可以从右上角开始",{"2":{"8":1}}],["没有结果之前不会返回",{"2":{"23":1}}],["程序运行时",{"2":{"30":1}}],["程序在一段时间内所访问的可能是一定范围内的内存地址",{"2":{"30":1}}],["程序在某一段时间内访问同一数据或执行同一指令多次",{"2":{"30":1}}],["程序发出调用之后",{"2":{"23":1}}],["程序发出调用的时候",{"2":{"23":1}}],["程序执行",{"2":{"15":1}}],["信息的即时沟通方式",{"2":{"23":1}}],["信号量",{"2":{"17":2,"19":1}}],["信号",{"2":{"17":1,"20":1}}],["阻塞是指调用在等待的过程中线程被挂起",{"2":{"22":1}}],["阻塞",{"2":{"22":1}}],["阻塞与非阻塞",{"0":{"22":1}}],["阻塞状态",{"2":{"16":1}}],["能更好满足用户需求",{"2":{"27":1}}],["能实现多任务运行的过程就是并发",{"2":{"21":1}}],["能不能使进程队列的某个进程执行完毕",{"2":{"20":1}}],["重点是",{"2":{"21":1}}],["指程序的设计结构",{"2":{"21":1}}],["指程序的运行状态",{"2":{"21":1}}],["直接从快表中读取相应的物理地址",{"2":{"28":1}}],["直接删除",{"2":{"5":1}}],["直到有足够的资源可用和死锁状态消除为止",{"2":{"20":1}}],["撤消进程",{"2":{"20":1}}],["以解除死锁状态",{"2":{"20":1}}],["以此判断是否分配资源",{"2":{"20":1}}],["剥夺资源",{"2":{"20":1}}],["解除死锁",{"2":{"20":1}}],["解决死锁的基本方法",{"2":{"20":1}}],["为了实现虚拟内存功能",{"2":{"30":1}}],["为了避免把全部页表",{"2":{"28":1}}],["为了解决虚拟地址到物理地址的转换速度",{"2":{"28":1}}],["为每个进程和每个资源指定一个唯一标识",{"2":{"20":1}}],["为什么数组下标从",{"0":{"5":1}}],["检测死锁",{"2":{"20":1}}],["否则不安全",{"2":{"20":1}}],["回收和地址转换",{"2":{"25":1}}],["回收",{"2":{"20":3}}],["剩余资源数量增加",{"2":{"20":1}}],["则系统处于安全状态",{"2":{"20":1}}],["则系统处于不安全状态",{"2":{"20":1}}],["则假设p3执行完毕后回收已分配给它的资源并标记为可完成",{"2":{"20":1}}],["随时间推移",{"2":{"20":1}}],["随机访问即时间复杂度o",{"2":{"4":1}}],["判断分配给p1后剩余的资源",{"2":{"20":1}}],["判断数组中是否含有该整数",{"2":{"8":1}}],["让该进程继续等待",{"2":{"20":1}}],["若用户能访问任意物理内存",{"2":{"29":1}}],["若采用页表做地址转换",{"2":{"28":1}}],["若所有进程都将能执行完毕",{"2":{"20":1}}],["若存在进程p3可执行完毕",{"2":{"20":1}}],["若没有进程可执行完毕",{"2":{"20":1}}],["若不安全则试探分配作废",{"2":{"20":1}}],["若无外力作用",{"2":{"20":1}}],["然后继续判断队列中的其它进程",{"2":{"20":1}}],["然后通过安全性算法判断分配后的系统是否处于安全状态",{"2":{"20":1}}],["然后将该元素插入到尾部",{"2":{"5":1}}],["前提是申请的资源数量小于等于剩余资源",{"2":{"20":1}}],["前一段的元素一定大于等于后一段的元素",{"2":{"9":1}}],["银行家算法通过先试探分配给该进程资源",{"2":{"20":1}}],["及两个二维数组claim",{"2":{"20":1}}],["未分配给进程的每种资源的总量",{"2":{"20":1}}],["系统终将处于死锁状态",{"2":{"20":1}}],["系统的安全状态是指至少存在一个资源分配序列不会导致死锁",{"2":{"20":1}}],["系统的状态是当前给进程分配的资源情况",{"2":{"20":1}}],["系统中每种资源的总量",{"2":{"20":1}}],["包含两个一维数组resource",{"2":{"20":1}}],["包括隐藏文件",{"2":{"13":1}}],["包括数组",{"2":{"3":1}}],["而段",{"2":{"27":1}}],["而避免死锁允许进程动态地申请资源",{"2":{"20":1}}],["而是一次性申请所有需要的资源",{"2":{"20":1}}],["而且必要的话也处理或者回复",{"2":{"23":1}}],["而且左边大于等于右边",{"2":{"9":1}}],["而且使用二分法比较中间元素与右侧元素的大小关系",{"2":{"9":1}}],["申请的时候按序号从小到大进行申请",{"2":{"20":1}}],["申请使用系统态级别的资源",{"2":{"12":1}}],["所以并行需要多个线程在同一时间执行多件事情",{"2":{"21":1}}],["所以可以分成以下情况",{"2":{"9":1}}],["所谓按序申请",{"2":{"20":1}}],["非连续分配管理",{"2":{"26":1}}],["非阻塞是指等待的过程",{"2":{"22":1}}],["非阻塞",{"2":{"22":1}}],["非请求",{"2":{"20":1}}],["非循环等待",{"2":{"20":1}}],["非保持",{"2":{"20":1}}],["非尾部删除",{"2":{"5":1}}],["非尾部插入",{"2":{"5":1}}],["其中最具有代表性的避免死锁算法是银行家算法",{"2":{"20":1}}],["其中不能破坏互斥条件",{"2":{"20":1}}],["其中第",{"2":{"5":1}}],["预防死锁是严格防止死锁的出现",{"2":{"20":1}}],["预防死锁",{"2":{"20":1}}],["缓冲区内的消息等",{"2":{"20":1}}],["消息",{"2":{"20":1}}],["消息队列克服了信号承载信息量少",{"2":{"17":1}}],["消息队列是内核中由消息队列标识符标识的消息构成的链表",{"2":{"17":1}}],["消息队列",{"2":{"17":1}}],["临时资源包括硬件中断",{"2":{"20":1}}],["与之相对的是可以再被其他进程或系统剥夺的可剥夺性资源",{"2":{"20":1}}],["打印机等",{"2":{"20":1}}],["打包并压缩",{"2":{"13":1}}],["必然存在一个进程",{"2":{"20":1}}],["环路等待条件",{"2":{"20":1}}],["当可用物理内存变小时内存管理器会将物理内存页",{"2":{"29":1}}],["当快表填满后",{"2":{"28":1}}],["当一个进程申请使用资源的时候",{"2":{"20":1}}],["当进程因请求资源而阻塞时",{"2":{"20":1}}],["当前行不大于目标元素",{"2":{"8":1}}],["当前行已经都比目标元素大",{"2":{"8":1}}],["当前一维数组大了",{"2":{"8":1}}],["请求段页式存储管理",{"2":{"30":1}}],["请求分段存储管理",{"2":{"30":1}}],["请求分页存储管理",{"2":{"30":1}}],["请求和保持条件",{"2":{"20":1}}],["请完成一个函数",{"2":{"8":1}}],["死锁产生的两类原因",{"2":{"20":1}}],["死锁的发生必须具备以下四个必要条件",{"2":{"20":1}}],["死锁是指两个或两个以上的进程在运行过程中因争夺资源或因彼此通信而造成的一一种阻塞的现象",{"2":{"20":1}}],["死锁",{"0":{"20":1}}],["便于实现多线程优先级的比较操作",{"2":{"19":1}}],["事件",{"2":{"19":1}}],["只能在进程用完后自行释放的资源",{"2":{"20":1}}],["只能在使用完时由自己释放",{"2":{"20":1}}],["只有拥有互斥对象的线程才能访问公共资源",{"2":{"19":1}}],["只打包不压缩",{"2":{"13":1}}],["方式",{"2":{"19":1}}],["不断维护一个按最近一段时间使用频率排序的页链表",{"2":{"31":1}}],["不可实现的理想情况",{"2":{"31":1}}],["不可剥夺资源",{"2":{"20":1}}],["不需要的调入外存",{"2":{"30":1}}],["不同进程使用的虚拟地址彼此隔离",{"2":{"29":1}}],["不同子队列采用适合自己队列进程性质的调度算法",{"2":{"18":1}}],["不能剥夺",{"2":{"20":1}}],["不剥夺条件",{"2":{"20":1}}],["不一定互异",{"2":{"3":2}}],["分段目的都是提高内存利用率",{"2":{"27":1}}],["分页",{"2":{"27":2}}],["分页与分段",{"0":{"27":1}}],["分配给",{"2":{"20":1}}],["分配给p2",{"2":{"20":1}}],["分配给p0",{"2":{"20":1}}],["分配给某进程后不能强行收回",{"2":{"20":1}}],["分成子队列",{"2":{"18":1}}],["分析",{"2":{"8":1,"9":1}}],["多线程处理可能会导致过多的上下文切换和内存消耗",{"2":{"24":1}}],["多线程处理会导致访问共享内存的竞争条件",{"2":{"24":1}}],["多线程可能会存在安全漏洞",{"2":{"24":1}}],["多线程可能出现的问题",{"2":{"24":1}}],["多线程需要进行同步",{"2":{"24":1}}],["多线程",{"2":{"24":1}}],["多线程编程性能和体验更好",{"2":{"15":1}}],["多级反馈队列",{"2":{"18":1}}],["等待时间越长或运行时间越短响应比越高",{"2":{"18":1}}],["等待资源或",{"2":{"16":1}}],["已等待时间",{"2":{"18":1}}],["已用物理内存",{"2":{"13":1}}],["高速缓存实现",{"2":{"30":1}}],["高响应比",{"2":{"18":2}}],["高效",{"2":{"6":1}}],["相同优先级的进程以先到先服务方式运行",{"2":{"18":1}}],["相比下标从",{"2":{"5":1}}],["优先的原则",{"2":{"18":1}}],["优先级",{"2":{"18":2}}],["优先照顾了短进程而忽略了长进程",{"2":{"18":1}}],["优化解法",{"2":{"8":1,"9":1}}],["选择就绪队列中估计运行时间最短的进程运行",{"2":{"18":1}}],["短进程优先",{"2":{"18":1}}],["按照",{"2":{"18":1}}],["按照一定的线性顺序",{"2":{"3":1}}],["按内存",{"2":{"18":1}}],["按进程进入就绪队列的先后次序运行",{"2":{"18":1}}],["算法",{"0":{"31":1}}],["算法有",{"2":{"18":1}}],["算法题",{"0":{"7":1},"1":{"8":1,"9":1}}],["目的在于确定进程的执行顺序",{"2":{"18":1}}],["目的在于进程间同步并避免竞争条件",{"2":{"17":1}}],["还可用于不同机器之间的进程",{"2":{"17":1}}],["套接字",{"2":{"17":1}}],["最近最少使用页面排序算法",{"2":{"31":1}}],["最近最久未使用页面置换算法",{"2":{"31":1}}],["最佳页面置换算法",{"2":{"31":1}}],["最大利用率",{"2":{"18":1}}],["最快且最有用的进程间通信方式",{"2":{"17":1}}],["最小元素在",{"2":{"9":4}}],["最小在",{"2":{"9":4}}],["最小数字一定是第一段非递减元素末尾的下一个",{"2":{"9":1}}],["进行进程间同步",{"2":{"17":1}}],["进程间的推进顺序非法",{"2":{"20":1}}],["进程集合",{"2":{"20":1}}],["进程已获得的资源在未使用完之前",{"2":{"20":1}}],["进程要求对所分配的资源进行排它性控制",{"2":{"20":1}}],["进程性质和类型",{"2":{"18":1}}],["进程的重要性和价值等",{"2":{"20":1}}],["进程的调度算法",{"0":{"18":1}}],["进程的状态",{"0":{"16":1}}],["进程占用资源多于线程",{"2":{"15":1}}],["进程拥有独立的地址数据空间",{"2":{"15":1}}],["进程是系统资源分配的最小独立单位",{"2":{"15":1}}],["进程和线程都是在程序执行过程中的运行活动",{"2":{"15":1}}],["进程与线程区别",{"0":{"15":1}}],["进程与线程",{"0":{"14":1},"1":{"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1}}],["进程详细信息",{"2":{"13":1}}],["进程数统计",{"2":{"13":1}}],["进程通信",{"0":{"17":1},"2":{"12":1}}],["进程控制",{"2":{"12":1}}],["互不影响",{"2":{"24":1}}],["互斥条件",{"2":{"20":1}}],["互斥量",{"2":{"19":1}}],["互斥锁",{"2":{"17":1}}],["互异",{"2":{"3":1}}],["往往配合其他通信机制",{"2":{"17":1}}],["共享内存",{"2":{"17":1}}],["共享内存大小",{"2":{"13":1}}],["管道只能承载无格式字节流和缓冲区大小受限等缺点",{"2":{"17":1}}],["一般作为衡量其他置换算法的方法",{"2":{"31":1}}],["一直放在内存中占用过多空间",{"2":{"28":1}}],["一直等待直到返回结果",{"2":{"23":1}}],["一种比较复杂的通信方式",{"2":{"17":1}}],["一个计数器",{"2":{"17":1}}],["一个进程至少有一个运行代码的主线程",{"2":{"15":1}}],["一个进程死掉不影响另一个进程",{"2":{"15":1}}],["一个线程死掉可能会导致整个进程被操作系统杀掉",{"2":{"15":1}}],["存在于磁盘",{"2":{"17":1}}],["存在于内存",{"2":{"17":1}}],["且能立即得到结果的",{"2":{"23":1}}],["且无论是否亲缘关系的进程通信",{"2":{"17":1}}],["且仅具有亲缘关系的进程通信",{"2":{"17":1}}],["有时只需访问一次高速缓冲存储器和一次主存",{"2":{"28":1}}],["有名管道",{"2":{"17":1}}],["有序",{"2":{"3":2}}],["出来的子进程",{"2":{"17":1}}],["半双工通信",{"2":{"17":2}}],["无法立即得到结果",{"2":{"23":1}}],["无名管道",{"2":{"17":1}}],["无序",{"2":{"3":1}}],["正常结束或中断退出",{"2":{"16":1}}],["结束状态",{"2":{"16":1}}],["操作完成",{"2":{"16":1}}],["操作系统在页表方案基础之上引入了快表",{"2":{"28":1}}],["操作系统支持额外的扩展",{"2":{"12":1}}],["操作系统是运行在计算机上管理计算机硬件与软件资源的软件程序",{"2":{"12":1}}],["操作系统",{"0":{"12":1},"1":{"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1}}],["运行代价",{"2":{"20":1}}],["运行状态",{"2":{"16":1}}],["运行进程",{"2":{"13":1}}],["就按照一定的淘汰策略淘汰掉快表中的一个页",{"2":{"28":1}}],["就访问内存中的页表",{"2":{"28":1}}],["就差",{"2":{"16":1}}],["就绪状态",{"2":{"16":1}}],["就是少了一次减法指令",{"2":{"5":1}}],["独享栈和寄存器等资源",{"2":{"15":1}}],["静态变量",{"2":{"15":1}}],["静态语言",{"2":{"3":1}}],["全局变量",{"2":{"15":1}}],["资源还在该线程中",{"2":{"22":1}}],["资源被分配到其他地方去",{"2":{"22":1}}],["资源的环形链",{"2":{"20":1}}],["资源就可运行",{"2":{"16":1}}],["资源",{"2":{"15":1}}],["占用大量",{"2":{"15":1}}],["占比",{"2":{"13":1}}],["却对其余进程不友好",{"2":{"15":1}}],["调度",{"2":{"15":1,"18":1}}],["即淘汰",{"2":{"31":1}}],["即为同步",{"2":{"23":1}}],["即撤消死锁进程或撤消代价最小的进程",{"2":{"20":1}}],["即从其它进程剥夺足够数量的资源给死锁进程",{"2":{"20":1}}],["即发现有进程死锁的同时立即把它从死锁状态中解脱出来",{"2":{"20":1}}],["即此时没有一个进程能够完成并释放资源",{"2":{"20":1}}],["即不是使用前才申请",{"2":{"20":1}}],["即按序申请",{"2":{"20":1}}],["即占用部分资源的线程如果申请不到其他资源时",{"2":{"20":1}}],["即在一段时间内某资源仅为一进程所占用",{"2":{"20":1}}],["即该进程允许运行的时间",{"2":{"18":1}}],["即等待状态",{"2":{"16":1}}],["即概念",{"0":{"15":1}}],["即函数式编程",{"2":{"1":1}}],["它们都将无法推进下去",{"2":{"20":1}}],["它可以前后翻页",{"2":{"13":1}}],["它将程序看作是函数的集合",{"2":{"1":1}}],["它将程序看作是一系列过程或函数的集合",{"2":{"1":1}}],["它将程序看作是一组对象的集合",{"2":{"1":1}}],["更有弹性",{"2":{"13":1}}],["更改元素",{"2":{"5":1}}],["比",{"2":{"13":1}}],["比如数组等",{"2":{"30":1}}],["比如单核",{"2":{"21":1}}],["比如设置定时器",{"2":{"20":1}}],["比如",{"2":{"8":1,"9":1,"12":1}}],["文件的大小和虚拟内存大小相同",{"2":{"30":1}}],["文件等资源",{"2":{"15":1}}],["文件",{"2":{"13":1}}],["文件管理",{"2":{"12":1}}],["参数",{"2":{"13":1}}],["命令的多功能产品",{"2":{"13":1}}],["和同时给运行多个程序造成困难",{"2":{"29":1}}],["和allocation",{"2":{"20":1}}],["和available",{"2":{"20":1}}],["和",{"2":{"13":1}}],["vmstat",{"2":{"13":1}}],["vi",{"2":{"13":1}}],["vim",{"2":{"13":1}}],["网络状态",{"2":{"13":1}}],["监控",{"2":{"13":1}}],["监控全部或指定进程占用系统资源情况",{"2":{"13":1}}],["针对特定进程进行统计",{"2":{"13":1}}],["情况统计",{"2":{"13":1}}],["used",{"2":{"31":2}}],["u",{"2":{"13":1}}],["unix操作系统采用",{"2":{"18":1}}],["unix",{"2":{"12":1}}],["undefined",{"2":{"5":1}}],["线性化申请避免循环",{"2":{"20":1}}],["线性的问题",{"2":{"1":1}}],["线程还能做其他的事情",{"2":{"22":1}}],["线程同步是两个或多个共享关键资源的线程在并发执行过程中避免资源冲突",{"2":{"19":1}}],["线程同步",{"0":{"19":1}}],["线程共享堆",{"2":{"15":1}}],["线程共享进程的地址数据空间",{"2":{"15":1}}],["线程从属于进程",{"2":{"15":1}}],["线程是",{"2":{"15":1}}],["线程等",{"2":{"13":1}}],["任务切换",{"2":{"13":1}}],["如数据泄露",{"2":{"24":1}}],["如此来避免系统存在潜在死锁的风险",{"2":{"20":1}}],["如cpu和主存",{"2":{"20":1}}],["如磁带机",{"2":{"20":1}}],["如下图所示",{"2":{"20":1}}],["如",{"2":{"13":1,"20":1}}],["如果该页不在快表中",{"2":{"28":1}}],["如果该页在快表中",{"2":{"28":1}}],["如果其中一行代码报错",{"2":{"24":1}}],["如果小于",{"2":{"8":1}}],["如果大于",{"2":{"8":1}}],["h",{"2":{"13":1}}],["交换区总量",{"2":{"13":1}}],["总物理内存",{"2":{"13":1}}],["总进程",{"2":{"13":1}}],["统计",{"2":{"13":1}}],["睡眠进程等",{"2":{"13":1}}],["搜索",{"2":{"13":1}}],["终止进程",{"2":{"13":1}}],["显示所有状态",{"2":{"13":1}}],["显示当前所在目录",{"2":{"13":1}}],["动态将需要的部分调入内存",{"2":{"30":1}}],["动态打印文件内容",{"2":{"13":1}}],["动态语言",{"2":{"3":1}}],["用于多进程对共享数据的访问",{"2":{"17":1}}],["用于通知接收进程某个事件已经发生",{"2":{"17":1}}],["用于查看当前正在运行的进程",{"2":{"13":1}}],["用于显示文件后几行内容",{"2":{"13":1}}],["用户cpu占用",{"2":{"13":1}}],["用户程序",{"2":{"12":1}}],["用户态",{"2":{"12":1}}],["zcvf",{"2":{"13":1}}],["表示将申请后的剩余资源先分配给p3",{"2":{"20":1}}],["表示当前分配给进程的资源",{"2":{"20":1}}],["表示进程对资源的需求",{"2":{"20":1}}],["表示强迫进程立即停止",{"2":{"13":1}}],["表示列出文件详情信息",{"2":{"13":1}}],["表示显示所有文件",{"2":{"13":1}}],["表示数组的首地址的寻址公式",{"2":{"5":1}}],["或多个相关事物的发生无需等待其前一事物的完成",{"2":{"23":1}}],["或者尽可能实时",{"2":{"23":1}}],["或者临时资源",{"2":{"20":1}}],["或",{"2":{"13":1}}],["或类型可不同",{"2":{"3":1}}],["编辑器",{"2":{"13":1}}],["创建状态",{"2":{"16":1}}],["创建空文件",{"2":{"13":1}}],["创建目录",{"2":{"13":1}}],["grep",{"2":{"13":2}}],["gt",{"2":{"9":2,"20":6}}],["移除目录",{"2":{"13":1}}],["并以页为单位进行置换",{"2":{"30":1}}],["并发",{"2":{"21":1}}],["并行",{"2":{"21":1}}],["并行与并发",{"0":{"21":1}}],["并建立资源分配表和进程等待表",{"2":{"20":1}}],["并根据可完成进程的分配顺序生成安全序列",{"2":{"20":1}}],["并在资源分配之前预先计算资源分配的安全性",{"2":{"20":1}}],["并由操作系统代为完成系统态的操作",{"2":{"12":1}}],["并且把内存扩展到硬盘空间",{"2":{"30":1}}],["并且不会对外部状态进行修改",{"2":{"1":1}}],["并且对象之间可以建立继承和关联关系",{"2":{"1":1}}],["内外存",{"2":{"30":1}}],["内存一外存",{"2":{"30":1}}],["内存单元真实地址",{"2":{"29":1}}],["内存利用率提高",{"2":{"26":1}}],["内存利用率低下",{"2":{"26":1}}],["内存溢出等问题",{"2":{"24":1}}],["内存",{"2":{"13":1}}],["内存信息",{"2":{"13":1}}],["内存管理机制",{"0":{"26":1}}],["内存管理涉及内存分配",{"2":{"25":1}}],["内存管理",{"0":{"25":1},"1":{"26":1,"27":1,"28":1,"29":1,"30":1,"31":1},"2":{"12":1}}],["内核cpu占用等",{"2":{"13":1}}],["内部的一维数组仍然从索引",{"2":{"5":1}}],["设备",{"2":{"13":1}}],["设备管理",{"2":{"12":1}}],["设备驱动和文件系统",{"2":{"12":1}}],["dstat",{"2":{"13":1}}],["d",{"2":{"13":1}}],["dynamic",{"2":{"12":1}}],["ddl",{"2":{"12":1}}],["synchronous",{"2":{"23":1}}],["shared",{"2":{"12":1}}],["so",{"2":{"12":1}}],["size",{"2":{"5":4}}],["支持按需装载",{"2":{"12":1}}],["waiting",{"2":{"16":1}}],["windows在磁盘上提供了虚拟内存使用的文件",{"2":{"30":1}}],["windows",{"2":{"12":2,"30":3}}],["while",{"2":{"8":1,"9":1}}],["常见操作系统有",{"2":{"12":1}}],["计算机组成原理",{"0":{"11":1}}],["计算机网络",{"0":{"10":1}}],["子数组有序",{"2":{"9":1}}],["上一个元素比当前元素大",{"2":{"9":1}}],["+",{"2":{"9":6,"18":1,"30":1}}],["说明最小在left",{"2":{"9":1}}],["时间局部性",{"2":{"30":1}}],["时间或其他资源",{"2":{"18":1}}],["时间片轮转",{"2":{"18":1}}],["时间",{"2":{"13":1}}],["时间复杂度为",{"2":{"5":1}}],["时间复杂度",{"2":{"5":5}}],["时只能是mid",{"2":{"9":1}}],["lfu",{"2":{"31":1}}],["lru",{"2":{"31":1}}],["l",{"2":{"13":1}}],["ls",{"2":{"13":1}}],["link",{"2":{"12":1}}],["linux",{"0":{"13":1},"2":{"12":2,"30":1}}],["library",{"2":{"12":2}}],["lt",{"2":{"9":4}}],["least",{"2":{"31":2}}],["less",{"2":{"13":1}}],["len",{"2":{"9":6}}],["length",{"2":{"8":4,"9":2}}],["leftnum",{"2":{"9":3}}],["left+1",{"2":{"9":1}}],["left",{"2":{"9":17}}],["let",{"2":{"8":4,"9":3}}],["由操作系统决定",{"2":{"27":1}}],["由一个进程创建的映射一段能被其他多个进程所访问的内存",{"2":{"17":1}}],["由一个或多个确定的元素所构成的整体",{"2":{"3":1}}],["由于一个线程在同一时间只能处理一件事情",{"2":{"21":1}}],["由于",{"2":{"9":1}}],["遍历即可",{"2":{"9":1}}],["首先定义状态和安全状态的概念",{"2":{"20":1}}],["首先运行具有最高优先级的进程",{"2":{"18":1}}],["首先",{"2":{"9":1}}],["是目前最常用的实现虚拟内存的方式",{"2":{"30":1}}],["是用时间",{"2":{"30":1}}],["是指资源是有线性顺序的",{"2":{"20":1}}],["是较好的进程调度算法",{"2":{"18":1}}],["是可以取代",{"2":{"13":1}}],["是内存使用情况统计",{"2":{"13":1}}],["是",{"2":{"9":1,"13":2}}],["是一种元素在内存中连续存储的线性列表数据结构",{"2":{"3":1}}],["4kb",{"2":{"30":1}}],["4",{"2":{"9":2,"29":1}}],["旋转数组的前一部分均大于等于后一部分",{"2":{"9":1}}],["旋转数组的最小数字",{"0":{"9":1}}],["旋转数组由前后两段非递减元素组成",{"2":{"9":1}}],["输出某个特定进程内所有线程的运行情况",{"2":{"13":1}}],["输出旋转数组的最小元素",{"2":{"9":1}}],["输入一个存在重复元素的升序数组的一个旋转",{"2":{"9":1}}],["输入这样的一个二维数组和一个整数",{"2":{"8":1}}],["我们称之为数组的旋转",{"2":{"9":1}}],["else",{"2":{"8":1,"9":2}}],["element",{"2":{"8":6}}],["x26",{"2":{"8":2}}],["x3c",{"2":{"8":3,"9":4}}],["blocking",{"2":{"22":2}}],["break",{"2":{"8":1}}],["boolean",{"2":{"8":2}}],[">=",{"2":{"8":1,"9":1}}],[">",{"2":{"8":2,"9":2}}],["robin",{"2":{"18":1}}],["round",{"2":{"18":1}}],["row",{"2":{"8":6}}],["rr",{"2":{"18":1}}],["running",{"2":{"16":1}}],["recently",{"2":{"31":1}}],["ready",{"2":{"16":1}}],["return",{"2":{"8":6,"9":6}}],["r",{"2":{"13":1}}],["rmdir",{"2":{"13":1}}],["rightnum",{"2":{"9":4}}],["right",{"2":{"9":18}}],["||",{"2":{"8":2}}],["二分查找",{"2":{"9":1}}],["二位数组为空",{"2":{"8":2}}],["二维数组的查找",{"0":{"8":1}}],["二维数组的本质上仍然是一个一维数组",{"2":{"5":1}}],["=right",{"2":{"9":1}}],["===",{"2":{"8":2}}],["=",{"2":{"8":10,"9":18}}],["cache",{"2":{"28":1}}],["cvf",{"2":{"13":1}}],["cur",{"2":{"9":3}}],["concurrency",{"2":{"21":1}}],["const",{"2":{"8":6,"9":8}}],["col",{"2":{"8":6}}],["cpu通知操作系统os将其调入内存的过程称为缺页中断",{"2":{"30":1}}],["cpu计算时间",{"2":{"30":1}}],["cpu中的内存管理单元mmu",{"2":{"29":1}}],["cpu",{"2":{"5":1,"13":5,"15":2,"16":1,"18":1,"21":1,"22":2,"28":1,"29":1}}],["terminated",{"2":{"16":1}}],["tcp",{"2":{"13":1}}],["top",{"2":{"13":2}}],["touch",{"2":{"13":1}}],["tail",{"2":{"13":1}}],["tar",{"2":{"13":2}}],["target",{"2":{"8":6}}],["true",{"2":{"8":2}}],["typescript",{"2":{"8":1,"9":1}}],["type",{"2":{"5":4}}],["暴力解法",{"2":{"8":1,"9":1}}],["求解",{"2":{"8":1}}],["找不到",{"2":{"8":2}}],["超时释放资源",{"2":{"20":1}}],["超时送入就绪队列的队尾",{"2":{"18":1}}],["超过行边界退出",{"2":{"8":1}}],["超过列边界退出",{"2":{"8":1}}],["超出数组长度范围插入",{"2":{"5":1}}],["向上走",{"2":{"8":1}}],["向右上进行遍历",{"2":{"8":1}}],["向右上角进行遍历",{"2":{"8":1}}],["向右走",{"2":{"8":1}}],["向左下角进行遍历",{"2":{"8":1}}],["可能导致数据不一致和死锁等问题",{"2":{"24":1}}],["可能会引起副作用",{"2":{"1":1}}],["可以主动释放它占有的资源",{"2":{"20":1}}],["可以从左下角开始",{"2":{"8":1}}],["可用套接字中的相关函数来完成通信过程",{"2":{"17":1}}],["假如对于整数",{"2":{"8":1}}],["2",{"0":{"9":1},"2":{"9":3,"30":1}}],["23",{"2":{"8":1}}],["21",{"2":{"8":1}}],["5",{"2":{"8":1,"9":2}}],["9",{"2":{"8":1,"13":1}}],["3",{"2":{"8":1,"9":2}}],["7",{"2":{"8":1}}],["从而降低程序的性能和稳定性",{"2":{"24":1}}],["从头执行到尾",{"2":{"24":1}}],["从宏观上观察系统各个进程对cpu的占用情况以及内存使用情况",{"2":{"13":1}}],["从左下角元素出发",{"2":{"8":1}}],["从上到下递增的顺序排序",{"2":{"8":1}}],["从索引",{"2":{"5":1}}],["列出文件列表",{"2":{"13":1}}],["列元素从上到下递增",{"2":{"8":1}}],["列分别按照从左到右",{"2":{"8":1}}],["列表",{"0":{"3":1},"2":{"3":1}}],["每一行",{"2":{"8":1}}],["每个进程分配",{"2":{"18":1}}],["每个进程均有一个时间片",{"2":{"18":1}}],["每个一维数组的长度相同",{"2":{"8":1}}],["每个过程都可以操作共享的数据",{"2":{"1":1}}],["每个对象都可以接收消息",{"2":{"1":1}}],["题目描述",{"2":{"8":1,"9":1}}],["删操作少的场景",{"2":{"6":1}}],["删除指定索引元素",{"2":{"5":1}}],["删除元素",{"2":{"5":1}}],["查看文件",{"2":{"13":1}}],["查找字符串",{"2":{"13":1}}],["查找元素",{"2":{"5":1}}],["查",{"2":{"6":1}}],["改操作多",{"2":{"6":1}}],["因此最小值和最大值在左上角和右下角",{"2":{"8":1}}],["因此",{"2":{"6":1}}],["因为直接暴露物理地址",{"2":{"29":1}}],["因为使用锁目的就是保证资源被互斥访问",{"2":{"20":1}}],["因为",{"2":{"5":1}}],["插入和删除元素",{"2":{"6":1}}],["插入元素",{"2":{"5":1}}],["低效",{"2":{"6":1}}],["的页进行分割",{"2":{"30":1}}],["的方案",{"2":{"30":1}}],["的两级存储器的结构",{"2":{"30":1}}],["的虚拟内存",{"2":{"30":1}}],["的交换空间",{"2":{"30":1}}],["的映射",{"2":{"26":1}}],["的最小单位",{"2":{"15":1}}],["的前两个数旋转到数组末尾得到的旋转数组",{"2":{"9":1}}],["的查找",{"2":{"6":1}}],["的随机访问",{"2":{"6":1}}],["的二维数组寻址公式为",{"2":{"5":1}}],["个一维数组的首元素的地址为",{"2":{"5":1}}],["kb",{"2":{"29":1}}],["kill",{"2":{"13":1}}],["k∗n",{"2":{"5":1}}],["k",{"2":{"5":2}}],["j++",{"2":{"8":2}}],["j",{"2":{"5":1,"8":8}}],["javascript",{"2":{"5":1}}],["mysql",{"2":{"28":1}}],["more",{"2":{"13":1}}],["mkdir",{"2":{"13":1}}],["macos",{"2":{"12":1}}],["math",{"2":{"9":1}}],["matrix",{"2":{"8":8}}],["minarray2",{"2":{"9":1}}],["minarray1",{"2":{"9":1}}],["midnum",{"2":{"9":3}}],["mid",{"2":{"9":12}}],["m",{"2":{"5":1}}],["后续元素依次向前填补",{"2":{"5":1}}],["尾部删除",{"2":{"5":1}}],["尾部插入",{"2":{"5":1}}],["对于没有使用的2级页表就可以不需要存储再内存中了",{"2":{"28":1}}],["对已获得的资源保持不放",{"2":{"20":1}}],["对超出部分会自动设置为",{"2":{"5":1}}],["对象具有状态和行为",{"2":{"1":1}}],["将逻辑地址映射为物理地址",{"2":{"29":1}}],["将1级页表划分成若干个2级页表",{"2":{"28":1}}],["将页细化成定义了逻辑信息的具有实际意义的段",{"2":{"26":1}}],["将就绪队列再划",{"2":{"18":1}}],["将元素插入索引对应的空出空间",{"2":{"5":1}}],["将尾部到索引下标之间的元素依次后移",{"2":{"5":1}}],["将函数作为程序的基本构建块",{"2":{"1":1}}],["non",{"2":{"22":1}}],["new",{"2":{"16":1}}],["netstat",{"2":{"13":2}}],["nan",{"2":{"9":2}}],["numbers",{"2":{"9":11}}],["number",{"2":{"8":4,"9":4}}],["n",{"2":{"5":4,"6":1}}],["处开始",{"2":{"5":1}}],["处理数据并和其他对象交互",{"2":{"1":1}}],["这样可加速查找并提高指令执行速度",{"2":{"28":1}}],["这会增加代码的复杂度和开销",{"2":{"24":1}}],["这会使系统性能降低",{"2":{"20":1}}],["这些永远在互相等待的进程称为死锁进程",{"2":{"20":1}}],["这些过程按照特定的顺序执行",{"2":{"1":1}}],["这对于",{"2":{"5":1}}],["访问数组元素少一次减法运算",{"2":{"5":1}}],["访问数组中的元素",{"2":{"4":1}}],["∗data",{"2":{"5":3}}],["in",{"2":{"30":1,"31":1}}],["ipc",{"0":{"17":1}}],["ip",{"2":{"13":1}}],["io",{"2":{"13":2,"16":1}}],["iostat",{"2":{"13":1}}],["ios",{"2":{"12":1}}],["id",{"2":{"13":1}}],["i++",{"2":{"8":1,"9":1}}],["ifstat",{"2":{"13":1}}],["if",{"2":{"8":6,"9":6}}],["i∗n+j",{"2":{"5":1}}],["i−1",{"2":{"5":1}}],["i",{"2":{"5":3,"8":9,"9":4,"12":1}}],["asynchronous",{"2":{"23":1}}],["awk",{"2":{"13":1}}],["aux",{"2":{"13":1}}],["android",{"2":{"12":1}}],["arr",{"2":{"8":2}}],["arr=",{"2":{"8":1}}],["array",{"2":{"3":1}}],["address+",{"2":{"5":3}}],["address+i∗data",{"2":{"5":1}}],["address=base",{"2":{"5":4}}],["a",{"2":{"5":5,"13":1}}],["开始的计算机寻址公式",{"2":{"5":1}}],["开始",{"0":{"5":1},"2":{"5":2}}],["0",{"0":{"5":1},"2":{"5":4,"8":6,"9":2}}],["1级页表中存储的是到2级页表的映射",{"2":{"28":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940414243444546",{"2":{"9":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940",{"2":{"8":1}}],["17",{"2":{"8":1}}],["11",{"2":{"8":1}}],["15",{"2":{"8":2}}],["19",{"2":{"8":1}}],["13",{"2":{"8":1}}],["1",{"0":{"8":1},"2":{"4":1,"5":5,"6":1,"8":2,"9":13,"30":1}}],["下标从",{"2":{"5":1}}],["下标",{"2":{"4":1,"5":1}}],["索引",{"2":{"4":1}}],["链表等",{"2":{"3":1}}],["队列",{"2":{"3":1}}],["栈",{"2":{"3":1}}],["排列而成的数据项的集合",{"2":{"3":1}}],["确定",{"2":{"3":1}}],["集合",{"0":{"3":1},"2":{"3":1}}],["数组的规律是行元素从左到右递增",{"2":{"8":1}}],["数组的优劣",{"0":{"6":1}}],["数组所适合的是读",{"2":{"6":1}}],["数组基本操作",{"0":{"4":1},"1":{"5":1}}],["数组",{"0":{"2":1,"3":1},"1":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1},"2":{"3":1}}],["数据的连续存储",{"2":{"30":1}}],["数据或代码页会根据需要在该物理内存与磁盘之间移动",{"2":{"29":1}}],["数据段",{"2":{"27":1}}],["数据处理工具",{"2":{"13":1}}],["数据转换等问题",{"2":{"1":1}}],["数据结构与算法",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1}}],["frequently",{"2":{"31":1}}],["first",{"2":{"31":2}}],["fifo",{"2":{"31":1}}],["file",{"2":{"30":1}}],["findnumberin2darray2",{"2":{"8":1}}],["findnumberin2darray1",{"2":{"8":1}}],["f",{"2":{"13":1}}],["floor",{"2":{"9":1}}],["fork",{"2":{"17":1}}],["for",{"2":{"8":2,"9":1}}],["fop",{"2":{"1":1}}],["false",{"2":{"8":4}}],["functional",{"2":{"1":1}}],["function",{"2":{"1":1,"8":2,"9":2}}],["通常大小是内存的",{"2":{"30":1}}],["通常大小为",{"2":{"29":1}}],["通常适用于处理数学运算",{"2":{"1":1}}],["通常适用于处理简单",{"2":{"1":1}}],["通过通知操作的方式来保持多线程同步",{"2":{"19":1}}],["通过控制同一时刻多个线程访问同一资源最大线程数量",{"2":{"19":1}}],["通过互斥对象具有唯一性",{"2":{"19":1}}],["通过父进程",{"2":{"17":1}}],["通过系统调用",{"2":{"12":1}}],["通过数组的索引",{"2":{"5":1}}],["通过数组的长度计算出即将插入元素的内存地址",{"2":{"5":1}}],["通过数组的",{"2":{"4":1}}],["通过组合和转换函数实现复杂的计算过程",{"2":{"1":1}}],["强调函数的使用和复用",{"2":{"1":1}}],["pt页面置换算法",{"2":{"31":1}}],["page",{"2":{"30":3}}],["parallelism",{"2":{"21":1}}],["p3",{"2":{"20":1}}],["pn正在等待已被p0占用的资源",{"2":{"20":1}}],["pn",{"2":{"20":1}}],["p2",{"2":{"20":2}}],["p1正在等待p2占用的资源",{"2":{"20":1}}],["p1",{"2":{"20":3}}],["p0",{"2":{"20":2}}],["p",{"2":{"13":2}}],["ps",{"2":{"13":1}}],["pidstat",{"2":{"13":1}}],["pid",{"2":{"13":3}}],["pwd",{"2":{"13":1}}],["pre",{"2":{"9":2}}],["procedural",{"2":{"1":1}}],["procedure",{"2":{"1":1}}],["programming",{"2":{"1":3}}],["pop",{"2":{"1":1}}],["例如修改全局变量",{"2":{"1":1}}],["函数是可变的",{"2":{"1":1}}],["在分页式中",{"2":{"30":1}}],["在不考虑程序构造的情况下",{"2":{"30":1}}],["在页式管理基础上增加请求调页功能和页面置换功能",{"2":{"30":1}}],["在某个时刻只有一件事情在执行",{"2":{"21":1}}],["在同一时间内多件事情能被交替地处理",{"2":{"21":1}}],["在同一时间内有几件事情并行在处理",{"2":{"21":1}}],["在发生死锁时",{"2":{"20":1}}],["在",{"2":{"12":2}}],["在一个二维数组中",{"2":{"8":1}}],["在pop中",{"2":{"1":1}}],["在oop",{"2":{"1":1}}],["中的p0正在等待一个p1占用的资源",{"2":{"20":1}}],["中则被称为动态链接库",{"2":{"12":1}}],["中叫做共享库",{"2":{"12":1}}],["中间的数等于右边",{"2":{"9":1}}],["中间数小于右边数",{"2":{"9":1}}],["中间数大于右边数",{"2":{"9":1}}],["中间元素的下标",{"2":{"9":1}}],["中",{"2":{"1":1}}],["out",{"2":{"30":1,"31":1}}],["o",{"2":{"5":6,"6":2,"12":1}}],["oop通常适用于处理与现实世界有关的问题",{"2":{"1":1}}],["oriented",{"2":{"1":6}}],["object",{"2":{"1":2}}],["面向函数",{"0":{"1":1},"2":{"1":1}}],["面向过程",{"0":{"1":1},"2":{"1":1}}],["面向对象",{"0":{"1":1},"2":{"1":1}}]],"serializationVersion":2}';export{t as default};
