import{_ as e,c as t,o as a,P as r}from"./chunks/framework.DtSlGNS9.js";const m=JSON.parse('{"title":"CAP4","description":"","frontmatter":{},"headers":[],"relativePath":"projects/low-code-platform/seeyon.md","filePath":"projects/low-code-platform/seeyon.md","lastUpdated":1757124188000}'),l={name:"projects/low-code-platform/seeyon.md"};function s(n,o,i,c,p,d){return a(),t("div",null,[...o[0]||(o[0]=[r('<h1 id="cap4" tabindex="-1">CAP4 <a class="header-anchor" href="#cap4" aria-label="Permalink to &quot;CAP4&quot;">​</a></h1><h2 id="树形分组在海量数据渲染时的优化" tabindex="-1">树形分组在海量数据渲染时的优化？ <a class="header-anchor" href="#树形分组在海量数据渲染时的优化" aria-label="Permalink to &quot;树形分组在海量数据渲染时的优化？&quot;">​</a></h2><p>由于在海量数据场景下，比如树形分组的内容很多时b，那么树的渲染耗时会很长，页面会出现长时间卡顿，甚至在IE浏览器上页面会出现卡死的情况。这时就考虑使用虚拟树的解决方案；当然也可以使用异步加载树节点的方式。虚拟树就是只渲染可视区域的数据的树。虚拟树和虚拟列表本质是一样的，只不过前者的原始数据的结构是树，而后者的原始数据的结构是列表，以及最后的表现形式不一样。虚拟树可以通过只渲染海量数据中的那部分在可视区域的数据来大幅缩短渲染耗时。实现虚拟树的思路是，先把实现虚拟树转化成实现虚拟列表，然后在展示的时候把列表装饰得像一棵树。具体分为以下四个步骤：</p><ol><li><strong>把树结构的原始数据拍平</strong>；拍平的关键是按深度优先把树遍历一遍，拍平后，全部的节点都成为了最外层的数组的项（之前只有一级节点是最外层的数组的项）。这时，如果我们把这个数组遍历一遍并绘制在页面上（即列表渲染），得到的节点的顺序和把原始数据渲染成树时的节点的顺序是一致的，只不过前者没有缩进，看起来是个列表，而后者有缩进，看起来是个树。</li><li><strong>计算哪些数据在可视区域</strong>；可视区域的高度是固定的，假设树的每一个节点的高度也是固定的，那么，根据这两个数据，就可以计算出可视区域内能展示多少个节点。然后，如果我们再知道可视区域里的第一个节点在数组中的索引，就可以知道到底是哪些数据在可视区域了。而可视区域里的第一个节点的索引，可以通过当前的滚动距离除以节点高度获得。</li><li><strong>模拟滚动</strong>；最外层的元素是设置了 overflow: scroll 的高度固定的可视区域滚动容器 <ol><li>滚动容器的第一个子元素是占位元素，是模拟滚动的关键，高度是树的总高度，由节点高度乘所有节点数量得到。这个占位元素用树的真实高度撑开了滚动容器，因此滚动容器就可以滚动了。</li><li>滚动容器的第二个子元素是<strong>渲染元素</strong>，负责渲染计算出来的在可视区域的数据。它是相对滚动容器（最外层的元素）绝对定位的，初始位置是在滚动容器的顶部。随着容器的滚动，除了更新可视区域的数据，同时，更新渲染元素的垂直偏移量，即top 值，使得应该展示在可视区域的数据在可视区域内。</li></ol></li><li><strong>把列表装饰成树</strong>；在递归拍平树结构的过程中给不同的层级元素添加level，然后就可以在通过编写CSS将列表根据树结构进行层级缩进。</li></ol>',4)])])}const h=e(l,[["render",s]]);export{m as __pageData,h as default};
