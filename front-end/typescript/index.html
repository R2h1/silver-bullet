<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Typescript | Silver Bullet</title>
    <meta name="description" content="前端修炼手册：也许，求知的道路上，未必就没有银色子弹">
    <meta name="generator" content="VitePress v1.0.0-rc.31">
    <link rel="preload stylesheet" href="/silver-bullet/assets/style.DkyWX4MS.css" as="style">
    
    <script type="module" src="/silver-bullet/assets/app.CkGK2i-Q.js"></script>
    <link rel="preload" href="/silver-bullet/assets/inter-roman-latin.Bu8hRsVA.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/silver-bullet/assets/chunks/framework.DtSlGNS9.js">
    <link rel="modulepreload" href="/silver-bullet/assets/chunks/theme.Dzcf_IDk.js">
    <link rel="modulepreload" href="/silver-bullet/assets/chunks/index.S8oVTZHA.js">
    <link rel="modulepreload" href="/silver-bullet/assets/front-end_typescript_index.md.CPqpwsTo.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-0afca6d4><!--[--><!--]--><!--[--><span tabindex="-1" data-v-94102d6f></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-94102d6f> Skip to content </a><!--]--><!----><header class="VPNav" data-v-0afca6d4 data-v-a40b6225><div class="VPNavBar" data-v-a40b6225 data-v-d14ba81c><div class="container" data-v-d14ba81c><div class="title" data-v-d14ba81c><div class="VPNavBarTitle has-sidebar" data-v-d14ba81c data-v-c537b66e><a class="title" href="/silver-bullet/" data-v-c537b66e><!--[--><!--]--><!--[--><img class="VPImage logo" src="/silver-bullet/logo.png" alt data-v-92f692bd><!--]--><!--[-->Silver Bullet<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-d14ba81c><div class="curtain" data-v-d14ba81c></div><div class="content-body" data-v-d14ba81c><!--[--><!--]--><div class="VPNavBarSearch search" data-v-d14ba81c><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><svg class="DocSearch-Search-Icon" width="20" height="20" viewBox="0 0 20 20" aria-label="search icon"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-d14ba81c data-v-43a07cc0><span id="main-nav-aria-label" class="visually-hidden" data-v-43a07cc0>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/silver-bullet/basics/data-structures-algorithms/index" tabindex="0" data-v-43a07cc0 data-v-e4a15b18><!--[--><span data-v-e4a15b18>计算机基础</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/silver-bullet/front-end/basics/index" tabindex="0" data-v-43a07cc0 data-v-e4a15b18><!--[--><span data-v-e4a15b18>前端基础</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/silver-bullet/front-end/engineering/index" tabindex="0" data-v-43a07cc0 data-v-e4a15b18><!--[--><span data-v-e4a15b18>前端工程化</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/silver-bullet/tools/index" tabindex="0" data-v-43a07cc0 data-v-e4a15b18><!--[--><span data-v-e4a15b18>工具合集</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-d14ba81c data-v-e7d5c273><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-e7d5c273 data-v-cd46cef9 data-v-cf5613ad><span class="check" data-v-cf5613ad><span class="icon" data-v-cf5613ad><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-cd46cef9><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-cd46cef9><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-d14ba81c data-v-6e4e643b data-v-0948c7c5><!--[--><a class="VPSocialLink no-icon" href="https://github.com/R2h1/silver-bullet" aria-label="github" target="_blank" rel="noopener" data-v-0948c7c5 data-v-441f1bd7><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-d14ba81c data-v-8fed258e data-v-45c72923><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-45c72923><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-45c72923><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-45c72923><div class="VPMenu" data-v-45c72923 data-v-454aea69><!----><!--[--><!--[--><!----><div class="group" data-v-8fed258e><div class="item appearance" data-v-8fed258e><p class="label" data-v-8fed258e>Appearance</p><div class="appearance-action" data-v-8fed258e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-8fed258e data-v-cd46cef9 data-v-cf5613ad><span class="check" data-v-cf5613ad><span class="icon" data-v-cf5613ad><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-cd46cef9><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-cd46cef9><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-8fed258e><div class="item social-links" data-v-8fed258e><div class="VPSocialLinks social-links-list" data-v-8fed258e data-v-0948c7c5><!--[--><a class="VPSocialLink no-icon" href="https://github.com/R2h1/silver-bullet" aria-label="github" target="_blank" rel="noopener" data-v-0948c7c5 data-v-441f1bd7><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-d14ba81c data-v-915dc1c6><span class="container" data-v-915dc1c6><span class="top" data-v-915dc1c6></span><span class="middle" data-v-915dc1c6></span><span class="bottom" data-v-915dc1c6></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav reached-top" data-v-0afca6d4 data-v-9194493c><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-9194493c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-9194493c><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-9194493c>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-9194493c data-v-567c7d0a><button data-v-567c7d0a>Return to top</button><!----></div></div><aside class="VPSidebar" data-v-0afca6d4 data-v-68047173><div class="curtain" data-v-68047173></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-68047173><span class="visually-hidden" id="sidebar-aria-label" data-v-68047173> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-68047173><section class="VPSidebarItem level-0 collapsible" data-v-68047173 data-v-8fac9f6b><div class="item" role="button" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><h2 class="text" data-v-8fac9f6b>计算机基础</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-8fac9f6b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-8fac9f6b><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-8fac9f6b><!--[--><section class="VPSidebarItem level-1 collapsible collapsed is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/data-structures-algorithms/index" data-v-8fac9f6b><!--[--><h3 class="text" data-v-8fac9f6b>数据结构与算法</h3><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-8fac9f6b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-8fac9f6b><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/data-structures-algorithms/array-string" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>数组和字符串</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/data-structures-algorithms/linkList" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>链表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/data-structures-algorithms/stack-queue" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>栈和队列</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/data-structures-algorithms/tree-graph" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>树和图</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/data-structures-algorithms/heap-hash" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>堆和散列表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/data-structures-algorithms/search-sort" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>查找和排序</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/data-structures-algorithms/dp-math" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>动态规划和数学</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/internet" data-v-8fac9f6b><!--[--><h3 class="text" data-v-8fac9f6b>网络</h3><!--]--></a><!----></div><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/http" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>HTTP</p><!--]--></a><!----></div><!----></div><!--]--></div></section><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/os" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>操作系统</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/basics/make-up-principle" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>组成原理</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-68047173><section class="VPSidebarItem level-0 is-link" data-v-68047173 data-v-8fac9f6b><div class="item" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/index" data-v-8fac9f6b><!--[--><h2 class="text" data-v-8fac9f6b>前端基础</h2><!--]--></a><!----></div><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/html/index" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>html</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1 collapsible collapsed is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/css/index" data-v-8fac9f6b><!--[--><h3 class="text" data-v-8fac9f6b>css</h3><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-8fac9f6b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-8fac9f6b><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/css/layout" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>布局</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/css/geometric-draw" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>几何图形绘制</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible collapsed is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/javascript/index" data-v-8fac9f6b><!--[--><h3 class="text" data-v-8fac9f6b>javascript</h3><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-8fac9f6b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-8fac9f6b><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/javascript/data-type" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>数据类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/javascript/function" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>函数相关</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/javascript/operator" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>运算符相关</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/javascript/web-api" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>Web API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/javascript/module" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>模块化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/basics/javascript/handwrite" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>手写实现相关</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><div class="group" data-v-68047173><div class="VPSidebarItem level-0 is-link" data-v-68047173 data-v-8fac9f6b><div class="item" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/typescript/index" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>typescript</p><!--]--></a><!----></div><!----></div></div><div class="group" data-v-68047173><section class="VPSidebarItem level-0" data-v-68047173 data-v-8fac9f6b><div class="item" role="button" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><h2 class="text" data-v-8fac9f6b>设计模式</h2><!----></div><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/design-patterns" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>前端常用设计模式</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-68047173><section class="VPSidebarItem level-0 collapsible collapsed is-link" data-v-68047173 data-v-8fac9f6b><div class="item" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/frame/index" data-v-8fac9f6b><!--[--><h2 class="text" data-v-8fac9f6b>前端框架</h2><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-8fac9f6b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-8fac9f6b><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/frame/jquery/index" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>jquery</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/frame/vue/index" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>vue</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/frame/react/index" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>react</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-68047173><div class="VPSidebarItem level-0 is-link" data-v-68047173 data-v-8fac9f6b><div class="item" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/browser" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>浏览器</p><!--]--></a><!----></div><!----></div></div><div class="group" data-v-68047173><section class="VPSidebarItem level-0" data-v-68047173 data-v-8fac9f6b><!----><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/lottie" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>lottie</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/performance-optimization" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>前端性能优化</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-68047173><div class="VPSidebarItem level-0 is-link" data-v-68047173 data-v-8fac9f6b><div class="item" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/micro-front-end" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>微前端</p><!--]--></a><!----></div><!----></div></div><div class="group" data-v-68047173><section class="VPSidebarItem level-0" data-v-68047173 data-v-8fac9f6b><div class="item" role="button" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><h2 class="text" data-v-8fac9f6b>混合开发</h2><!----></div><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/hybrid" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>跨平台</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-68047173><section class="VPSidebarItem level-0" data-v-68047173 data-v-8fac9f6b><div class="item" role="button" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><h2 class="text" data-v-8fac9f6b>前端数据治理与异常监控</h2><!----></div><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/data-govern-exception-monitor" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>前端数据治理与异常监控</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-68047173><section class="VPSidebarItem level-0 collapsible collapsed is-link" data-v-68047173 data-v-8fac9f6b><div class="item" tabindex="0" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/engineering/index" data-v-8fac9f6b><!--[--><h2 class="text" data-v-8fac9f6b>前端工程化</h2><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-8fac9f6b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-8fac9f6b><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/engineering/git" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>git</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/engineering/webpack" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>webpack</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/engineering/babel" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>babel</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/engineering/eslint" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>eslint</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/engineering/esbuild" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>esbuild</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/engineering/pnpm" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>pnpm</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/engineering/npm" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>npm</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/engineering/vite" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>vite</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-68047173><section class="VPSidebarItem level-0" data-v-68047173 data-v-8fac9f6b><!----><div class="items" data-v-8fac9f6b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8fac9f6b data-v-8fac9f6b><div class="item" data-v-8fac9f6b><div class="indicator" data-v-8fac9f6b></div><a class="VPLink link link" href="/silver-bullet/front-end/browser-extension" data-v-8fac9f6b><!--[--><p class="text" data-v-8fac9f6b>扩展开发</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-0afca6d4 data-v-8a9b403d><div class="VPDoc has-sidebar has-aside" data-v-8a9b403d data-v-7dc5f967><!--[--><!--]--><div class="container" data-v-7dc5f967><div class="aside" data-v-7dc5f967><div class="aside-curtain" data-v-7dc5f967></div><div class="aside-container" data-v-7dc5f967><div class="aside-content" data-v-7dc5f967><div class="VPDocAside" data-v-7dc5f967 data-v-3a8b9ff1><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-3a8b9ff1 data-v-2c5e3049><div class="content" data-v-2c5e3049><div class="outline-marker" data-v-2c5e3049></div><div class="outline-title" role="heading" aria-level="2" data-v-2c5e3049>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-2c5e3049><span class="visually-hidden" id="doc-outline-aria-label" data-v-2c5e3049> Table of Contents for current page </span><ul class="root" data-v-2c5e3049 data-v-ce2dfa66><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3a8b9ff1></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-7dc5f967><div class="content-container" data-v-7dc5f967><!--[--><!--]--><!----><main class="main" data-v-7dc5f967><div style="position:relative;" class="vp-doc _silver-bullet_front-end_typescript_" data-v-7dc5f967><div><h1 id="typescript" tabindex="-1">Typescript <a class="header-anchor" href="#typescript" aria-label="Permalink to &quot;Typescript&quot;">​</a></h1><p>Typescript是添加了类型系统的JavaScript，属于弱类型（即允许隐式类型转换）、静态类型语言，适应于任何规模的项目，支持 ES6，由微软开发并开源。Typescript增加的功能包括：类型批注和编译时类型检查、类型推断、类型擦除、接口、枚举、Mixin、泛型编程、名字空间、元组、Await。TypeScript 区分大小写。</p><p>TypeScript 和 JavaScript 一样没有整数类型；</p><p>TypeScript 继承关键字为extends，允许接口继承多个接口；</p><p>因此，现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。</p><h2 id="声明空间-编译上下文" tabindex="-1">声明空间/编译上下文 <a class="header-anchor" href="#声明空间-编译上下文" aria-label="Permalink to &quot;声明空间/编译上下文&quot;">​</a></h2><p>在 TypeScript 里存在两种声明空间：<strong>类型声明空间</strong>与<strong>变量声明空间</strong>。</p><ol><li><strong>类型声明空间包含用来当做类型注解的内容</strong>。注意，不能够把interface、type等声明作为一个变量来使用，因为它没有定义在变量声明空间中。类型注解支持使用内联语法注解任何内容，即 :<strong>{ /*Structure*/ }</strong>。</li><li><strong>变量声明空间包含可用作变量的内容</strong>，注意，用 var/let/class 声明的变量，也只能在变量声明空间使用，不能用作类型注解。但构造函数或 Class类名提供了一个类型到类型声明空间，此外它同样提供了一个同名变量到变量声明空间。</li></ol><p><strong>编译上下文</strong>可以用它来给文件分组，告诉 TypeScript 哪些文件是有效的，哪些是无效的，此外还包含有正在被使用的编译选项的信息。比较好的方式是使用 tsconfig.json 文件（在项目的根目录下创建一个包含空{}的tsconfig.json文件，TypeScript 将会把此目录和子目录下的所有.ts文件作为编译上下文的一部分，它还会包含一部分默认的编译选项）。编译选项通过compilerOptions 来定制。</p><p>好的 IDE 支持对 TypeScript 的即时编译。但是，如果想在使用 tsconfig.json 时从命令行手动运行 TypeScript 编译器，可以通过以下方式：</p><ol><li>运行 tsc，它会在当前目录或者是父级目录寻找 tsconfig.json 文件。</li><li>运行 tsc -p ./path-to-project-directory 。当然，这个路径可以是绝对路径，也可以是相对于当前目录的相对路径。</li><li>甚至可以使用 tsc -w 来启用 TypeScript 编译器的观测模式，在检测到文件改动之后，它将重新编译。</li></ol><p>也可以通过和 compilerOptions 同级的 files 选项或 include 和 exclude 选项，显式指定需要编译的文件：</p><ol><li>files 选项指定一个允许包括在程序中的文件数组。当找不到其中任何文件发生错误。不支持通配符匹配，适用于少量枚举需编译且不依赖全局引用很多文件，否则用include</li><li>include 同files, 但支持三种通配符来匹配多个文件（exclude选项也支持），如果通配符中不包含文件扩展名，则仅包含具有受支持扩展名的文件（默认是文件后缀名为.ts/.ts/.d.ts + [.js/.jsx](若allowJs: true)）： <ol><li><ul><li>匹配零个或多个字符（不包括目录分隔符）；</li></ul></li><li>？匹配任何一个字符（不包括目录分隔符）；</li><li>**/ 匹配嵌套到任何级别的任何目录。</li></ol></li><li>exclude 指定编译过程include选项配置的文件中需要忽略的文件列表，不影响文件实际的import types reference files ，默认值是 [&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;, outDir]。</li><li>extends 选项指定当前配置文件要继承的配置文件，是一个路径字符串，加载顺序 ./config/base.json(extends) -&gt; tsconfig.json(当前)，适用于控制某一配置文件的作用域；</li></ol><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">{</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">  &quot;compilerOptions&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    /* 基本选项 */</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;target&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;es5&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                       </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 指定 ECMAScript 目标版本: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES6&#39;/&#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;, or &#39;ESNEXT&#39;</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;module&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;commonjs&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                  </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 指定使用模块: &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39; or &#39;es2015&#39;</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;lib&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: [],                             </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 指定要包含在编译中的库文件</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;allowJs&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                       </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 允许编译 javascript 文件</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;checkJs&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                       </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 报告 javascript 文件中的错误</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;jsx&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;preserve&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                     </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 指定 jsx 代码的生成: &#39;preserve&#39;, &#39;react-native&#39;, or &#39;react&#39;</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;declaration&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                   </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 生成相应的 &#39;.d.ts&#39; 文件</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;sourceMap&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                     </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 生成相应的 &#39;.map&#39; 文件</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;outFile&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;./&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                       </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 将输出文件合并为一个文件</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;outDir&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;./&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                        </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 指定输出目录</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;rootDir&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;./&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                       </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 用来控制输出目录结构 --outDir.</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;removeComments&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 删除编译后的所有的注释</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;noEmit&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                        </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 不生成输出文件</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;importHelpers&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                 </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 从 tslib 导入辅助工具函数</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;isolatedModules&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,               </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 将每个文件作为单独的模块 （与 &#39;ts.transpileModule&#39; 类似）.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    /* 严格的类型检查选项 */</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;strict&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                        </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 启用所有严格类型检查选项</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;noImplicitAny&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                 </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 在表达式和声明上有隐含的 any类型时报错</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;strictNullChecks&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,              </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 启用严格的 null 检查</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;noImplicitThis&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;alwaysStrict&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                  </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 以严格模式检查每个模块，并在每个文件里加入 &#39;use strict&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    /* 额外的检查 */</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;noUnusedLocals&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 有未使用的变量时，抛出错误</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;noUnusedParameters&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,            </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 有未使用的参数时，抛出错误</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;noImplicitReturns&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,             </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;noFallthroughCasesInSwitch&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,    </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    /* 模块解析选项 */</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;moduleResolution&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;node&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,            </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 选择模块解析策略： &#39;node&#39; (Node.js) or &#39;classic&#39; (TypeScript pre-1.6)</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;baseUrl&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;./&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                       </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 用于解析非相对模块名称的基目录</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;paths&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: {},                           </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 模块名到基于 baseUrl 的路径映射的列表</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;rootDirs&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: [],                        </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;typeRoots&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: [],                       </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 包含类型声明的文件列表</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;types&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: [],                           </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 需要包含的类型声明文件名列表</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;allowSyntheticDefaultImports&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,  </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 允许从没有设置默认导出的模块中默认导入。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    /* Source Map Options */</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;sourceRoot&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;./&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                    </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;mapRoot&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;./&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                       </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;inlineSourceMap&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,               </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 生成单个 sourcemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;inlineSources&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,                 </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    /* 其他选项 */</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;experimentalDecorators&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,        </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 启用装饰器</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;emitDecoratorMetadata&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,          </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 为装饰器提供元数据的支持</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    /*</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">      esModuleInterop 选项默认值为 false。</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">      对于没有默认导出的模块（比如是使用 commonjs 且非 typescript 编写的模块），只能使用命名/命名空间导入，</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">      除非在 tsconfig.json 中显式开启 esModuleInterop 选项（TypeScript 将 CommonJS/AMD/UMD 模块视为类似于 ES6 模块），否则会报错。</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    */</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;esModuleInterop&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">false</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  }</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br></div></div><h2 id="命名空间-模块-动态导入表达式-lib-d-ts" tabindex="-1">命名空间/模块/动态导入表达式/lib.d.ts <a class="header-anchor" href="#命名空间-模块-动态导入表达式-lib-d-ts" aria-label="Permalink to &quot;命名空间/模块/动态导入表达式/lib.d.ts&quot;">​</a></h2><h3 id="命名空间" tabindex="-1">命名空间 <a class="header-anchor" href="#命名空间" aria-label="Permalink to &quot;命名空间&quot;">​</a></h3><p>namespace 是 TypeScript 早期时为了解决模块化而创造的关键字，中文称为命名空间。namespace 关键字编译后的 JavaScript 代码与传入待修改参数对象的立即调用函数表达式一样，注意，命名空间是支持嵌套的。对于大多数项目，建议使用外部模块和命名空间，来快速演示和移植旧的 JavaScript 代码。</p><h3 id="模块" tabindex="-1">模块 <a class="header-anchor" href="#模块" aria-label="Permalink to &quot;模块&quot;">​</a></h3><p><strong>全局模块</strong>：在默认情况下，在一个新的 TypeScript 文件中写下代码时，它处于全局命名空间中。如果在相同的项目里创建了一个新的文件，TypeScript 类型系统将会允许使用全局命名空间中的变量。显然，使用全局变量空间是危险的，因为它会与当前文件内的代码命名冲突。然而如果团队里有 TypeScript 初学者，可以自定义一个 global.d.ts 文件（global.d.ts 是一种扩充 lib.d.ts 很好的方式），用来将一些接口或者类型放入全局命名空间里，这些定义的接口和类型能在所有 TypeScript 代码里使用。</p><p><strong>文件模块</strong>：文件模块也被称为外部模块。如果在TypeScript 文件的根级别位置含有 import 或者 export，那么它会在这个文件中创建一个本地的作用域。文件内的代码不再处于全局命名空间中。在当前文件里使用 import 时，它不仅允许使用从其他文件导入的内容，还会将当前文件也标记为一个文件模块，当前文件内定义的声明也不会“污染”全局命名空间。<strong>可以根据不同的 module 选项来把 TypeScript 编译成不同的 JavaScript 模块类型，使用 module: commonjs 选项（tsconfig.json中）来替代以下模式是个好主意</strong>：</p><ol><li>AMD：不要使用它，它仅能在浏览器工作；</li><li>SystemJS：这是一个好的实验，已经被 ES 模块替代；</li><li>ES 模块：它并没有准备好。编译结果js文件中除了没有类型以外完全一样。</li></ol><p>放弃使用 import/require 语法即 import foo = require(&#39;foo&#39;) 写法，推荐使用 ES 模块语法书写TypeScript模块。即使用 module: commonjs 选项的同时，使用 ES 模块语法导入、导出、编写模块。</p><p>模块路径：如果需要使用编译选项 moduleResolution: node，应该将此选项放入tsconfig.json中，但如果使用了编译选项 module: commonjs 选项， moduleResolution: node 将会默认开启。存在两种截然不同的模块，它们的主要区别在于系统如何解析模块：</p><ol><li>相对模块路径（路径以 . 开头，例如：./someFile 或者 ../../someFolder/someFile 等）： <ol><li>如果当前文件中含有相对路径导入./someFile，那么someFile文件必须与当前文件存在于相同的文件夹下；</li><li>如果当前文件中含有相对路径导入../someFile，那么someFile文件所存在的地方必须是当前文件的上一级目录；</li><li>如果当前文件中含有../someFolder/someFile，那么someFile文件所在的文件夹 someFolder 必须与someFile文件所在文件夹在相同的目录下。</li></ol></li><li>动态查找模块（模块解析将会模仿 Node 模块解析策略，如：core-js，typestyle，react 或者甚至是 react/core 等）： <ol><li>当你使用 import Some from &#39;some&#39;，将会按如下顺序查找模块： <ol><li>./node_modules/some；</li><li>../node_modules/some；</li><li>../../node_modules/some；</li><li>直到系统的根目录。</li></ol></li><li>当你使用 import Some from &#39;something/some&#39;，将会按照如下顺序查找内容： <ol><li>./node_modules/something/some；</li><li>../node_modules/something/some；</li><li>../../node_modules/something/some；</li><li>直到系统的根目录。</li></ol></li></ol></li></ol><p>TypeScript 对查找到some文件或文件夹对应的位置（.ts/.d.ts/.js）即 place 将会检查以下内容：</p><ol><li>如果 place表示一个文件，则查找结束；</li><li>否则，如果place是一个文件夹且存在一个文件some/index.ts，则查找结束；</li><li>否则，如果place是一个文件夹且some/package.json 文件中的types指定的文件存在，则查找结束；</li><li>否则，如果place是一个文件夹且package.json 文件中的main指定的文件存在，则查找结束。</li></ol><p>项目中可以通过 declare module &#39;some&#39; 声明一个全局模块的方式，来解决查找模块路径的问题。 而且，定义declare module &quot;some-library-you-dont-care-to-get-defs-for&quot;能使得快速开始从JS迁移到TS。</p><p>语法import some = require(‘some’) 只是导入 foo 模块的所有类型信息以及确定some模块运行时的依赖关系。如果没有把导入的名称some当做变量声明空间来用，在编译成 JavaScript 时，导入的模块some将会被完全移除。使用场景有：</p><ol><li><strong>懒加载</strong>： <ol><li>在 webApp 中在特定路由上加载 JavaScript。</li><li>在 node 应用中只想加载特定模块，用来加快启动速度时。</li></ol></li><li><strong>打破循环依赖</strong>：某些模块加载器（commonjs/node 和 amd/requirejs）不能很好的处理循环依赖。在这种情况下，一方面使用延迟加载代码，另一方面预先加载模块。</li><li><strong>确保导入</strong>：当加载该模块只是想引入其附加的作用（如：模块可能会注册一些像 CodeMirror addons）时，然而，如果仅仅是 import/require （导入），经过 TypeScript 编译后，这些将会被完全忽视。在这种情况下可以使用一个 ensureImport 变量，来确保编译的 JavaScript 依赖该模块。</li></ol><h3 id="动态导入表达式" tabindex="-1">动态导入表达式 <a class="header-anchor" href="#动态导入表达式" aria-label="Permalink to &quot;动态导入表达式&quot;">​</a></h3><p>动态导入表达式是 ECMAScript 的新功能，它允许在程序的任意位置异步加载一个模块，目前处于提案的 stage4 阶段。此外，webpack 支持 Code Splitting 功能，它能允许将代码拆分为许多块，这些块在将来可被异步下载，webpack 实现代码分割的方式有两种：使用 import() （首选，ECMAScript 的提案）和 require.ensure()。在 tsconfig.json 中的compilerOptions编译选项配置中使用 &quot;module&quot;: &quot;esnext&quot; 选项使得TypeScript 保留 import() 语句用于 Webpack 的Code Splitting。</p><h3 id="lib-d-ts" tabindex="-1">lib.d.ts <a class="header-anchor" href="#lib-d-ts" aria-label="Permalink to &quot;lib.d.ts&quot;">​</a></h3><p>安装 TypeScript 时会安装 lib.d.ts 声明文件（包含 JavaScript 运行时以及 DOM 中存在各种常见的环境声明）。</p><ol><li>它自动包含在 TypeScript 项目的编译上下文中；</li><li>它使得能快速开始书写经过类型检查的 JavaScript 代码。</li></ol><p>如果当前运行的 JavaScript 环境与基于标准浏览器运行时环境有很大不同，或者希望在代码里严格的控制全局变量（比如不希望lib.d.ts中定义的某些全局变量泄漏到项目代码里），可以通过指定 --noLib 的编译器命令行标志（或者在 tsconfig.json 中指定选项noLib: true）从上下文中排除此文件，然后在编译上下文中包含一个命名相似的文件，TypeScript 将提取该文件进行类型检查，但请谨慎使用--noLib选项。</p><p>寻找代码类型的最简单方式是<strong>选中代码并 F12</strong> 或者 <strong>ctrl（Mac是command） + 鼠标左键</strong>跳转到定义。</p><p>在 TypeScript 中，接口也是开放式的，这意味着想使用原本不存在的成员时，只需要将它们添加至 lib.d.ts 中的接口声明中即可，TypeScript 将会自动接收它。注意，基于可维护性，推荐在全局模块（比如创建一个global.d.ts）中做这些修改，以使这些接口与 lib.d.ts 相关联，然而如果愿意，可以在文件模块中通过使用 declare global { /* global namespace */ }进入全局命名空间。String接口、Date接口等对应的是prototype，DateConstructor接口、StringConstructor接口等对应的是构造函数。</p><p>编译目标选项target改变编译出的代码版本，版本越高，能导致 lib.d.ts 包含更多的新功能的环境声明，但不应该将编译出的代码与环境混为一谈，如果是对环境进行更细粒的控制应该使用lib选项，它可以将任何lib（环境库支持）与target（编译目标，即生成的 JavaScript 版本）解耦。</p><p>lib 分类如下：</p><ol><li>JavaScript 功能：es5/es6/es2015/es7/es2016/es2017/esnext；</li><li>运行环境：dom/dom.iterable/webworker/scripthost；</li><li>ESNext 功能选项：es2015.core/es2015.collection/es2015.generator/es2015.iterable/es2015.promise/es2015.proxy/es2015.reflect/es2015.symbol/es2015.symbol.wellknown/es2016.array.include/es2017.object/es2017.sharedmemory/esnext.asynciterable。</li></ol><p>lib 选项提供非常精细的控制，因此最有可能从运行环境与 JavaScript 功能类别中分别选择一项，如果没有指定lib，则会导入默认库：</p><ol><li>target 选项为 es5 时，会导入es5, dom, scripthost。</li><li>target 选项为 es6 时，会导入es6, dom, dom.iterable, scripthost。</li></ol><p>targe 与 lib 配置示例：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">{</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">  &quot;complierOptions&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: {</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;target&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;es5&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,</span></span>
<span class="line"><span style="--shiki-light:#0451A5;--shiki-dark:#9CDCFE;">    &quot;lib&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: [</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;es6&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&quot;dom&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">] </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 如果要使用 Symbol，添加一个 &quot;es2015.symbol&quot; 即可</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  }</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>特别的，如果运行时是在旧的 JavaScript 引擎的浏览器中，要使用新功能（比如 Map、Set、Promise或更新的功能），除了使用现代的 lib 选项，还需要安装 core-js 并在项目中导入 Polyfill：core-js/shim。</p><h2 id="原始数据类型" tabindex="-1">原始数据类型 <a class="header-anchor" href="#原始数据类型" aria-label="Permalink to &quot;原始数据类型&quot;">​</a></h2><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。原始数据类型包括：boolean、number、string、null、undefined、Symbol、bigInt。</p><p>在 TypeScript 中，使用 boolean 定义布尔值类型， number 定义数值类型，string 定义字符串类型，而new Boolean/Number/String返回的是一个 Boolean/Number/String 对象，直接调用 Boolean /Number/String也可以返回一个 boolean /number/string类型。其中，0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，转为JavaScript时它们会被编译为十进制数字。其中<code></code>用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式，转为JavaScript时它们会被编译为字符串拼接。</p><p>JavaScript 没有空值（void）的概念，在 TypeScript 中，void类型表示没有任何返回值的函数。声明一个 void 类型的变量没有什么用，因为只能将它赋值为 undefined 和 null。在 TypeScript 中，可以使用 null 和 undefined 来定义原始数据类型null 和 undefined。与 void 的区别是，undefined 和 null 是所有类型的子类型，即undefined 和 null 类型的变量可以赋值给任何类型的变量（前提是strictNullChecks选项设置为false）。</p><h2 id="其他类型" tabindex="-1">其他类型 <a class="header-anchor" href="#其他类型" aria-label="Permalink to &quot;其他类型&quot;">​</a></h2><h3 id="元组-tuple-类型" tabindex="-1">元组（tuple）类型 <a class="header-anchor" href="#元组-tuple-类型" aria-label="Permalink to &quot;元组（tuple）类型&quot;">​</a></h3><p>在 TypeScript 中，数组合并了相同类型的元素，而元组合并了不同类型的元素：</p><ol><li>当赋值或访问元组类型中某个已知索引的元素时，会得到正确的类型。</li><li>当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。</li><li>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型。</li></ol><h3 id="枚举-enum-类型" tabindex="-1">枚举（enum）类型 <a class="header-anchor" href="#枚举-enum-类型" aria-label="Permalink to &quot;枚举（enum）类型&quot;">​</a></h3><p>枚举类型用于取值被限定在一定有限范围内的场景，枚举可以作为变量使用，因为它既处于类型声明空间，也位于变量声明空间。<strong>枚举使用 enum 关键字来定义</strong>：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">enum</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Tristate</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  False</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  True</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  Unknown</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">/**</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  // 枚举类型的编译结果</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  var Tristate;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  (function(Tristate) {</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    Tristate[(Tristate[&#39;False&#39;] = 0)] = &#39;False&#39;;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    Tristate[(Tristate[&#39;True&#39;] = 1)] = &#39;True&#39;;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    Tristate[(Tristate[&#39;False&#39;] = 0)] = &#39;Unknown&#39;;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  })(Tristate || (Tristate = {}))</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;"> */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">console</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">log</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">Tristate</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[</span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">0</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]); </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// &#39;False&#39;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">console</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">log</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">Tristate</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">False</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">); </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 0</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">console</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">log</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">Tristate</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">Tristate</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">False</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]); </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// &#39;False&#39; 因为 Tristate.False 为 0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><ol><li>枚举成员默认会被赋值为从 0 开始递增的数字，即数字类型枚举，同时也会对枚举值到枚举名进行反向映射。数字类型枚举允许将数字类型或者其他任何与数字类型兼容的类型赋值给枚举类型的实例。</li><li>枚举项可以手动赋值。手动赋值的枚举项可以不是数字，也可以是小数或负数。未手动赋值的枚举项会接着上一个枚举项步长为1递增。</li><li>根据枚举的编译结果，枚举是开放式的，意味着可以跨多个文件拆分（和扩展）枚举定义。在枚举的延续块中，重新初始化第一个成员（此处为 DarkRed = 3），使生成的代码不破坏先前定义的值（即0、1...等值），否则，TypeScript 将会发出警告（错误信息：In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.）。只有在不使用模块时，开放式的枚举才有意义，然而应该使用模块而不是开放式枚举。</li><li>可以使用枚举，将其中的数字枚举成员作为标志，允许你检查一组条件中的某个条件是否为真。使用左移的位运算符，将除0以外的每个数字枚举成员的二进制向左移动位置得到数字 0001、0010、0100 和 1000（换成十进制结果是：1, 2, 4, 8），依次类推，然后，可以使用 |= 来添加一个标志；组合使用 &amp;= 和 ~ 来清理标志；| 来合并多个标志。比如:</li></ol><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">enum</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Flags</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  None</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">0</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  Flag1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> &lt;&lt; </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">0</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  Flag1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> &lt;&lt; </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  Flag1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> &lt;&lt; </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">2</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  Flag1Flag2Flag3</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">Flag1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> | </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">Flag2</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> | </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">Flag3</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="5"><li>枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错。当满足以下条件时，枚举成员被当作是常数，其它情况的枚举成员被当作是需要计算得出的值： <ol><li>不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。</li><li>枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式： <ol><li>数字字面量；</li><li>引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用；</li><li>带括号的常数枚举表达式；</li><li>+, -, ~ 一元运算符应用于常数枚举表达式； 5.+, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错。</li></ol></li></ol></li></ol><p><strong>常数枚举是使用 const enum 定义的枚举类型</strong>，常数枚举与普通枚举的区别是它会在编译阶段被删除，可以获得性能提升，并且不能包含计算成员，否则会在编译阶段抛错。然而，可能除了内联枚举，还想让编译器仍然把枚举类型的定义编译到JavaScript中，用于从字符串到数字，或者是从数字到字符串的查找。在这种情景下，可以使用编译选项 --preserveConstEnums，并且这不会以任何方式影响内联。</p><p><strong>外部枚举（Amibient Enums）是使用 declare enum 定义的枚举类型</strong>，declare 定义的类型只会用于编译时的检查，编译结果中会被删除。外部枚举与声明语句一样，常出现在声明文件（.d.ts）中，同时使用 declare 和 const 关键字也是可以的。</p><p><strong>有静态方法的枚举</strong>，可以使用 enum定义好枚举类型SomeEnum，然后再使用namespace 向枚举类型SomeEnum中添加静态方法。</p><h3 id="任意-any-类型" tabindex="-1">任意（any）类型 <a class="header-anchor" href="#任意-any-类型" aria-label="Permalink to &quot;任意（any）类型&quot;">​</a></h3><p>任意类型用来表示允许赋值为任意类型。</p><ol><li>对于单一普通类型，在赋值过程中改变类型是不被允许的，任意类型则可以。</li><li>在任意值上访问任何属性都是允许的，也允许调用任何方法。</li><li>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型。 通常，会用any 来表示数组中允许出现任意类型，即 any[]。</li></ol><h3 id="never-类型" tabindex="-1">never 类型 <a class="header-anchor" href="#never-类型" aria-label="Permalink to &quot;never 类型&quot;">​</a></h3><p>never 类型表示那些永不存在的值的类型。特别的，never 可以是永远不返回的函数的返回值类型，也可以是变量在类型收窄中不可能为真的类型，也可以是总是会抛出错误的函数的类型。具有以下特征：</p><ol><li>没有类型是 never 的子类型，never类型可以赋值给任何类型，返回 never 的函数可以赋值给需要返回一个具体类型的函数。never类型可作为类型注解；</li><li>never 是所有类型的子类型，在联合类型中它始终被省略，并且只要函数有其他返回的类型，推导出的函数返回值类型中就会忽略它；</li><li>除了never类型，没有类型可以赋值给 never类型；</li><li>在一个没有返回值标注的函数表达式或箭头函数中，如果函数没有 return 语句，或者仅有表达式类型为 never 的 retur 语句，并且函数的终止点无法被执行到（按照控制流分析），则推导出的函数返回值类型是 never；</li><li>在一个明确指定了 never 返回值类型的函数中，所有 return 语句（如果有）表达式的值必须为 never 类型，且函数不应能执行到终止点。</li></ol><p>never 类型同时也是 TypeScript 中的底层类型，自然被分配为never类型包括：</p><ol><li>一个从来不会有返回值的函数（如：函数内含有 while(true) {}）；</li><li>一个总是会抛出错误的函数（如：function foo() { throw new Error(&#39;Not Implemented&#39;) }，foo 的返回类型是 never）。</li></ol><p>void 表示没有任何类型，never 表示永远不存在的值的类型。当一个函数没有返回值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。void 类型可以被赋值（在 strictNullChecking 为 false 时），但是除了 never 本身以外，其他任何类型不能赋值给 never。</p><h3 id="数组-array-类型" tabindex="-1">数组（Array）类型 <a class="header-anchor" href="#数组-array-类型" aria-label="Permalink to &quot;数组（Array）类型&quot;">​</a></h3><p>在 TypeScript 中，有多种方式定义数组类型，<strong>最简单的方法是使用「类型 + 方括号」来表示数组</strong>。数组的项中不允许出现其他的类型。数组方法的参数也会根据数组在定义时约定的类型进行限制。<strong>也可以使用数组泛型（Array Generic）即 <code>Array&lt;elemType&gt;</code> 来表示数组</strong>。也可以用interface接口来描述数组。然而类数组只能使用接口的方式来描述。</p><p>使用接口表示数组：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> NumberArray</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  [</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">index</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">number</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">number</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 类数组</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> ArrayLike</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  readonly</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> [</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">index</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">number</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  readonly</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> length</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">number</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="函数-function-类型" tabindex="-1">函数（Function）类型 <a class="header-anchor" href="#函数-function-类型" aria-label="Permalink to &quot;函数（Function）类型&quot;">​</a></h3><p>函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到。</p><ol><li><p>输入多余的（或者少于要求的）参数，是不被允许的，但支持用 ? 表示可选的参数且可选参数必须接在必需参数后面。在 ES6 中允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数且不受「可选参数必须在必需参数后面」的限制。</p></li><li><p>在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型，而且不能使用重载，而 ES6 中，=&gt; 叫做箭头函数。</p></li><li><p>在 ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数），事实上，rest是一个数组，所以可以用数组的类型来定义它。</p></li><li><p>如果有一个含有很多参数或者相同类型参数的函数，那么可能需要考虑将函数改为接收对象的形式，有利于发现错误及代码审查。</p></li><li><p><strong>在 TypeScript 中，通过重复定义多次函数类型进行重载允许一个函数接受不同数量或类型的参数，作出不同的处理</strong>。TypeScript 中的函数重载没有任何运行时开销，它只允许记录希望调用函数的方式，并且编译器会检查其余代码。注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。最后一个签名要包含前面所有签名的情况，并且它不在重载列表内，即最后一个签名不能被有效调用。</p></li><li><p>在没有提供函数实现的情况下，有两种声明函数类型的方式，完全相同，区别在于方式（1）才支持函数重载：</p><ol><li>可以使用类型别名或者接口来表示一个可调用的类型注解，type LongHand = { (a: number): number; }; 或 interface LongHand { (a: number): number; }; 这种方式可以在内联注解语法上使用。可实例化是可调用的一种特殊情况，在其中的函数声明前添加new关键字。 可调用且可实例化：</li></ol><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> CallMeWithNew</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  new</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (): </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">someType</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 或</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> CallMeWithNew</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  new (): someType;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="2"><li>type ShortHand = (a: number) =&gt; number;</li></ol></li><li><p>对于函数表达式，进行类型定义应该是对赋值目标进行定义。</p></li><li><p>函数返回类型如果确定为void，内联注解可以删除void，TypeScript 能推导出来。</p></li><li><p>也可以使用接口interface的方式来定义一个函数需要符合的形状。</p></li></ol><p>使用接口定义函数：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> IFunc</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">param1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">param2</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">): </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">boolean</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="字符串-数字-布尔字面量类型" tabindex="-1">字符串/数字/布尔字面量类型 <a class="header-anchor" href="#字符串-数字-布尔字面量类型" aria-label="Permalink to &quot;字符串/数字/布尔字面量类型&quot;">​</a></h3><p>字符串字面量可以作为类型，约束只能是该字符串字面量。字符串字面量类型用来约束取值只能是某几个字符串中的一个（type StringLiteralType = ‘string1’ | ‘string2’ | ‘string3’），通过关键字type和联合类型符号“|”进行定义。注意，类型别名与字符串字面量类型都是使用 type 进行定义。</p><p>TypeScript 同样也提供 boolean 和 number 的字面量类型。</p><p>使用 keyof typeof 操作一个普通对象obj，可以返回obj的属性构成的字符串字面量联合类型。</p><h3 id="对象字面量类型" tabindex="-1">对象字面量类型 <a class="header-anchor" href="#对象字面量类型" aria-label="Permalink to &quot;对象字面量类型&quot;">​</a></h3><p>为了能让检查对象字面量类型更容易，TypeScript 提供 「Freshness」 的概念（它也被称为更严格的对象字面量检查）用来确保对象字面量在结构上类型兼容。结构类型在赋值时，可以允许接受未知属性，然而在对象字面量上只能指定已知属性即更严格的对象字面量类型：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">const</span><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;"> person1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = { </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">name:</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> &#39;matt&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">job:</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> &#39;being awesome&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> };</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">let</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> person2</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  name:</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">} = </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">person1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">; </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// ok，因为非对象字面量赋值可以有未知属性</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">person2</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = { </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">name:</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> &#39;matt&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">job:</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> &#39;being awesome&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> }; </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// Error，因为对象字面量只能指定已知属性，&#39;job&#39; 属性不存在 person2 的类型中</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>使用比较多的场景是与具有可选成员的接口一起使用，如果严格的对象字面量检查，当输入的对象中属性名错误时，并不会发出错误警告。</p><p>之所以只对<strong>对象字面量</strong>进行更严格类型检查，因为在使用对象字面量时，保证属性不被拼写错误或属性不冗余。</p><p>但是，可以通过包含索引签名[propName: string]: valueType的方式明确表明可以使用额外的属性。</p><p>React的this.setState通常是使用对象字面量进行调用，它是Freshness的很好的用例。</p><h3 id="接口-interface" tabindex="-1">接口（interface） <a class="header-anchor" href="#接口-interface" aria-label="Permalink to &quot;接口（interface）&quot;">​</a></h3><p>在 TypeScript 中，使用接口即interface来定义对象的类型。TypeScript 中的接口可用于对类的一部分行为进行抽象，也常用于对「对象的形状（Shape）」进行描述。</p><ol><li>接口一般首字母大写。</li><li>接口对运行时的影响为 0。</li><li>接口相比接口形式的内联类型注解，是开放式的即可扩展的（利用接口声明合并，扩展接口成员）。</li><li>赋值的时候，变量的形状必须和接口保持一致，但可以使用可选属性，其含义是该属性可以不存在，但仍然不允许添加未定义的属性。</li><li>使用 [propName: string]: valueType 可以定义任意属性，其他确定属性和可选属性的值类型都必须是类型valueType的子集。一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在该任意属性中使用联合类型。如果同时存在任意属性、可选属性，那么任意属性的数据类型要带undefined，除非valueType是any。</li><li>可以用 <strong>readonly</strong> 前缀定义只读属性（包括索引签名）。注意，只读的约束存在于第一次给对象赋值后，而不是第一次给只读属性赋值后。 <ol><li>也可以在type里使用 readonly；</li><li>比如React中的声明文件已经标记Props和State的属性为 readonly（通过传入泛型参数至一个内部包装，来把每个属性标记为 readonly）。</li><li>可以使用 TypeScript 提供的 <code>ReadonlyArray&lt;T&gt;</code> 接口，以不变的方式使用原生 JavaScript 数组。</li><li>编译器能把一些特定的属性推断为 readonly，比如class 中一个只含有 getter 但是没有 setter 的属性能被推断为只读。</li><li><strong>与 const 的区别</strong>：const用于变量且变量不能重新赋值为其他任何值。readonly用于属性，readonly 能确保本身不能修改属性，但是由于类型兼容性的原因，当把这个属性交给其他并没有这种保证的使用者后能被修改。</li></ol></li></ol><h4 id="interface-vs-type" tabindex="-1">interface vs type? <a class="header-anchor" href="#interface-vs-type" aria-label="Permalink to &quot;interface vs type?&quot;">​</a></h4><p>interface 的几乎所有功能都在type 中可用，主要区别在于类型创建后无法更改，而接口始终可扩展。接口只能用于声明对象的形状，而不是重命名基本类型/联合类型/交叉类型。类型别名不得参与 在声明合并中，但接口可以。命名联合类型的类型别名无法被实现/扩展。</p><p><img src="/silver-bullet/assets/1.DD2exoKo.png" alt=""></p><h2 id="类" tabindex="-1">类 <a class="header-anchor" href="#类" aria-label="Permalink to &quot;类&quot;">​</a></h2><p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。类的相关概念：</p><ol><li>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法。</li><li>对象（Object）：类的实例，通过 new 生成。</li><li><strong>面向对象（OOP）的三大特性：封装、继承、多态</strong>。 <ol><li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据。</li><li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性。继承可以描述类与类之间的关系。子类重写父类的成员时类型需要和父类匹配。</li><li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行eat。</li></ol></li><li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为。</li><li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法。</li><li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现。</li><li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。<strong>接口可以被类实现（implements）</strong>，希望在类中使用必须要被遵循的接口（类）或别人定义的对象结构时使用，implements关键字限制了类实例的结构。一个类只能继承自另一个类，但是可以实现多个接口。</li></ol><p>ES6 中，使用 class 定义类，使用 constructor 定义构造函数。通过 new 生成新实例的时候，会自动调用构造函数。使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。使用 getter 和 setter 可以改变属性的赋值和读取行为。使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用。</p><p>ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义，ES7 中可以直接在类里面定义。ES7 提案中，可以使用 static 定义一个静态属性。</p><p>在 TypeScript 中，可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected：</p><ol><li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的。</li><li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问，即实例中无法访问，在子类中也无法访问。需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。<strong>当构造函数修饰为 private 时，该类不允许被继承或实例化</strong>。</li><li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的，即子类实例中也无法访问。protected修饰构造函数时，该类只允许继承。</li><li>readonly指定一个类的属性为只读，然后在声明时或者构造函数中进行初始化。</li><li>修饰符 public、修饰符 private 和修饰符 protected 以及 readonly，还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。只读属性关键字readonly，只允许出现在属性声明或索引签名或构造函数中。注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面：</li></ol><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">class</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Animal</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  // public readonly name: string</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  public</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> constructor</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">public</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> readonly</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> name</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    // this.name = name;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  }</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>abstract 用于定义抽象类和其中的抽象方法。首先，抽象类是不允许被实例化的，否则会编译抛出错误。其次，抽象类中的抽象方法必须被子类实现，否则也会编译抛出错误。需要注意的是，即使TypeScript 的编译结果中，仍然会存在这个抽象类，但这个抽象类中没有抽象方法。</p><p>类名可以作为类型注解（:TypeAnnotation），因为它既处于类型声明空间，也位于变量声明空间。然而，使用var/let/const 声明新变量赋值为已有类名，只是复制该类到变量声明空间，新变量不能再作为类型注解使用。正确的方式是使用 import 关键字，import NewClassName = ClassName。</p><p>TypeScript（和 JavaScript）类只能严格的单继承。混合（mixins）是以基类作为输入和一个继承该基类的派生类作为输出的函数，实现多重继承：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Constructor</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = {}&gt; = </span><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">new</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (...</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">args</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[]) </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">function</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> Activatable</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">TBase</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> extends</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Constructor</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">Base</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">TBase</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  return</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> class</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> extends</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Base</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">    isActivated</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">false</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">    activate</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">() {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">      this</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">isActivated</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">true</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">    }</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">    deactivate</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">() {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">      this</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">isActivated</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">false</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">    }</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  };</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="uml-类图" tabindex="-1">UML 类图 <a class="header-anchor" href="#uml-类图" aria-label="Permalink to &quot;UML 类图&quot;">​</a></h3><p>**统一建模语言(Unified Modeling Language，UML)**是一种为面向对象系统的产品进行说明、可视化和编制文档的的一种标准语言，UML是面向对象设计的建模工具，独立于任何具体程序设计语言。</p><p>类图表示类、接口和它们之间的协作关系。类的属性、操作中的可见性使用+、#、－分别表示 public、protected、private。static 静态属性和方法添加下划线表示。类之间的关系有：</p><ol><li>关联（即A是B的属性，实线非心箭头指向A，线上可添加n:m表示数量对应关系），可细化为： <ol><li>聚合：整体A包含部分B，部分可以脱离整体而单独存在；空心菱形开始实线非心箭头指向B。</li><li>组合：整体A包含部分B，部分不可以脱离整体；实心菱形开始实线非心箭头指向B。</li><li>依赖：不是属性关系，而是函数参数B或返回值B。虚线非心箭头指向B。</li></ol></li><li>泛化（即继承）：实线空闲箭头指向父类。</li><li>实现（即实现接口）：虚线空心箭头指向接口。</li></ol><p>UML类图中，单个类分为三个区域（类名、属性、方法）。对于接口，需要在类名前添加<code>&lt;&lt;Interface&gt;&gt;</code>，而且接口属性和方法放在同一区域。</p><h2 id="声明文件" tabindex="-1">声明文件 <a class="header-anchor" href="#声明文件" aria-label="Permalink to &quot;声明文件&quot;">​</a></h2><h3 id="关于声明文件" tabindex="-1">关于声明文件 <a class="header-anchor" href="#关于声明文件" aria-label="Permalink to &quot;关于声明文件&quot;">​</a></h3><p>通常会把声明语句放到一个单独的文件（声明文件必需以 .d.ts 为后缀）中，这就是声明文件，也就是环境声明。当使用第三方库时需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。TypeScript会解析项目中所有的 *.ts 文件，当然也包含以 .d.ts 结尾的文件，前提根据tsconfig.json 中的 files、include 和 exclude 配置确保包含声明文件。通常是通过使用 @types 统一管理第三方库的声明文件。声明语句用于编译时的检查，在编译结果中会被删除。声明文件的类型可以直接使用而不需要手动导入。</p><h3 id="书写声明文件" tabindex="-1">书写声明文件 <a class="header-anchor" href="#书写声明文件" aria-label="Permalink to &quot;书写声明文件&quot;">​</a></h3><p>库的使用场景主要有：</p><ol><li><p><strong>全局变量：通过 <code>&lt;script&gt;</code> 标签或npm安装引入第三方库，注入全局变量</strong>。使用全局变量的声明文件时，如果是以 npm install @types/xxx --save-dev 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 src 目录下（或者对应的源码目录下）。需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现。声明语句用于编译时的检查，在编译结果中会被删除。全局变量的声明文件主要语法有：</p><ol><li>declare var/let/const 声明全局变量，其中declare var与declare let没什么区别，而declare const 声明定义的全局变量是常量，通常全局变量都是禁止修改的常量，因此大部分情况使用的是declare const。</li><li>declare function 声明全局方法/函数的类型。在函数类型的声明语句中，支持函数重载。</li><li>declare class 声明全局类的类型。</li><li>declare enum 声明全局枚举类型，也称作外部枚举（Ambient Enums）。</li><li>declare namespace 声明（含有子属性的）全局对象。namespace 是TypeScript早期时为了解决模块化而创造的关键字，中文称为命名空间。由于历史遗留原因，在早期还没有 ES6 的时候，TypeScript提供了一种模块化方案，使用 module 关键字表示内部模块。但由于后来 ES6 也使用了 module 关键字，TypeScript 为了兼容 ES6，使用 namespace 替代了原来的 module，更名为命名空间。随着 ES6 的广泛应用，不建议再使用TypeScript中的 namespace模块化方案，而推荐使用 ES6 的模块化方案了。namespace 模块化方案被淘汰了，但是在声明文件中，declare namespace 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。注意，在 declare namespace 内部，直接使用 function来声明函数，而不是使用 declare function。类似的，也直接使用 const, class, enum 等语句。如果对象拥有深层的层级，则需要用嵌套的 namespace 而不是declare namespace来声明深层的属性的类型。假如 declare namespace声明的全局对象下仅有一个属性prop，则可以不需要嵌套 namespace，而是直接 declare namespace globalObject.prop 内部去声明prop的子属性。</li><li>interface 和 type 声明全局类型。暴露在声明文件中最外层的 interface 或 type 会作为全局类型作用于整个项目中，应该尽可能的减少这种全局变量或全局类型的数量，而最好将它们放到declare namespace 下，而在使用时需要加上declare namespace声明的全局对象前缀。</li></ol></li><li><p><strong>npm 包：通过 import foo from &#39;foo&#39; 导入，符合 ES6 模块规范</strong>。在尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：</p><ol><li>与该 npm 包绑定在一起。判断依据是 package.json 中有 types 字段，或者有一个 index.d.ts 声明文件。这种模式不需要额外安装其他包，是最为推荐的。</li><li>发布到 @types 里。只需要尝试安装一下对应的 @types 包就知道是否存在该声明文件，安装命令是 <code>npm install @types/[some] --save-dev</code>。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 @types 里了。@types 支持全局和模块类型定义。@types支持全局和模块类型定义，全局即默认情况下，TypeScript 会自动包含支持全局使用的任何声明定义；模块指可以像import导入模块那样被使用。全局类型定义可通过编译选项 ’compilerOptions’: { ‘types’: [] } 进行配置，只允许使用types对应的 @types 包，即使安装其他声明文件，其他声明文件的全局变量也不会泄漏到项目代码中，直到将它们添加到types选项里。</li></ol><p>假如以上两种方式都没有找到对应的声明文件，那么就需要自己为它写声明文件了。由于是通过 import 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：</p><ol><li>创建一个 <code>node_modules/@types/[some]/index.d.ts</code> 文件，存放对应模块的声明文件。这种方式不需要额外的配置，但是 node_modules 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。</li><li>创建一个 types 目录，专门用来管理自己写的声明文件，将对应模块的声明文件放到 <code>types/[some]/index.d.ts</code> 中。这种方式需要配置下 tsconfig.json 中的 paths 和 baseUrl 字段。如此配置后，通过 import 导入对应模块的时候，也会去 types 目录下寻找对应的模块的声明文件了。</li></ol><p>注意 module 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。最常用的是 commonjs。不管采用了以上两种方式中的哪一种，都强烈建议将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 @types 里）发布到开源社区中。</p><p>npm 包的声明文件主要有以下几种语法：</p><ol><li><strong>export 导出变量</strong>。export 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现。也可以使用 declare 先声明多个变量，最后再用 export 一次性导出，注意，与全局变量的声明文件类似，interface 前是不需要 declare 的。npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 export 导出，然后在使用方 import 导入后，才会应用到这些类型声明。</li><li><strong>export namespace 导出（含有子属性的）对象</strong>。与 declare namespace 类似，export namespace 用来导出一个拥有子属性的对象。</li><li><strong>export default ES6 默认导出</strong>。 在 ES6 模块系统中，使用 export default 可以导出一个默认值，使用方可以用 import some from &#39;some&#39; 而不是 import { some } from &#39;some&#39; 来导入这个默认值。在类型声明文件中，export default 用来导出默认值的类型。注意，只有 function、class 和 interface 可以直接默认导出，其他的变量需要先定义出来再默认导出。默认导出一般会将导出语句放在整个声明文件的最前面。</li><li><strong>export = commonjs 导出模块</strong>。在 commonjs 规范中，用module.export 或export.some = some方式来导出一个模块。在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 const ... = require。第二种方式是 import ... from，注意针对整体导出module.export，需要使用 import * as 来导入。第三种方式是 import ... require，这也是 ts 官方推荐的方式。对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 <strong>export =</strong> 语法。使用了export =就不能再使用export 单个导出。export = 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，import ... require 和 export = 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法。虽然由于很多第三方库是 commonjs 规范的，但相比与 export =，我们更推荐使用 ES6 标准的 export default 和 export。</li></ol></li><li><p><strong>UMD 库：既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 import 导入</strong>。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，ts 提供了一个新语法 export as namespace实现这种方式。一般使用 export as namespace 时，都是先有了 npm 包的声明文件，再基于它添加一条 export as namespace 语句，即可将声明好的一个变量声明为全局变量。export as namespace也可以与 export default 一起使用。</p></li><li><p><strong>直接扩展全局变量：通过 <code>&lt;script&gt;</code> 标签引入后，改变一个全局变量的结构</strong>。有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要利用声明合并扩展全局变量的类型。</p></li><li><p><strong>在 npm 包或 UMD 库中扩展全局变量：引用 npm 包或 UMD 库后，改变一个全局变量的结构</strong>。对于一个 npm 包或者 UMD 库的声明文件，只有 export 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用 declare global语法在声明文件中扩展全局变量的类型。注意即使模块声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。</p></li><li><p><strong>模块插件：通过 <code>&lt;script&gt;</code> 或 import 导入后，改变另一个模块的结构</strong>。有时通过 import 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。TypeScript提供declare module语法用来在模块插件的类型声明文件对原有模块的类型进行扩展。declare module 也可用于在一个文件中一次性声明多个模块的类型。</p></li></ol><p>一个声明文件有时会依赖另一个声明文件中的类型。除了可以在声明文件中通过 import 导入另一个声明文件中的类型之外，还可以使用**三斜线指令（<code>/// &lt;reference type=&#39;&#39;或path=&#39;&#39;/&gt;</code>）**来导入另一个声明文件。三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明普通模块之间的依赖关系了，而在声明文件中有用武之地。类似于声明文件中的 import，它可以用来导入另一个声明文件。与 import 的区别是，当且仅当在以下几个场景下才需要使用三斜线指令替代 import，在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 import 来导入：</p><ol><li>当书写一个全局变量的声明文件时；在全局变量的声明文件中，是不允许出现 import, export 关键字的，否则会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了。</li><li>当需要依赖一个全局变量的声明文件时。由于全局变量不支持通过 import 导入，当然也就必须使用三斜线指令来引入。</li></ol><p>注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。当全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。types 和 path 是三斜线指令中两种不同的指令。它们的区别是：types 用于声明对另一个库的依赖，而 path 用于声明对另一个文件的依赖。</p><p><strong>自动生成声明文件：如果库的源码本身就是由 ts 写的，那么在使用 tsc 脚本将 ts 编译为 js 的时候，在tsconfig.json中添加 declaration 选项为true，就可以自动生成 .d.ts 声明文件到lib</strong>。使用 tsc 自动生成声明文件时，每个 ts 文件都会对应一个 .d.ts 声明文件。这样的好处是，使用方不仅可以在使用 import some from &#39;some&#39; 导入默认的模块some时获得类型提示，还可以在使用 import other from &#39;some/lib/other&#39; 导入一个子模块other时，也获得对应的类型提示。除了 declaration 选项之外的与自动生成声明文件有关的选项有：</p><ol><li>declarationDir 设置生成 .d.ts 文件的目录；</li><li>declarationMap 对每个 .d.ts 文件，都生成对应的 .d.ts.map（sourcemap）文件；</li><li>emitDeclarationOnly 仅生成 .d.ts 文件，不生成 .js 文件。</li></ol><h3 id="发布声明文件" tabindex="-1">发布声明文件 <a class="header-anchor" href="#发布声明文件" aria-label="Permalink to &quot;发布声明文件&quot;">​</a></h3><p>发布声明文件有两种方案：</p><ol><li>将声明文件和源码放在一起。如果声明文件是通过 tsc 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。如果是手动写的声明文件，那么按以下优先级满足其中一个条件才能被正确的识别（有的库为了支持导入子模块，就需要额外再编写一个类型声明文件）： <ol><li>给 package.json 中的 types 或 typings 字段指定一个类型声明文件地址；</li><li>在项目根目录下，编写一个 index.d.ts 文件；</li><li>针对入口文件（package.json 中的 main 字段指定的入口文件），编写一个同名不同后缀的 .d.ts 文件；</li></ol></li><li>将声明文件发布到 @types 下。与普通的 npm 模块不同，@types 是统一由 DefinitelyTyped 管理的。要将声明文件发布到 @types 下，就需要给 DefinitelyTyped 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 tsconfig.json 等。pull-request 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 @types 下。</li></ol><p>优先选择第一种方案。保持声明文件与源码在一起，使用时就不需要额外增加单独的声明文件库的依赖了，而且也能保证声明文件的版本与源码的版本保持一致。仅当在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request 时，才需要使用第二种方案，将声明文件发布到 @types 下。</p><h2 id="内置对象" tabindex="-1">内置对象 <a class="header-anchor" href="#内置对象" aria-label="Permalink to &quot;内置对象&quot;">​</a></h2><p>JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。</p><p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。ECMAScript 标准提供的内置对象有：Boolean、Error、Date、RegExp 等；DOM 和 BOM 提供的内置对象有：Document、HTMLElement、Event、NodeList 等。这些对象的定义文件在 TypeScript 核心库的定义文件中。</p><p>TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。注意，TypeScript 核心库的定义中不包含 Node.js 部分。Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件@types/node。</p><h2 id="类型兼容性" tabindex="-1">类型兼容性 <a class="header-anchor" href="#类型兼容性" aria-label="Permalink to &quot;类型兼容性&quot;">​</a></h2><p>类型兼容性用于确定一个类型是否能赋值给其他类型。比如，string 类型与 number 类型不兼容。</p><ol><li>安全性：TypeScirpt类型系统设计比较方便，它允许有一些不正确的行为。比如，任何类型都能被赋值给any。类型安全：保证成员始终可用（即只能子类型（范围小的）赋值给父类型（范围大的），函数则是判定具体参数、返回值是否满足此规则）。</li><li>结构化：TypeScript 对象是一种结构类型，这意味着只要结构匹配，名称无关紧要，即成员类型是兼容的则它们就是兼容的。允许动态创建对象，并且如果它能被推断，该对象仍然具有安全性，比如类型推论时，对象中额外属性是允许的。</li><li>变体：对一个简单类型 Base 和 Child 来说，如果 Child 是 Base 的子类，Child 的实例能被赋值给 Base 类型的变量。这是多态性。在由 Base 和 Child 组合的复杂类型的类型兼容性中，它取决于相同场景下的 Base 与 Child 的变体： <ol><li>协变（Covariant）：只在同一个方向；</li><li>逆变（Contravariant）：只在相反的方向；</li><li>双向协变（Bivariant）：包括同一个方向和不同方向；</li><li>不变（Invariant）：如果类型不完全相同，则它们是不兼容的。</li></ol></li></ol><p><strong>我们在协变与逆变中约定</strong>：</p><ol><li><strong>A ≼ B</strong> 意味着 A 是 B 的子类型。子类型通常是可传递的。</li><li><strong>A → B</strong> 指的是以 A 为参数类型，以 B 为返回值类型的函数类型。假设 f 是一个以 Dog → Dog 为参数的函数即f : (Dog → Dog) → String。Dog -&gt; Dog安全的子类型可以是 Animal -&gt; Greyhound。首先，f 可能会以任何狗的品种来作为参数调用，而所有的狗都是动物。其次，它可能会假设结果是一条狗，而所有的灰狗都是狗。即(Animal → Greyhound) ≼ (Dog → Dog)。返回值类型，灰狗是狗的子类型。但参数类型则是相反的：动物是狗的父类！允许一个函数类型中，返回值类型是协变的，而参数类型是逆变的。返回值类型是协变的，意思是 A ≼B 就意味着 (T → A) ≼ (T → B) 。参数类型是逆变的，意思是 A ≼B 就意味着 (B → T) ≼ (A → T) 。在 TypeScript 中，参数类型是双向协变的，即既是协变又是逆变的，而这并不安全。但是现在可以在 TypeScript 2.6+ 版本中通过 --strictFunctionTypes 或 --strict 标记设置为true来修复这个问题。可以允许不变的列表（immutable）在它的参数类型上是协变的，但是对于可变的列表（mutable），其参数类型则必须是不变的（invariant），既不是协变也不是逆变。</li><li><strong>x : A</strong> 意味着 x 的类型为 A。</li></ol><h2 id="类型推论-类型断言-类型保护" tabindex="-1">类型推论/类型断言/类型保护 <a class="header-anchor" href="#类型推论-类型断言-类型保护" aria-label="Permalink to &quot;类型推论/类型断言/类型保护&quot;">​</a></h2><h3 id="类型推论" tabindex="-1">类型推论 <a class="header-anchor" href="#类型推论" aria-label="Permalink to &quot;类型推论&quot;">​</a></h3><p><strong>类型推论</strong>：TypeScript 会在没有明确的指定类型的时候推测出一个类型。如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）（又称类型推断、类型判断）的规则推断出一个类型。如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查。</p><ol><li>如果类型不能被赋值推断出来，类型也将不会流入函数参数中。</li><li><strong>编译选项 noImplicitAny</strong> 告诉编译器，当无法推断变量的类型或者只能推断为一个隐式的 any 类型时抛出编译错误，通过显式添加 :any 的类型注解或者更正确的类型注解来帮助 TypeScript 推断类型而不是抛出错误。</li></ol><h2 id="类型断言" tabindex="-1">类型断言 <a class="header-anchor" href="#类型断言" aria-label="Permalink to &quot;类型断言&quot;">​</a></h2><p><strong>类型断言</strong>（Type Assertion）可以用来手动指定一个值的类型。语法是 <strong>&lt;类型&gt;值</strong> 或 <strong>值 as 类型</strong>，在 tsx 语法中必须使用后一种即<strong>值 as 类型</strong>，因为前者会与 JSX 的语法存在歧义。前者是在需要断言的变量前加上 <code>&lt;Type&gt;</code> 即可。类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的。类型断言的常见用途有：</p><ol><li><strong>将一个联合类型断言为其中一个类型</strong>。需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误。总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</li><li><strong>将一个父类断言为更加具体的子类</strong>。特别是当某一个类型不是一个真正的类，而只是一个 TypeScript 的接口（interface），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 instanceof 来做运行时判断。</li><li><strong>将任何一个类型断言为 any</strong>，因为在 any 类型的变量上，访问任何属性都是允许的。需要注意的是，将一个变量断言为 any 可以说是解决 TypeScript 中类型问题的最后一个手段。它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 as any，也可以使用类型扩展的方式解决。总之，一方面不能滥用 as any，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡。</li><li><strong>将 any 断言为一个具体的类型</strong>。在日常的开发中，我们不可避免的需要处理 any 类型的变量，可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。通过类型断言及时的把 any 断言为精确的类型，亡羊补牢，才能使代码向着高可维护性的目标发展，提高代码的可维护性。</li></ol><p><strong>类型断言的限制</strong>：并不是任何一个类型都可以被断言为任何另一个类型。具体来说，要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可（当 A 类型是 B类型的子集，或者 B 类型是 A 类型的子集时，A 能被成功断言成 B）。TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。</p><p><strong>双重断言</strong>：通过任何类型都可以被断言为 any和any 可以被断言为任何类型，我们知道，通过双重断言（as any as type）可以打破类型断言的限制，将任何一个类型断言为任何另一个类型。双重断言十有八九是非常错误的，它很可能会导致运行时错误，除非迫不得已，千万别用双重断言。 类型断言vs 类型转换：类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除。类型断言不是类型转换，它不会真的影响到变量的类型，因为后者通常意味着某种运行时的支持。若要进行类型转换，需要直接调用类型转换的方法。</p><p><strong>类型断言 vs 类型声明</strong>：类型断言是被认为有害的，即使断言使得更容易的从遗留项目中迁移（甚至将其他代码粘贴复制到项目中），因此应该小心谨慎的使用类型断言而是使用类型声明注解。类型声明是比类型断言更加严格的，最好优先使用类型声明，这也比类型断言的 as 语法更加优雅。类型1断言为类型2，只需要满足类型1兼容类型2或类型2兼容类型1即可；但类型1赋值给类型2，需要满足类型2兼容类型1。</p><p><strong>类型断言 vs 泛型</strong>：通过给返回any类型的函数添加了一个泛型 <code>&lt;T&gt;</code>，可以更加规范的实现对改函数返回值的约束，这也同时去除掉了代码中的 any，是最优的一个解决方案。</p><h3 id="类型保护" tabindex="-1">类型保护 <a class="header-anchor" href="#类型保护" aria-label="Permalink to &quot;类型保护&quot;">​</a></h3><p><strong>类型保护</strong>允许使用更小范围下的对象类型。对于联合类型的变量，是无法法知道编译时的具体类型的。JavaScript 中常用的方式是检查成员是否存在，但是 TypeScript 中联合类型只有访问联合类型中共同拥有的成员（即辨析联合类型）。而TypeScript 的类型保护机制：一次判断，整个作用域/所有分支有效。类型保护（Type Guards）就是一些表达式，会在运行时检查以确保在某个作用域内的类型：</p><ol><li><strong>typeof 类型保护</strong>：用于判断变量是哪种原始类型。typeof 类型保护只有两种形式能被识别（typename 必须为 number、string、boolean 或 symbol 类型，但是 TypeScript 并不会阻止与其他字符串字面量比较而且不会把那些表达式识别为类型保护）： <ol><li>typeof val === &#39;typename&#39;；</li><li>typeof val !== &#39;typename&#39;。</li></ol></li><li><strong>instanceof 类型保护</strong>：主要用于判断是否是一个类的实例对象或继承实例对象。instanceof 类型保护是通过构造函数来细化类型，其右侧要求是一个构造函数，TypeScript 将细化为： <ol><li>此构造函数的 prototype 属性的类型，如果它的类型不为 any；</li><li>构造签名所返回类型的联合。</li></ol></li><li><strong>in 类型保护</strong>：检查一个对象上是否存在一个属性。</li><li><strong>字面量类型保护</strong>：用字面量类型属性来辨析联合结构类型。</li><li><strong>自定义类型保护</strong>：typeof 和 instanceof 类型保护能够满足一般场景，对于一些更加特殊的场景（比如区分不同的普通对象时），可以通过创建用户自定义的类型保护函数，即返回值类型为someArgumentName is SomeType 的函数自定义类型保护。编译器通过类型谓词 someArgumentName is SomeType 得知，如果函数返回 true，则someArgumentName就是SomeType类型。</li></ol><p>自定义类型保护(利用类型谓词 is)：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">const</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> isNumber</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">value</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> value</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> is</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> number</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">let</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> foo</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> | </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">number</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">if</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">isNumber</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">foo</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">)) {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  foo</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">toFixed</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">2</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">);</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">} </span><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">else</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  foo</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">toUpperCase</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">();</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="联合类型-交叉类型" tabindex="-1">联合类型/交叉类型 <a class="header-anchor" href="#联合类型-交叉类型" aria-label="Permalink to &quot;联合类型/交叉类型&quot;">​</a></h2><h3 id="联合类型" tabindex="-1">联合类型 <a class="header-anchor" href="#联合类型" aria-label="Permalink to &quot;联合类型&quot;">​</a></h3><p><strong>联合类型</strong>（<strong>Union Types</strong>）表示取值可以为多种类型中的一种，使用|分隔每个类型。联合类型是对参与类型对应的值取并集。当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里共有的属性或方法。联合类型与其他类型进行运算时，是分别进行元素的。联合类型的变量在被赋值的时候，会根据类型推论的规则推断出其中一个类型。在 TypeScript 中，具有判别属性的类型联合通常称为辨析联合类型。如果使用类型保护风格的检查（==、===、!=、!==）或者使用具有判断性的属性，TypeScript 将认为使用的对象类型一定是拥有特殊字面量的，并且它会自动把类型范围变小。</p><ol><li>在辨析联合类型时，可能需要在判定的情况外添加一个更额外的检查来捕获错误（比如将辨析后收缩的剩余类型（即never）赋值给never类型的变量），如果同时还使用 strictNullChecks 选项，那么应该返回never类型的变量，否则 TypeScript 可能会推断返回值为 undefined。Redux的Action和reducer函数正是使用辨析联合类型的示例，与 TypeScript 一起使用可以有效的防止拼写错误，并且能提高重构和书写文档化代码的能力。</li></ol><p>never 进行详细检查：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Square</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;square&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Rectangle</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;rectangle&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 有人仅仅是添加了 &#39;Circle&#39; 类型</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Circle</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;circle&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">; </span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Shape</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Square</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> | </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Rectangle</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> | </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Circle</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">function</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> area</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Shape</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  if</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> === </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;square&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">    return</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">size</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> * </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">size</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  }</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  if</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> === </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;rectangle&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">    return</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">width</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> * </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">height</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  }</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  const</span><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;"> _exhaustiveCheck</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">never</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">; </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// Error: &#39;Circle&#39; 不能被赋值给 &#39;never&#39;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">function</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> area</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Shape</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  if</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> === </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;square&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">    return</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">size</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> * </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">size</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  }</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  if</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> === </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;rectangle&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">    return</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">width</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> * </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">height</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  }</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  if</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> === </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;circle&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">    return</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> Math</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">PI</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> * </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">radius</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> ** </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">2</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  }</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  const</span><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;"> _exhaustiveCheck</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">never</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">s</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">; </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// ok</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><h3 id="交叉类型" tabindex="-1">交叉类型 <a class="header-anchor" href="#交叉类型" aria-label="Permalink to &quot;交叉类型&quot;">​</a></h3><p><strong>交叉类型</strong>（Intersection Types）是将多个类型叠加合并组成新的类型，是对这些类型对应的值取交集：使用&amp;交叉合并多个非基本类型，新类型包含了所有被合并类型的所有属性；然而对于基本类型之间使用&amp;交叉类型则是取交集 (string &amp; (string | number) = string)。在混入（Mixins）或其他不适合典型面向对象模型的地方存在交叉类型的使用。交叉类型可能出现属性类型冲突，则该属性类型为属性类型的交叉类型（比如，string &amp; number = never），导致组成类型（string或number）均不能赋值给交叉属性类型。此时解决办法时将类型变量断言为any，这样类型变量的属性都是any，赋值就不会报编译错。</p><h2 id="类型别名-声明合并" tabindex="-1">类型别名/声明合并 <a class="header-anchor" href="#类型别名-声明合并" aria-label="Permalink to &quot;类型别名/声明合并&quot;">​</a></h2><h3 id="类型别名" tabindex="-1">类型别名 <a class="header-anchor" href="#类型别名" aria-label="Permalink to &quot;类型别名&quot;">​</a></h3><p><strong>类型别名</strong>：使用 type 创建类型别名，类型别名用来给一个类型起个新名字，类型别名常用于联合类型。</p><h3 id="声明合并" tabindex="-1">声明合并 <a class="header-anchor" href="#声明合并" aria-label="Permalink to &quot;声明合并&quot;">​</a></h3><p><strong>声明合并</strong>：如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型。</p><ol><li>函数声明合并: 使用重载定义多个函数类型。</li><li>接口声明合并：接口中的属性在合并时会简单的合并到一个接口。被合并的接口中的同一属性的类型必须是相同的。接口中方法的合并，与函数声明合并一样。</li><li>类合并：类的合并与接口的合并规则一致。</li><li>除此之外，声明文件中的全局变量类型也可以不冲突的合并起来，比如 declare namespace和declare function声明的同名变量。</li></ol><h2 id="泛型" tabindex="-1">泛型 <a class="header-anchor" href="#泛型" aria-label="Permalink to &quot;泛型&quot;">​</a></h2><p>设计泛型的关键目的是在成员（成员可以是<strong>类的实例成员</strong>、<strong>类的方法</strong>、<strong>函数参数</strong>、<strong>函数返回值</strong>）之间提供有意义的约束。比如约束队列出队类型和入队类型一样，又比如约束反转数组reverse 函数中传入参数类型与函数返回值类型相同。</p><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><ol><li>在函数名后添加了 <code>&lt;T&gt;</code>，其中 T 用来指代任意输入的类型，在后面参数、返回值以及函数体中即可以使用类型T。调用时可以在函数名后手动指定，或者让类型推论自动推断出来。</li><li>仅使用一次的泛型并不比一个类型断言来的安全。<code>declare function some&lt;T&gt;(name: string): T</code> 中泛型 T 只在函数返回值中使用，它相当于类型断言 <code>declare function some(name: string): any; some(&#39;something&#39;) as TypeOfParamsSomething;</code> 比如，一个用于加载 json 返回值函数，它返回任何传入类型的Promise。</li></ol><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">const</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> getJson</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = &lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">config</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  url</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">; </span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  headers</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">?: {</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">    [</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">key</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  } </span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}): </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Promise</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  const</span><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;"> fetchConfig</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">    method:</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> &#39;GET&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">    Accept:</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> &#39;application/json&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,</span></span>
<span class="line"><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">    &#39;Content-type&#39;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">:</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> &#39;application/json&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">    ...(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">config</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">headers</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> || {})</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  };</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  return</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> fetch</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">config</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">url</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">fetchConfig</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">).</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">then</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;((</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">rsp</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> rsp</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">json</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">());</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ol start="3"><li>定义泛型的时候，可以一次定义多个类型参数 <code>&lt;T, K, U&gt;</code>。如果在参数里不止一个泛型，则应该使用一个更语义化名称，如 TKey 和 TValue （通常情况下，以 T 作为泛型的前缀，在其他语言如 C++ 里，也被称为模板）。</li><li>在函数内部使用泛型变量（被赋予泛型类型的变量）的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法。此时，可以对泛型进行约束，只允许该函数传入那些包含对应属性的变量，即泛型约束。比如T extends SomeType，SomeType是包含属性的类型。而且如果调用该函数传入的对应参数不包含对应属性，那么在编译阶段就会报错。多个泛型类型参数之间也可以互相约束 <code>&lt;T extends U, U&gt;</code>，即要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。</li><li>泛型接口：可以使用含有泛型的接口来定义函数的形状，注意，在使用泛型接口的时候做类型注解时，需要确定定义泛型的类型。</li><li>泛型类：与泛型接口类似，泛型也可以用于类的类型定义中。</li></ol><p>TypeScript 2.3+ 可以为泛型中的类型参数指定默认类型（<code>&lt;T = SomeType&gt;</code>）。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p><h3 id="配合-axios-使用" tabindex="-1">配合 axios 使用 <a class="header-anchor" href="#配合-axios-使用" aria-label="Permalink to &quot;配合 axios 使用&quot;">​</a></h3><p>通常情况下会把后端返回数据格式单独放入一个接口 interface 里：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> ResponseData</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  /**</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">   * 状态码</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">   * </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">@type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> { number }</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">   */</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  code</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">number</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  /**</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">   * 数据</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">   * </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">@type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> { T }</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">   */</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  result</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  /**</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">   * 消息</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">   * </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">@type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> { string }</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">   */</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  message</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">function</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> getUser</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  return</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> axios</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">get</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">ResponseData</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;&gt;(</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;/some-path&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">)</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">    .</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">then</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">((</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">res</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> res</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">data</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">)</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">    .</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">catch</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">err</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> =&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> console</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">error</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">err</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">));</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> User</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  name</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  age</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">number</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">async</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> function</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> test</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">() {</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  // user 被推断出为</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  // {</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  //   code: number,</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  //   result: { name: string; age: number },</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  //   message: string</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  // }</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  const</span><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;"> user</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">await</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> getUser</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">User</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;();</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><h3 id="内置泛型" tabindex="-1">内置泛型 <a class="header-anchor" href="#内置泛型" aria-label="Permalink to &quot;内置泛型&quot;">​</a></h3><p>可选泛型 <code>Partial&lt;T&gt;</code> 将类型T所有的属性设置为可选的。它的返回类型表示输入类型的所有子类型。</p><p>只读泛型 <code>Readonly&lt;T&gt;</code> 将类型T所有的浅属性设置为只读 readonly，也就是说构造出的类型的属性不能被再次赋值。</p><p>键值泛型 <code>Record&lt;K, T&gt;</code> 构造一个类型，其属性名的类型为 K，属性值的类型为 T。可用来将某个类型K的属性映射到另一个类型T上。</p><p>挑选属性泛型 <code>Pick&lt;T, K&gt;</code> 从类型 T 中挑选部分属性 K 来构造类型。</p><p>剔除属性泛型 <code>Exclude&lt;T, U&gt;</code> 从类型 T 中剔除所有可以赋值给 U 的属性来构造新类型。</p><p>提取属性泛型 <code>Extract&lt;T, U&gt;</code> 从类型 T 中提取所有可以赋值给 U 的类型来构造新类型。</p><p><code>Omit&lt;T, K&gt;</code> 通过从 T 中选取所有属性然后删除传入的属性 K 来构造新类型。</p><p>剔除空属性泛型 <code>NonNullable&lt;T&gt;</code> 从类型 T 中剔除 null 和 undefined来构造新类型。</p><p>返回值类型泛型 <code>ReturnType&lt;T&gt;</code> 由函数类型 T 的返回值类型构造一个类型。</p><p>实例泛型 <code>InstanceType&lt;T&gt;</code> 由构造函数类型 T 的实例类型构造一个类型。</p><p>必须泛型 <code>Required&lt;T&gt;</code> 构造一个类型，使类型 T 的所有属性为必须 required。</p><p><code>Parameters&lt;T&gt;</code> 构造一个关于函数类型 T 的参数类型的元组类型。</p><p><code>ConstructorParameters&lt;T&gt;</code> 提取构造函数类型的所有参数类型，它会生成构造函数所具有的所有参数类型的元组类型（如果 T 不是函数，则不返回）。</p><p><code>ThisType&lt;T&gt;</code> 通过 ThisType 可以在对象字面量中键入 this，并提供通过上下文类型控制 this 类型的便捷方式。它只有在--noImplicitThis 的选项为true才有效。在对象字面量方法中的 this 类型，将由以下决定：</p><ol><li>如果这个方法显式指定了 this 参数，那么 this 具有该参数的类型。</li><li>否则，如果方法由带 this 参数的签名进行上下文键入，那么 this 具有该参数的类型。</li><li>否则，如果 --noImplicitThis 选项已经启用，并且对象字面量中包含由 <code>ThisType&lt;T&gt;</code> 键入的上下文类型，那么 this 的类型为 T。</li><li>否则，如果 --noImplicitThis 选项已经启用，并且对象字面量中不包含由 <code>ThisType&lt;T&gt;</code> 键入的上下文类型，那么 this 的类型为该上下文类型。</li><li>否则，如果 --noImplicitThis 选项已经启用，this 具有该对象字面量的类型。</li><li>否则，this 的类型为 any。</li></ol><p>通过 API 转换参数的形式来生成 this 的值的情景下，可以通过创建一个新的 <code>ThisType&lt;T&gt;</code> 标记接口，可用于在上下文中表明转换后的类型。尤其是当字面量中的上下文类型为 <code>ThisType&lt;T&gt;</code> 或者是包含 <code>ThisType&lt;T&gt;</code> 的交集时，显得尤为有效，对象字面量方法中 this 的类型即为 T。<code>ThisType&lt;T&gt;</code> 的接口，在 lib.d.ts 只是被声明为空的接口，除了可以在对象字面量上下文中可以被识别以外，该接口的作用等同于任意空接口。</p><h2 id="索引类型-映射类型" tabindex="-1">索引类型/映射类型 <a class="header-anchor" href="#索引类型-映射类型" aria-label="Permalink to &quot;索引类型/映射类型&quot;">​</a></h2><h3 id="索引类型" tabindex="-1">索引类型 <a class="header-anchor" href="#索引类型" aria-label="Permalink to &quot;索引类型&quot;">​</a></h3><p><strong>索引类型</strong>（<strong>Index Types</strong>）的使用让编译器能够检查使用了动态属性名的类型。</p><ol><li><strong>索引类型的查询操作符为 <code>keyof T</code></strong>。对于任何类型查询操作符 <code>keyof T</code>，假设 T 是一个类型，那么 <code>keyof T</code> 产生的类型是 T 的属性名称字符串字面量类型构成的联合类型。和直接使用联合类型的区别在于，可以动态的根据类型T的改变自动改变。索引类型的查询操作符 keyof T：</li></ol><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Person</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  name</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  age</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">number</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  address</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> PersonKeyUnion</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">keyof</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">; </span><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// name | age | address;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="2"><li><strong>索引访问操作符 <code>T[K]</code></strong>，表示类型T 的属性 K 的类型。可以在普通的上下文中使用 <code>T[K]</code>，只要确保类型变量 <code>K extends keyof T</code>。</li><li><strong>索引签名</strong>：TypeScript 的索引签名必须是 string 或者 number，此外 Symbol 也是有效的。索引签名的名称（如：<code>{ [key: string]: SomeType}</code> 里的 key）除了可读性外，并没有任何意义。声明一个索引签名时，所有明确的成员都必须符合索引签名。索引签名[key in UnionType]可以通过映射类型来使索引字符串k为联合类型 UnionType 中的一员。number类型的索引也支持：<code>{ [index: number]: SomeType }</code>。对于对象类型的索引签名，JavaScript 会隐式调用 toString 方法，而在 TypeScript需要显式调用toString，否则会抛出错误。<strong>尽量不要把字符串索引签名与确定属性名称混合使用，因为如果属性名称中有拼写错误将不会被捕获到，应该将索引签名在一个确定属性名称里嵌套</strong>。嵌套索引签名：<div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">interface</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> NestedCSS</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  color</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">?: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  nest</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">?: {</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">    [</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">selector</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">NestedCSS</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  };</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol><li>如果类型 T 带有字符串索引签名，那么 keyof T 为 string | number 类型。因为可以同时拥有string 和 number 类型的索引签名。</li><li>如果类型 T 带有数字索引签名，那么 keyof T 为 number 类型。</li><li>如果类型 T 带有索引签名，那么 T[K] 为索引签名的类型。</li></ol></li></ol><h3 id="映射类型" tabindex="-1">映射类型 <a class="header-anchor" href="#映射类型" aria-label="Permalink to &quot;映射类型&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 将原有类型所有属性转为可选的</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Partial</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; = {</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  [</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">P</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> in</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> keyOf</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">P</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">];</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 将原有类型所有属性转为只读的</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Readonly</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; = {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  readonly</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> [</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">P</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> in</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> keyOf</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">P</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">];</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 从原来类型中选取部分属性形成新类型</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Pick</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">K</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> extends</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> keyof</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; = {</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  [</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">P</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> in</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> K</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">P</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">];</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 新类型是 K 为属性，T 类型为值得类型</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Recode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">K</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> extends</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; = {</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  [</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">P</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> in</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> K</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>映射类型</strong>（<strong>Mapped Types</strong>）可以基于旧类型创建新类型。比如将现有类型转换为可选的或将现有类型转换为只读的，其实现中[P in keyof T]类型变量 P会把字符串字面量联合类型keyof T 的每个字符串都映射为属性。Readonly，Partial 和 Pick 是同态的，即属性列表是 keyof T 且结果类型是 T[P] 的变体，因为这类转换是同态的，映射只作用于 T 的属性而没有其他的。编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符，但 Record是非同态的，因为 Record 并不需要输入类型来拷贝属性，非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。</p><p>由映射类型进行推断，即拆包（注意这个拆包推断只适用于同态的映射类型。如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数）：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">function</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> unproxify</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">t</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Proxify</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;): </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  let</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> result</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = {} </span><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">as</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  for</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">const</span><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;"> k</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> in</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> t</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">    result</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">k</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">] = </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">t</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">k</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">].</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">get</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">()</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  }</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  return</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> result</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">let</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> originalProps</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">unproxify</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">proxyProps</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="条件类型-this-类型" tabindex="-1">条件类型/This 类型 <a class="header-anchor" href="#条件类型-this-类型" aria-label="Permalink to &quot;条件类型/This 类型&quot;">​</a></h2><h3 id="条件类型" tabindex="-1">条件类型 <a class="header-anchor" href="#条件类型" aria-label="Permalink to &quot;条件类型&quot;">​</a></h3><p><strong>条件类型</strong>（<strong>Conditional Types</strong>）用于表达非均匀类型映射（non-uniform type mapping），能够根据类型兼容关系（即条件）从两个类型中选出一个。T extends U ? X : Y语义类似于三目运算符，若 T 是 U 的子类型，则为 X 类型，否则就是 Y 类型。另外，还有一种情况是条件的真假无法确定（无法确定 T 是不是 U 的子类型），此时为 X | Y 类型。另外，如果 T 或 U 含有类型变量，就要等到类型变量都有对应的具体类型后才能得出条件类型的结果。</p><p>可分配条件类型（distributive conditional type）中被检查的类型是个裸类型参数（naked type parameter）。其特殊之处在于满足分配律，即(A | B | C) extends U ? X : Y等价于(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)。此外，在 T extends U ? X : Y 中，X 中出现的 T 都具有 U 类型约束。</p><p>在条件类型的 extends 子句中，可以通过 infer 声明引入一个将被推断的类型变量。</p><p>TypeScript 内置的常用的条件类型有：</p><div class="language-typeScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typeScript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 从 T 中去掉属于 U 的子类型的部分</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Exclude</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">U</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; = </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> extends</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> U</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> ? </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">never</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> : </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 从 T 中筛选出属于 U 的子类型的部分</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Extract</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">U</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; = </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> extends</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> U</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> ? </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> : </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">never</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 取出函数类型的返回类型：如果存在重载，就取最后一个签名（按照惯例，最后一个通常是宽泛的）进行推断</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> ReturnType</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> extends</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (...</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">args</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; = </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> extends</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (...</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">args</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> infer</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> R</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> ? </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">R</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> : </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 取出构造函数类型的实例类型</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> InstanceType</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> extends</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> abstract</span><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;"> new</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (...</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">args</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; = </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> extends</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> abstract</span><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;"> new</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (...</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">args</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> infer</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> R</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> ? </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">R</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> : </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="this-类型" tabindex="-1">This 类型 <a class="header-anchor" href="#this-类型" aria-label="Permalink to &quot;This 类型&quot;">​</a></h2><p><strong>This 类型</strong>（<strong>This Types</strong>）表示所属类或接口的子类型（称之为有界多态性 F-bounded polymorphism）。具体地，TypeScript 中的 This 类型分为两类：</p><ol><li>类/接口（的成员方法）中的 this 类型；JavaScript运行时 this 指向当前类实例或其子类实例，即this 的类型并不是固定的，取决于其调用上下文。而this 类型表现为所属类/接口的子类型，即this 类型就是 this 值的类型，其实现原理，就是把类/接口看作是具有隐式类型参数 this 的泛型，并加上其所在类/接口相关的类型约束。具体地，this 类型在实现上相当于 <code>A&lt;this extends A&lt;A&gt;&gt;</code>，类中 this 值的类型就是泛型参数 this。除了当前类/接口的上下文，this 的类型就是 <code>A&lt;this: A&gt;</code>，类型兼容性等与泛型一致。所以，this 类型就像一个带有类派生关系约束的隐式类型参数。</li><li>普通函数中的 this 类型。不同于类或接口中的 this 类型通常隐式发挥作用，函数中的 this 类型大都通过现式声明来约束函数体中 this 值的类型。把 this 显式地作为函数的（第一个）参数，从而限定其类型，像普通参数一样进行类型检查。特殊地，匿名函数（lambda）的 this 无法手动限定其类型。</li></ol><p><strong>This 类型的应用场景</strong>：</p><ol><li>流式接口：this 类型让流式接口（fluent interface）变得很容易描述。所谓的流式接口（设计层面），可以简单理解为链式调用（实现层面）。简言之，流式接口是 OOP 中的一种 API 设计方式，通过链式方法调用让源码具有可读性。</li><li>描述this的类型：普通函数中的 this 类型允许我们像描述普通参数一样限定 this 的类型，尤其是会调用函数场景。</li><li>追踪上下文类型：有了 this 类型，bind、call、apply 等场景也能正确维持类型约束，要求当前函数 this 与传入的目标对象类型一致，让其中的错误暴露出来（需要开启 strictBindCallApply 选项）。</li></ol><h2 id="从-javascript-迁移" tabindex="-1">从 JavaScript 迁移 <a class="header-anchor" href="#从-javascript-迁移" aria-label="Permalink to &quot;从 JavaScript 迁移&quot;">​</a></h2><p>所有的 JavaScript 代码都是有效的 TypeScript 代码。这意味着，如果让 TypeScript 编译器编译 TypeScript 里的 JavaScript 代码，编译后的结果将会与原始的 JavaScript 代码一模一样。也就是说，把文件扩展名从 .js 改成 .ts 将不会造成任何负面的影响。一般来说，将 JavaScript 代码迁移至 TypeScript 包括以下步骤：</p><ol><li>添加一个 tsconfig.json 文件；</li><li>把文件扩展名从 .js 改成 .ts，开始使用 any 来减少错误；使用any来减少错误是危险的，但是它允许将注意力转移到新 TypeScript 代码错误上，因为此时的重点是在逐步更新旧代码库的同时，用 TypeScript 编写新代码。当进行下一步前，最好要留下 // TODO 的注释。</li><li>开始在 TypeScript 中写代码，尽可能的减少 any 的使用；</li><li>回到旧代码，开始添加类型注解，并修复已识别的错误；</li><li>为第三方 JavaScript 代码定义环境声明。可以创建一个针对于特定库的声明文件（.d.ts）或去DefinitelyTyped 仓库中寻找是否有对应的声明文件。</li></ol><p>在 TypeScript 中，甚至可以允许导入任何文件（.css/.html），只需要在 global.d.ts 中declare <code>module &#39;*.css&#39;</code> 或 <code>declare module &#39;*.html&#39;</code>。</p><h2 id="异常处理和错误提示" tabindex="-1">异常处理和错误提示 <a class="header-anchor" href="#异常处理和错误提示" aria-label="Permalink to &quot;异常处理和错误提示&quot;">​</a></h2><p>内置错误类型包括Error类和以下继承自Error类的：</p><ol><li>RangeError：当数字类型变量或者参数超出其有效范围时，出现 RangeError 的错误提示。</li><li>ReferenceError：当引用无效时，会出现 ReferenceError 的错误提示。</li><li>SyntaxError：当解析无效 JavaScript 代码时，会出现 SyntaxError 的错误提示。</li><li>TypeError：变量或者参数不是有效类型时，会出现 TypeError 的错误提示。</li><li>URIError：当传入无效参数至 encodeURI() 和 decodeURI() 时，会出现 URIError 的错误提示。</li></ol><p>除非想要使用非常通用（try/catch）的方式处理错误，否则不要抛出错误。抛出错误时使用内置错误类型能自动跟踪堆栈的属性构建以及生成位置。相比之下，原始字符串会导致极差的调试体验，并且在分析日志时，将会变得错综复杂。</p><p>TypeScript 错误信息提示分为两类：简洁和详细。简洁的错误信息包括编译器描述的错误号以及对应基本信息。详细的错误信息是为了指导使用者知道为什么一些错误会发生。IDE 通常会在详细的错误提示之后显示简洁版本。常见错误代码：</p><ol><li>TS2304：Cannot find name “”；可能在使用第三方的库，但是并没有 declare 的声明。需要明确的声明使用的任何变量。</li><li>TS2307：Cannot find module “”；可能把第三方的库作为模块使用，但没有对应的环境声明文件。</li><li>TS1148：Cannot compile modules unless the &#39;--module&#39; flag provided；</li><li>捕获不能有类型注解的简短变量：比如try...catch中的e，需要在catch块内对e使用类型保护。</li><li>接口 ElementClass 不能同时扩展类型别名 Component 和 Component：当在编译上下文中同时含有两个 react.d.ts（@types/react/index.d.ts）会发生。 <ol><li>删除 node_modules 和任何 package-lock（或者 yarn lock），然后再一次 npm install；</li><li>如果这不能工作，查找无效的模块（所使用的所有用到了 react.d.ts 模块应该作为 peerDependency 而不是作为 dependency 使用），并且把这个报告给相关模块。</li></ol></li></ol><h2 id="jsx" tabindex="-1">JSX <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;JSX&quot;">​</a></h2><p><strong>JSX的规则</strong>：</p><ol><li>只能返回一个根元素：多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹，因为JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。</li><li>JSX 要求标签必须正确闭合。</li><li>使用驼峰式命名法给大部分属性命名：JSX 最终会被转化为 JavaScript，而 JSX 中的属性也会变成 JavaScript 对象中的键值对。在组件中，经常会遇到需要用变量的方式读取这些属性。但 JavaScript 对变量的命名有限制。例如，变量名称不能包含 - 符号或者像 class 这样的保留字。但是，由于历史原因，aria-* 和 data-* 属性应该以带 - 符号的 HTML 格式书写。</li></ol><p>TypeScript 支持 JSX 转换和代码分析。JSX允许用户在 JavaScript 中书写类似于 HTML 的视图，因此可以：</p><ol><li>使用相同代码，既能检查JavaScript，同时能检查 HTML 视图层部分。</li><li>让视图层了解运行时的上下文（加强传统 MVC 中的控制器与视图连接）。</li><li>复用 JavaScript 设计模式维护 HTML 部分，例如用Array.prototype.map 创建新元素。</li></ol><p>这能够减少错误的可能性，并且能增加用户界面的可维护性。JSX 的主要消费者是React。使用TypeScript开始开发 React 的应用的重点：</p><ol><li>使用文件后缀 .tsx（替代 .ts）；</li><li>在 tsconfig.json 配置文件的 compilerOptions 里设置选项 &quot;jsx&quot;: &quot;react&quot;；</li><li>在项目里为 JSX 和 React 安装声明文件：npm i -D @types/react @types/react-dom；</li><li>导入 react 到.tsx 文件（import * as React from &#39;react&#39;）。</li></ol><p>React 不但能渲染 HTML 标签（首字母小写，原理是<code>React.createElement(&#39;div&#39;)</code>）也能渲染 React 组件（首字母大写，原理是 <code>React.createElement(MyComponent)</code>）。</p><ol><li>HTML 标签的类型是 <code>JSX.IntrinsicElements.div</code>。</li><li>函数式组件类型是 <code>React.FunctionComponent</code>。</li><li>类组件类型是 <code>React.Component&lt;Props,State&gt;</code>。</li><li>组件实例的类型是 <code>React.ReactElement&lt;T&gt;</code> 。</li><li>可渲染内容的类型是类型 <code>React.ReactNode</code>。</li><li>对于泛型组件，组件内部定义 <code>&lt;T&gt;</code> 时，需要在泛型参数里使用 extends 即 <code>&lt;T extends SomeType&gt;</code> 来提示编译器，这是个泛型。</li></ol><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 一个泛型组件</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">type</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> SelectProps</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; = { </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">items</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[] };</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">class</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> Select</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">extends</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> React</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Component</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">SelectProps</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;, </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 使用</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">const</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> Form</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = () </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> &lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Select</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">string</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt; </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">items</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">={[</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;a&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;b&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">]} /&gt;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="7"><li>ref的类型应该使用 ref 和 null 的联合类型。</li></ol><p>TypeScript 使得能够以类型安全的方式，在 React 中使用 JSX 之外的其他东西。可自定义的点如下（适用于高级 UI 框架的作者）：</p><ol><li>可以使用 &quot;jsx&quot;:&quot;preserve&quot; 选项来禁用 React 的样式触发。这意味着，JSX 将按原样被触发，然后可以使用自定义转化器来转化 JSX 部分。</li><li>使用 JSX 全局模块： <ol><li>可以通过定制 JSX.IntrinsicElements 的接口成员来控制哪些 HTML 标签是可用的，以及如何对其进行类型检查；</li><li>当在组件中使用时： <ol><li>可以通过自定义默认的 <code>interface ElementClass extends React.Component&lt;any, any&gt; { }</code> 声明文件来控制哪个 class 必须由组件继承；</li><li>可以通过自定义 declare module JSX { interface ElementAttributesProperty { props: {} } } 声明文件来控制使用的哪个属性（property）来检查特性（attribute）（默认是 props）。</li></ol></li></ol></li><li>通过 <code>--jsxFactory &lt;JSX factory Name&gt;</code> 与 <code>--jsx react</code>，能不同于默认 React 的方式使用 JSX 工厂函数（默认工厂函数名称是createElement）。</li></ol><h2 id="typescript-编译原理" tabindex="-1">TypeScript 编译原理 <a class="header-anchor" href="#typescript-编译原理" aria-label="Permalink to &quot;TypeScript 编译原理&quot;">​</a></h2><p>TypeScript 编译器源文件位于 src/compiler 目录下，关键部分包括：</p><ol><li><p><strong>Scanner 扫描器</strong>（scanner.ts）：SourceCode（源码）转化为Token流；解析器根据需要使用 initializeState 函数准备该扫描器。为避免重复创建扫描器造成的开销，parser.ts 中创建单例扫描器。调用 scan 后，扫描器更新其局部状态（扫描位置，当前 token 详情等）。扫描器提供工具函数获取当前扫描器状态，scanner.getStartPos()获取即将扫描的token的开始位置。即便 TypeScript 解析器有单例扫描器，仍可以使用ts.createScanner 创建独立的扫描器，然后用 setText/setTextPos 随意扫描文件的不同位置。</p></li><li><p><strong>Parser 解析器</strong>（parser.ts）：控制扫描器将源码转化为Token 流，再转化为AST（抽象语法树）；Node节点是抽象语法树（AST） 的基本构造块。语法上，通常 Node 表示非末端（non-terminals）节点。但是，有些末端节点，如：标识符和字面量也会保留在树中。AST 节点文档由两个关键部分构成，一是节点的 SyntaxKind 常量枚举（const enum），用于标识 AST 中的类型；二是其接口，即实例化 AST 时节点提供的 API。工具函数 ts.forEachChild，可以用来访问 AST 任一节点的所有子节点。interface Node 的关键成员：</p><ol><li>TextRange 标识该节点在源文件中的起止位置。</li><li>parent?: Node 当前节点（在 AST 中）的父节点。</li><li>标志（flags）和修饰符（modifiers）。</li></ol><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 常量枚举</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 但编译时需要使用 --preserveConstEnums 编译标志，以便枚举在运行时仍可用。</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">export</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> const</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> enum</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> SyntaxKind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  Unknown</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  EndOfFileToken</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,</span></span>
<span class="line"><span style="--shiki-light:#0070C1;--shiki-dark:#4FC1FF;">  SingleLineCommentTrivia</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">,</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">  // ... 更多</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 将枚举成员转化为可读的字符串</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">export</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> function</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> syntaxKindToName</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">ts</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">SyntaxKind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  return</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">ts</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">).</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">SyntaxKind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">];</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 访问 AST 任一节点的所有子节点</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 该函数不会为所有子节点调用 visitNode（例如：SyntaxKind.SemicolonToken）。</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">export</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> function</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> forEachChild</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;(</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">  cbNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">  cbNodeArray</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">?: (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">nodes</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">[]) </span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">=&gt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;"> T</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">): </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">T</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  if</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (!</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">    return</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  }</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">  switch</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">    case</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> SyntaxKind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">BinaryExpression</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">:</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">        return</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> visitNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">cbNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, (&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">BinaryExpression</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">).</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">left</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) ||</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">            visitNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">cbNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, (&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">BinaryExpression</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">).</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">operatorToken</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) ||</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">            visitNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">cbNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, (&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">BinaryExpression</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">).</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">right</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">);</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">    case</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> SyntaxKind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">IfStatement</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">:</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">        return</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> visitNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">cbNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, (&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">IfStatement</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">).</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">expression</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) ||</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">            visitNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">cbNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, (&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">IfStatement</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">).</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">thenStatement</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) ||</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">            visitNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">cbNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, (&lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">IfStatement</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">).</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">elseStatement</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">    // .... 更多</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">// 获得某 AST 节点的所有子节点</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">function</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> printAllChildren</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">ts</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">depth</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">0</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  console</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">log</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">    new</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> Array</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">depth</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> + </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">).</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">join</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">&#39;----&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">), </span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">    ts</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">syntaxKindToName</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">kind</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">), </span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">    node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">pos</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">    node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">end</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">  );</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  depth</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> += </span><span style="--shiki-light:#098658;--shiki-dark:#B5CEA8;">1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">getChildren</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">().</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">forEach</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">c</span><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;"> =&gt;</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> printAllChildren</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">c</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">depth</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">));</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br></div></div><p>解析器实现原理是单例模式（其原因类似扫描器，如果能重新初始化就不重新构建）。实际实现成 namespace Parser，包含解析器的各种状态变量和单例扫描器（const scanner）。该扫描器由解析器函数管理。解析器由程序间接驱动，简化的调用栈：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">程序</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  CompilerHost</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">getSourceFile</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">    (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">全局函数</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> parser</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">ts</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">).</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">createSourceFile</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">      Parser</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">parseSourceFile</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>parseSourceFile 不仅准备好解析器的状态，还调用 initializeState 准备好扫描器的状态。然后使用 parseSourceFileWorker 继续解析源代码。</p><p>parseSourceFileWorker函数先创建一个 SourceFile AST 节点，然后从 parseStatements 函数开始解析源代码。一旦返回结果，就用额外信息（例如 nodeCount, identifierCount等） 完善 SourceFile 节点。parseStatements根据扫描器返回的当前 token 来切换（调用相应的 parseXXX 函数），例如：如果当前 token 是一个 SemicolonToken（分号标记），就会调用 parseEmptyStatement 为空语句创建一个 AST 节点。</p><p>解析器有一系列 parseXXX 函数用来创建相应类型为XXX的节点，通常在相应类型的节点出现时被（其他解析器函数）调用。该过程的典型示例是解析空语句（例如 ;;;;;;）时要用的 parseEmptyStatement() 函数，其中包括 3 个关键函数 createNode, parseExpected 和 finishNode：</p><ol><li>createNode：解析器函数 function createNode(kind: SyntaxKind, pos?: number): Node 负责创建节点，设置传入的 SyntaxKind（语法类别），和初始位置（默认使用当前扫描器状态提供的位置信息）。</li><li>parseExpected：解析器的 parseExpected 函数 function parseExpected(kind: SyntaxKind, diagnosticMessage?: DiagnosticMessage): boolean 会检查解析器状态中的当前 token 是否与指定的 SyntaxKind 匹配。如果不匹配，则会向传入的 diagnosticMessage（诊断消息）报告，未传入则创建某种通用形式 xxx expected。该函数内部用 parseErrorAtPosition 函数（使用扫描位置）提供良好的错误报告。</li><li>finishNode：解析器的 finishNode 函数 <code>function finishNode&lt;T extends Node&gt;(node: T, end?: number): T</code> 设置节点的 end 位置，并添加一些有用的信息，例如上下文标志（parserContextFlags）以及解析该节点前出现的错误（如果有错的话，就不能在增量解析中重用此 AST 节点）。</li></ol></li><li><p><strong>Binder 绑定器</strong>（binder.ts）：AST转化为Symbols（符号）；大多数的 JavaScript 转译器（transpiler）相比TypeScript 几乎没提供代码分析的方法，缺失TypeScript 的语义系统。为了协助（检查器执行）类型检查，绑定器将源码的各部分连接成一个相关的类型系统，供检查器使用。绑定器的主要职责是创建符号（Symbols）。符号将 AST 中的声明节点与相同实体的其他声明相连。符号是绑定的结果，是 TypeScript 语义系统的主要构造块。符号的构造器定义在 core.ts（绑定器实际上通过 objectAllocator.getSymbolConstructor 来获取构造器）。SymbolFlags 符号标志是个标志枚举，用于识别额外的符号类别（例如：变量作用域标志 FunctionScopedVariable 或 BlockScopedVariable 等。实际上，绑定器被检查器在内部调用，而检查器又被程序调用。简化的调用栈如下：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">program</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">getTypeChecker</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  ts</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">createTypeChecker</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">（</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">检查器中</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">）-&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">    initializeTypeChecker</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">（</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">检查器中</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">） -&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">        for</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> each</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> SourceFile</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> `ts.bindSourceFile`</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">（</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">绑定器中</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">）</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">        // followed by</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">        for</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> each</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> SourceFile</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> `ts.mergeSymbolTable`</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">（</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">检查器中</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>bindSourceFile 和 mergeSymbolTable 是两个关键的绑定器函数：</p><ol><li>bindSourceFile：主要是检查 file.locals 是否定义，如果没有则交给（本地函数） bind 来处理。注意：locals 定义在节点上，其类型为 SymbolTable。SourceFile 也是一个节点（事实上是 AST 中的根节点）。TypeScript 编译器大量使用本地函数。本地函数很可能使用来自父函数的变量（通过闭包捕获）。</li><li>bind 是 bindSourceFile 中的一个本地函数，它或它调用的函数会设置 symbolCount 和 classifiableNames 等状态，然后将其存在返回的 SourceFile 中。bind 能处理任一节点（不只是 SourceFile），它做的第一件事是分配 node.parent（如果 parent 变量已设置，绑定器在 bindChildren 函数的处理中仍会再次设置），然后交给 bindWorker。最后调用 bindChildren进行递归绑定（该函数简单地将绑定器的状态（如：parent）存入函数本地变量中，接着在每个子节点上调用 bind，然后再将状态转存回绑定器中）。</li><li>bindWorker函数依据 node.kind（SyntaxKind类型）进行切换，并将工作委托给合适的 bindXXX 函数（通用的模式和工具函数，也定义在binder.ts中）。例如：如果该节点是 SourceFile 则（最终且仅当节点是外部文件模块时）调用 bindAnonymousDeclaration。常用的有 createSymbol 函数，它简单地更新 symbolCount（一个 bindSourceFile 的本地变量），并使用指定的参数创建符号。</li></ol><p>addDeclarationToSymbol函数用于绑定 SourceFile 节点到源文件符号（外部模块的情况下）。创建一个从 AST 节点到符号的链接（node.symbol），并将节点添加为该符号的一个声明（interface Declaration）。</p><p>AST 的节点可以被当作容器。这决定了节点及相关符号的 SymbolTables 的类别。容器是个抽象概念（没有相关的数据结构），由ContainerFlags 枚举等决定。函数 getContainerFlags（位于 binder.ts） 驱动此标志，该函数只在绑定器函数 bindChildren 中调用，会根据 getContainerFlags 的运行结果将节点设为 container 和（或） blockScopedContainer。</p><p>符号表（SymbolTable）是 Map 实现的，符号表通过绑定进行初始化。编译器中实用的符号表，节点上是locals?: SymbolTable；符号上是members?: SymbolTable和exports?: SymbolTable。符号表使用符号来填充，主要是通过调用declareSymbol( symbolTable: SymbolTable, parent: Symbol, node: Declaration, includes: SymbolFlags, excludes: SymbolFlags ): Symbol来进行。</p><p><strong>绑定器中的绑定错误</strong>被添加到源文件的 bindDiagnostics 列表中。</p></li><li><p><strong>Checker 检查器</strong>（checker.ts）：利用AST +符号进行类型验证；符号和 AST 是检查器用来验证源代码语义的。检查器是由程序（program）初始化。检查器是整个编译器中最大的部分。检查器的相关调用栈如下：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">program</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">getTypeChecker</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  ts</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">createTypeChecker</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">（</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">检查器中</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">）-&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">    initializeTypeChecker</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">（</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">检查器中</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">） -&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">        for</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> each</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> SourceFile</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> `ts.bindSourceFile`</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">（</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">绑定器中</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">）</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">        // 接着</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">        for</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> each</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> SourceFile</span><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;"> `ts.mergeSymbolTable`</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">（</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">检查器中</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>真正的类型检查会在调用getDiagnostics时才发生。该函数被调用时（比如由 Program.emit 请求），检查器返回一个EmitResolver（由程序调用检查器的 getEmitResolver 函数得到），EmitResolver 是 createTypeChecker 的一个本地函数的集合。</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">program</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">emit</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">  emitWorker</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">program</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> local</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) -&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">    createTypeChecker</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">getEmitResolver</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">        // 第一次调用下面的几个 createTypeChecker 的本地函数</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">        call</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> getDiagnostics</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">            getDiagnosticsWorker</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">                checkSourceFile</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">        // 接着</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C586C0;">        return</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> resolver</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#6A9955;">        // 通过对本地函数 createResolver() 的调用，resolver 已在 createTypeChecker 中初始化。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>全局命名空间合并由initializeTypeChecker 中初始化全局符号表，基本上是将所有的 global 符号合并到 let globals: SymbolTable = {} 符号表中（位于 createTypeChecker 中）。 mergeSymbolTable 主要调用 mergeSymbol 函数。 检查器使用本地的 error 函数报告错误：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">function</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;"> error</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">location</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">Node</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">message</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">DiagnosticMessage</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">arg0</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">?: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">arg1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">?: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">arg2</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">?: </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">any</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">): </span><span style="--shiki-light:#267F99;--shiki-dark:#4EC9B0;">void</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#569CD6;">  let</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> diagnostic</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> = </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">location</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">    ? </span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">createDiagnosticForNode</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">location</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">message</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">arg0</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">arg1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">arg2</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">)</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">    : </span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">createCompilerDiagnostic</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">message</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">arg0</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">arg1</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">arg2</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">);</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">  diagnostics</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">add</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">diagnostic</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">);</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><p><strong>Emitter 发射器</strong>（emitter.ts）：检查器 + AST输出JavaScript代码。程序Program 提供emit 函数，它主要将功能委托给 emitter.ts中的 function emitFiles(resolver: EmitResolver, host: EmitHost, targetSourceFile?: SourceFile): EmitResult 函数。emitWorker给发射器提供一个 EmitResolver。 EmitResolver 由程序的 TypeChecker 提供，是来自 createChecker 的本地函数的子集。emitJavaScript函数主要设置了一批本地变量和函数（这些函数构成 emitter.ts 的大部分内容），接着交给本地函数 emitSourceFile 发射文本，其中initializeEmitterWithSourceMaps函数是emitJavaScript 的本地函数，initalizeEmitterWithSourceMap 的底部覆盖了部分已定义的本地函数，意味着大部分的发射器代码不关心 SourceMap，它们以相同的方式使用这些（带或不带 SourceMap 的）本地函数。emitSourceFile 函数设置 currentSourceFile 然后交给本地函数 emit 去处理。emit函数处理注释和实际 JavaScript 的发射。实际 JavaScript 的发射是 emitJavaScriptWorker 函数的工作。emitJavaScriptWorker通过简单地调用相应的 emitXXX 函数来完成递归。发射器相关调用栈：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes light-plus dark-plus vp-code"><code><span class="line"><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">Program</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">emit</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">  `emitWorker`</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> （</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">在</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> program</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">ts</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> 中的</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> createProgram</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">） -&gt;</span></span>
<span class="line"><span style="--shiki-light:#A31515;--shiki-dark:#CE9178;">    `emitFiles`</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;"> （</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">emitter</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">.</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">ts</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;"> 中的函数</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">）</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">      emitFile</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">jsFilePath</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">targetSourceFile</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">) -&gt;</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#DCDCAA;">        emitJavaScript</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">(</span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">jsFilePath</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">, </span><span style="--shiki-light:#001080;--shiki-dark:#9CDCFE;">targetSourceFile</span><span style="--shiki-light:#000000;--shiki-dark:#D4D4D4;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>另一个发射器declarationEmitter.ts用于为 TypeScript 源文件（.ts） 创建声明文件（.d.ts）。</p></li><li><p><strong>core.ts</strong> ：TypeScript 编译器使用的核心工具集。let objectAllocator: ObjectAllocator 是一个定义为全局单例的变量。提供以下定义：</p><ol><li>getNodeConstructor；</li><li>getSymbolConstructor；</li><li>getTypeConstructor；</li><li>getSignatureConstructor（签名是索引，调用和构造签名）。</li></ol></li><li><p><strong>types.ts</strong>：包含整个编译器中使用的关键数据结构和接口，关键部分有:</p><ol><li>SyntaxKind AST 节点类型通过 SyntaxKind 枚举进行识别；</li><li>TypeChecker 类型检查器提供此接口；</li><li>CompilerHost 用于程序（Program）和系统之间的交互；</li><li>Node AST 节点。</li></ol></li><li><p><strong>system.ts</strong>：可以将其视为操作环境（OE, Operating Environment）；TypeScript 编译器与操作系统的所有交互均通过 System 接口进行。接口及其实现（WScript 和 Node）均定义在system.ts中。</p></li><li><p><strong>program.ts</strong>：编译上下文在 TypeScript 编译器中被视为一个 Program，它包含 SourceFile 和编译选项。CompilerHost 是与操作环境（OE, Operating Enviornment）进行交互的机制。用 CompilerHost 作中间层的原因是可以让接口对 Program 的需求进行细粒度的调整，而无需考虑操作环境的需求。程序的getSourceFiles API（getSourceFiles(): SourceFile[]）用于获取SourceFile 。得到的每个元素均是一棵抽象语法树的根节点（称做 SourceFile）。</p></li><li><p><strong>AST杂项</strong>（<strong>Trivia</strong>）：杂项是指源文本中对正常理解代码不太重要的部分，例如：空白，注释，冲突标记。为了保持轻量，杂项不会存储在 AST 中。</p><ol><li>通常，token拥有它后面同一行到下一个token之前的所有杂项；该行之后的注释都与下个的token相关。</li><li>对于文件中的前导（leading）和结束（ending）注释：源文件中的第一个 token 拥有所有开始的杂项；而文件最后的一些列杂项则附加到文件结束符上，该 token 长度为 0。</li></ol><p>节点存在 &quot;token start&quot; 和 &quot;full start&quot; 位置，Token Start即文件中一个 token 的文本开始的位置。Full Start是指扫描器从上一个重要 token 之后开始扫描的位置，要注意，full start 甚至会包含前一节点拥有的杂项。AST 节点有 getStart 和 getFullStart API 用于获取以上两种位置。节点的注释通过以下函数获取：</p><ol><li>ts.getLeadingCommentRanges：给定源文本及其位置，返回给定位置后第一个换行符到 token 本身之间的注释范围（可能需要结合 ts.Node.getFullStart 使用）。</li><li>ts.getTrailingCommentRanges 给定源文本及其位置，返回给定位置后第一个换行符之前的注释范围（可能需要结合 ts.Node.getEnd 使用）。</li></ol></li></ol></div></div></main><footer class="VPDocFooter" data-v-7dc5f967 data-v-b186fd51><!--[--><!--]--><div class="edit-info" data-v-b186fd51><div class="edit-link" data-v-b186fd51><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/R2h1/silver-bullet" target="_blank" rel="noreferrer" data-v-b186fd51><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" aria-label="edit icon" data-v-b186fd51><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> Edit this page on Github<!--]--></a></div><div class="last-updated" data-v-b186fd51><p class="VPLastUpdated" data-v-b186fd51 data-v-fcdc9a98>Last Updated: <time datetime="2025-09-12T16:47:54.000Z" data-v-fcdc9a98></time></p></div></div><nav class="prev-next" data-v-b186fd51><div class="pager" data-v-b186fd51><!----></div><div class="pager" data-v-b186fd51><a class="VPLink link pager-link next" href="/silver-bullet/basics/data-structures-algorithms/index" data-v-b186fd51><!--[--><span class="desc" data-v-b186fd51>Next page</span><span class="title" data-v-b186fd51>数据结构与算法</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-0afca6d4 data-v-f6cb1f7b><div class="container" data-v-f6cb1f7b><!----><p class="copyright" data-v-f6cb1f7b>Copyright © 2023-present R2h1</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"about-me.md\":\"BG4-Gt2D\",\"back-end_index.md\":\"DvGdnlLZ\",\"back-end_mongodb.md\":\"DyUoNjqS\",\"back-end_mysql.md\":\"BYjPgL6D\",\"back-end_nginx.md\":\"pfUjP2iZ\",\"back-end_nodejs.md\":\"DkI8I3Qe\",\"back-end_redis.md\":\"BEQvwuDm\",\"basics_data-structures-algorithms_array-string.md\":\"ByOzgfzB\",\"basics_data-structures-algorithms_dp-math.md\":\"BPocYh0M\",\"basics_data-structures-algorithms_heap-hash.md\":\"BgxtLP0T\",\"basics_data-structures-algorithms_index.md\":\"DLrU7MtH\",\"basics_data-structures-algorithms_linklist.md\":\"CTnPkAQZ\",\"basics_data-structures-algorithms_search-sort.md\":\"DxpnfTf_\",\"basics_data-structures-algorithms_stack-queue.md\":\"BniC3MpK\",\"basics_data-structures-algorithms_tree-graph.md\":\"DCGsf_m5\",\"basics_http.md\":\"BTDIMZOw\",\"basics_internet.md\":\"Cdtrl97F\",\"basics_make-up-principle.md\":\"CnOpPlKW\",\"basics_os.md\":\"10tuNq6s\",\"front-end_axios.md\":\"vJsMeiNy\",\"front-end_basics_css_geometric-draw.md\":\"CTkeM-bk\",\"front-end_basics_css_index.md\":\"c3d4r6z2\",\"front-end_basics_css_layout.md\":\"7OTe9cMV\",\"front-end_basics_html_index.md\":\"oMrQXNnI\",\"front-end_basics_index.md\":\"BcCQMLLC\",\"front-end_basics_javascript_data-type.md\":\"BPCJqz9g\",\"front-end_basics_javascript_function.md\":\"CCFrW3dw\",\"front-end_basics_javascript_handwrite.md\":\"D6rhVaIw\",\"front-end_basics_javascript_index.md\":\"B29h4Ncm\",\"front-end_basics_javascript_module.md\":\"qJ1Wm_6q\",\"front-end_basics_javascript_operator.md\":\"BL5aIth0\",\"front-end_basics_javascript_web-api.md\":\"BQjNki9F\",\"front-end_browser.md\":\"Dcs-5f-0\",\"front-end_canvas.md\":\"Bi6VGiqP\",\"front-end_data-govern-exception-monitor.md\":\"BE9-3t7V\",\"front-end_design-patterns.md\":\"BBDqJWpU\",\"front-end_engineering_babel.md\":\"88TyAMqk\",\"front-end_engineering_esbuild.md\":\"CVmMixOA\",\"front-end_engineering_eslint.md\":\"o9ZE7Q4G\",\"front-end_engineering_git.md\":\"L511mnl7\",\"front-end_engineering_index.md\":\"D8Dc6UGb\",\"front-end_engineering_lerna.md\":\"CUICKeCD\",\"front-end_engineering_npm.md\":\"BIFPWZuI\",\"front-end_engineering_pnpm.md\":\"8ZNxCIKy\",\"front-end_engineering_vite.md\":\"CIbFf349\",\"front-end_engineering_webpack.md\":\"C3sdRdGH\",\"front-end_extension-develop.md\":\"DL4I2u6_\",\"front-end_frame_index.md\":\"BSSLY48r\",\"front-end_frame_jquery_index.md\":\"9deir17o\",\"front-end_frame_react_index.md\":\"D7SaCzyp\",\"front-end_frame_vue_index.md\":\"Cwo6jMSl\",\"front-end_hybrid.md\":\"DO_Ul7CO\",\"front-end_lottie.md\":\"DzduWviJ\",\"front-end_mathml.md\":\"DsYTNDy1\",\"front-end_micro-front-end.md\":\"BuLNvNML\",\"front-end_mini-app.md\":\"-KnwNUSs\",\"front-end_performance-optimization.md\":\"DkyVZKzY\",\"front-end_scaffold-develop.md\":\"ConQAHn2\",\"front-end_svg.md\":\"Bw1bD5uP\",\"front-end_typescript_index.md\":\"CPqpwsTo\",\"good-book_mark-logic.md\":\"DjLSvS6a\",\"index.md\":\"BusOCSVS\",\"machine-learning_index.md\":\"No2KM7BW\",\"nginx_index.md\":\"D-k35U_F\",\"projects_edemao_index.md\":\"BkJEBmSe\",\"projects_low-code-platform_guosen.md\":\"BiwMYcFC\",\"projects_low-code-platform_seeyon.md\":\"CZRaiVxE\",\"projects_music-webapp_index.md\":\"BLX1tkJT\",\"projects_theater_my-watchlist.md\":\"C9SSZG3g\",\"projects_theater_save-point.md\":\"C2Xnvv6Z\",\"projects_theater_slide-video.md\":\"Da3mmmLz\",\"soft-skill_eq.md\":\"CkPHZfWC\",\"soft-skill_job-develop-plan.md\":\"C75mXUZQ\",\"soft-skill_ppt.md\":\"CoTtqVpf\",\"tools_base64-converter.md\":\"BwPZ31cX\",\"tools_bmi-calculator.md\":\"DF0fQrE5\",\"tools_color-converter.md\":\"CA0AYM9g\",\"tools_index.md\":\"BgIDCDrW\",\"tools_json-formatter.md\":\"DLxKvhDE\",\"tools_lottery-wheel.md\":\"BBdtM4mt\",\"tools_password-generator.md\":\"eddrV6wZ\",\"tools_poem-generator.md\":\"CG7sS9_1\",\"tools_qr-generator.md\":\"D-6xQ1Fl\",\"tools_quote-generator.md\":\"C7hE0ZpM\",\"tools_random-generator.md\":\"KYmGBcu6\",\"tools_regex-tester.md\":\"BsW6y2Pg\",\"tools_superlotto.md\":\"CcYRGS02\",\"tools_text-processor.md\":\"_cZI1_L5\",\"tools_timestamp-converter.md\":\"Dpbq3d95\",\"tools_unit-converter.md\":\"UnY8E_pN\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Silver Bullet\",\"description\":\"前端修炼手册：也许，求知的道路上，未必就没有银色子弹\",\"base\":\"/silver-bullet/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/logo.png\",\"search\":{\"provider\":\"local\",\"options\":{\"locales\":{\"root\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}}}},\"outline\":[1,4],\"nav\":[{\"text\":\"计算机基础\",\"link\":\"/basics/data-structures-algorithms/index\"},{\"text\":\"前端基础\",\"link\":\"front-end/basics/index\"},{\"text\":\"前端工程化\",\"link\":\"/front-end/engineering/index\"},{\"text\":\"工具合集\",\"link\":\"/tools/index\"}],\"sidebar\":[{\"text\":\"计算机基础\",\"collapsed\":false,\"items\":[{\"text\":\"数据结构与算法\",\"collapsed\":true,\"link\":\"/basics/data-structures-algorithms/index\",\"items\":[{\"text\":\"数组和字符串\",\"link\":\"/basics/data-structures-algorithms/array-string\"},{\"text\":\"链表\",\"link\":\"/basics/data-structures-algorithms/linkList\"},{\"text\":\"栈和队列\",\"link\":\"/basics/data-structures-algorithms/stack-queue\"},{\"text\":\"树和图\",\"link\":\"/basics/data-structures-algorithms/tree-graph\"},{\"text\":\"堆和散列表\",\"link\":\"/basics/data-structures-algorithms/heap-hash\"},{\"text\":\"查找和排序\",\"link\":\"/basics/data-structures-algorithms/search-sort\"},{\"text\":\"动态规划和数学\",\"link\":\"/basics/data-structures-algorithms/dp-math\"}]},{\"text\":\"网络\",\"link\":\"/basics/internet\",\"items\":[{\"text\":\"HTTP\",\"link\":\"/basics/http\"}]},{\"text\":\"操作系统\",\"link\":\"/basics/os\"},{\"text\":\"组成原理\",\"link\":\"/basics/make-up-principle\"}]},{\"text\":\"前端基础\",\"link\":\"/front-end/basics/index\",\"items\":[{\"text\":\"html\",\"link\":\"/front-end/basics/html/index\"},{\"text\":\"css\",\"link\":\"/front-end/basics/css/index\",\"collapsed\":true,\"items\":[{\"text\":\"布局\",\"link\":\"/front-end/basics/css/layout\"},{\"text\":\"几何图形绘制\",\"link\":\"/front-end/basics/css/geometric-draw\"}]},{\"text\":\"javascript\",\"link\":\"/front-end/basics/javascript/index\",\"collapsed\":true,\"items\":[{\"text\":\"数据类型\",\"link\":\"/front-end/basics/javascript/data-type\"},{\"text\":\"函数相关\",\"link\":\"/front-end/basics/javascript/function\"},{\"text\":\"运算符相关\",\"link\":\"/front-end/basics/javascript/operator\"},{\"text\":\"Web API\",\"link\":\"/front-end/basics/javascript/web-api\"},{\"text\":\"模块化\",\"link\":\"/front-end/basics/javascript/module\"},{\"text\":\"手写实现相关\",\"link\":\"/front-end/basics/javascript/handwrite\"}]}]},{\"text\":\"typescript\",\"link\":\"/front-end/typescript/index\",\"items\":[]},{\"text\":\"设计模式\",\"items\":[{\"text\":\"前端常用设计模式\",\"link\":\"/front-end/design-patterns\"}]},{\"text\":\"前端框架\",\"link\":\"/front-end/frame/index\",\"collapsed\":true,\"items\":[{\"text\":\"jquery\",\"link\":\"/front-end/frame/jquery/index\"},{\"text\":\"vue\",\"link\":\"/front-end/frame/vue/index\"},{\"text\":\"react\",\"link\":\"/front-end/frame/react/index\"}]},{\"text\":\"浏览器\",\"link\":\"/front-end/browser\",\"items\":[]},{\"text\":\"lottie\",\"link\":\"/front-end/lottie\"},{\"text\":\"前端性能优化\",\"link\":\"/front-end/performance-optimization\"},{\"text\":\"微前端\",\"link\":\"/front-end/micro-front-end\",\"items\":[]},{\"text\":\"混合开发\",\"items\":[{\"text\":\"跨平台\",\"link\":\"/front-end/hybrid\"}]},{\"text\":\"前端数据治理与异常监控\",\"items\":[{\"text\":\"前端数据治理与异常监控\",\"link\":\"/front-end/data-govern-exception-monitor\"}]},{\"text\":\"前端工程化\",\"link\":\"/front-end/engineering/index\",\"collapsed\":true,\"items\":[{\"text\":\"git\",\"link\":\"/front-end/engineering/git\"},{\"text\":\"webpack\",\"link\":\"/front-end/engineering/webpack\"},{\"text\":\"babel\",\"link\":\"/front-end/engineering/babel\"},{\"text\":\"eslint\",\"link\":\"/front-end/engineering/eslint\"},{\"text\":\"esbuild\",\"link\":\"/front-end/engineering/esbuild\"},{\"text\":\"pnpm\",\"link\":\"/front-end/engineering/pnpm\"},{\"text\":\"npm\",\"link\":\"/front-end/engineering/npm\"},{\"text\":\"vite\",\"link\":\"/front-end/engineering/vite\"}]},{\"text\":\"扩展开发\",\"link\":\"/front-end/browser-extension\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/R2h1/silver-bullet\"}],\"editLink\":{\"pattern\":\"https://github.com/R2h1/silver-bullet\",\"text\":\"Edit this page on Github\"},\"lastUpdatedText\":\"Last Updated\",\"footer\":{\"copyright\":\"Copyright © 2023-present R2h1\"}},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":true}");</script>
    
  </body>
</html>